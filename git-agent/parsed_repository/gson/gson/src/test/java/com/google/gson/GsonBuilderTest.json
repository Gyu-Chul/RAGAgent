[
  {
    "type": "package",
    "name": "com.google.gson",
    "start_line": 17,
    "end_line": 17,
    "code": "package com.google.gson;\r\n\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java"
  },
  {
    "type": "import",
    "name": "com.google.common.truth.Truth.assertThat",
    "start_line": 19,
    "end_line": 19,
    "code": "import static com.google.common.truth.Truth.assertThat;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java"
  },
  {
    "type": "import",
    "name": "org.junit.Assert.assertThrows",
    "start_line": 20,
    "end_line": 20,
    "code": "import static org.junit.Assert.assertThrows;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.stream.JsonReader",
    "start_line": 22,
    "end_line": 22,
    "code": "import com.google.gson.stream.JsonReader;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.stream.JsonWriter",
    "start_line": 23,
    "end_line": 23,
    "code": "import com.google.gson.stream.JsonWriter;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java"
  },
  {
    "type": "import",
    "name": "java.io.IOException",
    "start_line": 24,
    "end_line": 24,
    "code": "import java.io.IOException;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java"
  },
  {
    "type": "import",
    "name": "java.io.StringReader",
    "start_line": 25,
    "end_line": 25,
    "code": "import java.io.StringReader;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java"
  },
  {
    "type": "import",
    "name": "java.io.StringWriter",
    "start_line": 26,
    "end_line": 26,
    "code": "import java.io.StringWriter;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java"
  },
  {
    "type": "import",
    "name": "java.lang.reflect.Modifier",
    "start_line": 27,
    "end_line": 27,
    "code": "import java.lang.reflect.Modifier;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java"
  },
  {
    "type": "import",
    "name": "java.lang.reflect.Type",
    "start_line": 28,
    "end_line": 28,
    "code": "import java.lang.reflect.Type;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java"
  },
  {
    "type": "import",
    "name": "java.text.DateFormat",
    "start_line": 29,
    "end_line": 29,
    "code": "import java.text.DateFormat;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java"
  },
  {
    "type": "import",
    "name": "java.util.Date",
    "start_line": 30,
    "end_line": 30,
    "code": "import java.util.Date;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java"
  },
  {
    "type": "import",
    "name": "org.junit.Ignore",
    "start_line": 31,
    "end_line": 31,
    "code": "import org.junit.Ignore;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java"
  },
  {
    "type": "import",
    "name": "org.junit.Test",
    "start_line": 32,
    "end_line": 32,
    "code": "import org.junit.Test;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java"
  },
  {
    "type": "class",
    "name": "GsonBuilderTest",
    "start_line": 39,
    "end_line": 432,
    "code": "/**\r\n * Unit tests for {@link GsonBuilder}.\r\n *\r\n * @author Inderjeet Singh\r\n */\r\npublic class GsonBuilderTest {\r\n\r\n    private static final TypeAdapter<Object> NULL_TYPE_ADAPTER = new TypeAdapter<>() {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Object value) {\r\n            throw new AssertionError();\r\n        }\r\n\r\n        @Override\r\n        public Object read(JsonReader in) {\r\n            throw new AssertionError();\r\n        }\r\n    };\r\n\r\n    @Test\r\n    public void testCreatingMoreThanOnce() {\r\n        GsonBuilder builder = new GsonBuilder();\r\n        Gson gson = builder.create();\r\n        assertThat(gson).isNotNull();\r\n        assertThat(builder.create()).isNotNull();\r\n        builder.setFieldNamingStrategy(f -> \"test\");\r\n        Gson otherGson = builder.create();\r\n        assertThat(otherGson).isNotNull();\r\n        // Should be different instances because builder has been modified in the meantime\r\n        assertThat(gson).isNotSameInstanceAs(otherGson);\r\n    }\r\n\r\n    /**\r\n     * Gson instances should not be affected by subsequent modification of GsonBuilder which created\r\n     * them.\r\n     */\r\n    @Test\r\n    public void testModificationAfterCreate() {\r\n        GsonBuilder gsonBuilder = new GsonBuilder();\r\n        Gson gson = gsonBuilder.create();\r\n        // Modifications of `gsonBuilder` should not affect `gson` object\r\n        gsonBuilder.registerTypeAdapter(CustomClass1.class, new TypeAdapter<CustomClass1>() {\r\n\r\n            @Override\r\n            public CustomClass1 read(JsonReader in) {\r\n                throw new UnsupportedOperationException();\r\n            }\r\n\r\n            @Override\r\n            public void write(JsonWriter out, CustomClass1 value) throws IOException {\r\n                out.value(\"custom-adapter\");\r\n            }\r\n        });\r\n        gsonBuilder.registerTypeHierarchyAdapter(CustomClass2.class, (JsonSerializer<CustomClass2>) (src, typeOfSrc, context) -> new JsonPrimitive(\"custom-hierarchy-adapter\"));\r\n        gsonBuilder.registerTypeAdapter(CustomClass3.class, (InstanceCreator<CustomClass3>) type -> new CustomClass3(\"custom-instance\"));\r\n        assertDefaultGson(gson);\r\n        // New GsonBuilder created from `gson` should not have been affected by changes\r\n        // to `gsonBuilder` either\r\n        assertDefaultGson(gson.newBuilder().create());\r\n        // New Gson instance from modified GsonBuilder should be affected by changes\r\n        assertCustomGson(gsonBuilder.create());\r\n    }\r\n\r\n    private static void assertDefaultGson(Gson gson) {\r\n        // Should use default reflective adapter\r\n        String json1 = gson.toJson(new CustomClass1());\r\n        assertThat(json1).isEqualTo(\"{}\");\r\n        // Should use default reflective adapter\r\n        String json2 = gson.toJson(new CustomClass2());\r\n        assertThat(json2).isEqualTo(\"{}\");\r\n        // Should use default instance creator\r\n        CustomClass3 customClass3 = gson.fromJson(\"{}\", CustomClass3.class);\r\n        assertThat(customClass3.s).isEqualTo(CustomClass3.NO_ARG_CONSTRUCTOR_VALUE);\r\n    }\r\n\r\n    private static void assertCustomGson(Gson gson) {\r\n        String json1 = gson.toJson(new CustomClass1());\r\n        assertThat(json1).isEqualTo(\"\\\"custom-adapter\\\"\");\r\n        String json2 = gson.toJson(new CustomClass2());\r\n        assertThat(json2).isEqualTo(\"\\\"custom-hierarchy-adapter\\\"\");\r\n        CustomClass3 customClass3 = gson.fromJson(\"{}\", CustomClass3.class);\r\n        assertThat(customClass3.s).isEqualTo(\"custom-instance\");\r\n    }\r\n\r\n    static class CustomClass1 {\r\n    }\r\n\r\n    static class CustomClass2 {\r\n    }\r\n\r\n    static class CustomClass3 {\r\n\r\n        static final String NO_ARG_CONSTRUCTOR_VALUE = \"default instance\";\r\n\r\n        final String s;\r\n\r\n        public CustomClass3(String s) {\r\n            this.s = s;\r\n        }\r\n\r\n        public CustomClass3() {\r\n            this(NO_ARG_CONSTRUCTOR_VALUE);\r\n        }\r\n    }\r\n\r\n    @Test\r\n    public void testExcludeFieldsWithModifiers() {\r\n        Gson gson = new GsonBuilder().excludeFieldsWithModifiers(Modifier.VOLATILE, Modifier.PRIVATE).create();\r\n        assertThat(gson.toJson(new HasModifiers())).isEqualTo(\"{\\\"d\\\":\\\"d\\\"}\");\r\n    }\r\n\r\n    @SuppressWarnings(\"unused\")\r\n    static class HasModifiers {\r\n\r\n        private String a = \"a\";\r\n\r\n        volatile String b = \"b\";\r\n\r\n        private volatile String c = \"c\";\r\n\r\n        String d = \"d\";\r\n    }\r\n\r\n    @Test\r\n    public void testTransientFieldExclusion() {\r\n        Gson gson = new GsonBuilder().excludeFieldsWithModifiers().create();\r\n        assertThat(gson.toJson(new HasTransients())).isEqualTo(\"{\\\"a\\\":\\\"a\\\"}\");\r\n    }\r\n\r\n    static class HasTransients {\r\n\r\n        transient String a = \"a\";\r\n    }\r\n\r\n    @Test\r\n    public void testRegisterTypeAdapterForCoreType() {\r\n        Type[] types = { byte.class, int.class, double.class, Short.class, Long.class, String.class };\r\n        for (Type type : types) {\r\n            new GsonBuilder().registerTypeAdapter(type, NULL_TYPE_ADAPTER);\r\n        }\r\n    }\r\n\r\n    @Test\r\n    public void testDisableJdkUnsafe() {\r\n        Gson gson = new GsonBuilder().disableJdkUnsafe().create();\r\n        var e = assertThrows(JsonIOException.class, () -> gson.fromJson(\"{}\", ClassWithoutNoArgsConstructor.class));\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Unable to create instance of class\" + \" com.google.gson.GsonBuilderTest$ClassWithoutNoArgsConstructor; usage of JDK\" + \" Unsafe is disabled. Registering an InstanceCreator or a TypeAdapter for this\" + \" type, adding a no-args constructor, or enabling usage of JDK Unsafe may fix\" + \" this problem.\");\r\n    }\r\n\r\n    private static class ClassWithoutNoArgsConstructor {\r\n\r\n        @SuppressWarnings(\"unused\")\r\n        public ClassWithoutNoArgsConstructor(String s) {\r\n        }\r\n    }\r\n\r\n    @Test\r\n    public void testSetVersionInvalid() {\r\n        GsonBuilder builder = new GsonBuilder();\r\n        var e = assertThrows(IllegalArgumentException.class, () -> builder.setVersion(Double.NaN));\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Invalid version: NaN\");\r\n        e = assertThrows(IllegalArgumentException.class, () -> builder.setVersion(-0.1));\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Invalid version: -0.1\");\r\n    }\r\n\r\n    @Test\r\n    public void testDefaultStrictness() throws IOException {\r\n        GsonBuilder builder = new GsonBuilder();\r\n        Gson gson = builder.create();\r\n        assertThat(gson.newJsonReader(new StringReader(\"{}\")).getStrictness()).isEqualTo(Strictness.LEGACY_STRICT);\r\n        assertThat(gson.newJsonWriter(new StringWriter()).getStrictness()).isEqualTo(Strictness.LEGACY_STRICT);\r\n    }\r\n\r\n    // for GsonBuilder.setLenient\r\n    @SuppressWarnings({ \"deprecation\", \"InlineMeInliner\" })\r\n    @Test\r\n    public void testSetLenient() throws IOException {\r\n        GsonBuilder builder = new GsonBuilder();\r\n        builder.setLenient();\r\n        Gson gson = builder.create();\r\n        assertThat(gson.newJsonReader(new StringReader(\"{}\")).getStrictness()).isEqualTo(Strictness.LENIENT);\r\n        assertThat(gson.newJsonWriter(new StringWriter()).getStrictness()).isEqualTo(Strictness.LENIENT);\r\n    }\r\n\r\n    @Test\r\n    public void testSetStrictness() throws IOException {\r\n        Strictness strictness = Strictness.STRICT;\r\n        GsonBuilder builder = new GsonBuilder();\r\n        builder.setStrictness(strictness);\r\n        Gson gson = builder.create();\r\n        assertThat(gson.newJsonReader(new StringReader(\"{}\")).getStrictness()).isEqualTo(strictness);\r\n        assertThat(gson.newJsonWriter(new StringWriter()).getStrictness()).isEqualTo(strictness);\r\n    }\r\n\r\n    @Test\r\n    public void testRegisterTypeAdapterNotAdapterClass() {\r\n        GsonBuilder gsonBuilder = new GsonBuilder();\r\n        IllegalArgumentException e = assertThrows(IllegalArgumentException.class, () -> gsonBuilder.registerTypeAdapter(Integer.class, \"test\"));\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Class java.lang.String does not implement any supported type adapter class or\" + \" interface\");\r\n    }\r\n\r\n    @Test\r\n    public void testRegisterTypeAdapterForObjectAndJsonElements() {\r\n        String errorMessage = \"Cannot override built-in adapter for \";\r\n        Type[] types = { Object.class // TODO: Registering adapter for JsonElement is allowed (for now) for backward compatibility,\r\n        //   see https://github.com/google/gson/issues/2787\r\n        // JsonElement.class, JsonArray.class,\r\n        };\r\n        GsonBuilder gsonBuilder = new GsonBuilder();\r\n        for (Type type : types) {\r\n            IllegalArgumentException e = assertThrows(IllegalArgumentException.class, () -> gsonBuilder.registerTypeAdapter(type, NULL_TYPE_ADAPTER));\r\n            assertThat(e).hasMessageThat().isEqualTo(errorMessage + type);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Verifies that (for now) registering adapter for {@link JsonElement} and subclasses is possible,\r\n     * but has no effect. See {@link #testRegisterTypeAdapterForObjectAndJsonElements()}.\r\n     */\r\n    @Test\r\n    public void testRegisterTypeAdapterForJsonElements() {\r\n        Gson gson = new GsonBuilder().registerTypeAdapter(JsonArray.class, NULL_TYPE_ADAPTER).create();\r\n        TypeAdapter<JsonArray> adapter = gson.getAdapter(JsonArray.class);\r\n        // Does not use registered adapter\r\n        assertThat(adapter).isNotSameInstanceAs(NULL_TYPE_ADAPTER);\r\n        assertThat(adapter.toJson(new JsonArray())).isEqualTo(\"[]\");\r\n    }\r\n\r\n    @Test\r\n    public void testRegisterTypeHierarchyAdapterNotAdapterClass() {\r\n        GsonBuilder gsonBuilder = new GsonBuilder();\r\n        IllegalArgumentException e = assertThrows(IllegalArgumentException.class, () -> gsonBuilder.registerTypeHierarchyAdapter(Integer.class, \"test\"));\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Class java.lang.String does not implement any supported type adapter class or\" + \" interface\");\r\n    }\r\n\r\n    @Ignore(\"Registering adapter for JsonElement is allowed (for now) for backward compatibility, see\" + \" https://github.com/google/gson/issues/2787\")\r\n    @Test\r\n    public void testRegisterTypeHierarchyAdapterJsonElements() {\r\n        String errorMessage = \"Cannot override built-in adapter for \";\r\n        Class<?>[] types = { JsonElement.class, JsonArray.class };\r\n        GsonBuilder gsonBuilder = new GsonBuilder();\r\n        for (Class<?> type : types) {\r\n            IllegalArgumentException e = assertThrows(IllegalArgumentException.class, () -> gsonBuilder.registerTypeHierarchyAdapter(type, NULL_TYPE_ADAPTER));\r\n            assertThat(e).hasMessageThat().isEqualTo(errorMessage + type);\r\n        }\r\n        // But registering type hierarchy adapter for Object should be allowed\r\n        gsonBuilder.registerTypeHierarchyAdapter(Object.class, NULL_TYPE_ADAPTER);\r\n    }\r\n\r\n    /**\r\n     * Verifies that (for now) registering hierarchy adapter for {@link JsonElement} and subclasses is\r\n     * possible, but has no effect. See {@link #testRegisterTypeHierarchyAdapterJsonElements()}.\r\n     */\r\n    @Test\r\n    public void testRegisterTypeHierarchyAdapterJsonElements_Allowed() {\r\n        Gson gson = new GsonBuilder().registerTypeHierarchyAdapter(JsonArray.class, NULL_TYPE_ADAPTER).create();\r\n        TypeAdapter<JsonArray> adapter = gson.getAdapter(JsonArray.class);\r\n        // Does not use registered adapter\r\n        assertThat(adapter).isNotSameInstanceAs(NULL_TYPE_ADAPTER);\r\n        assertThat(adapter.toJson(new JsonArray())).isEqualTo(\"[]\");\r\n    }\r\n\r\n    @Test\r\n    public void testSetDateFormatWithInvalidPattern() {\r\n        GsonBuilder builder = new GsonBuilder();\r\n        String invalidPattern = \"This is an invalid Pattern\";\r\n        IllegalArgumentException e = assertThrows(IllegalArgumentException.class, () -> builder.setDateFormat(invalidPattern));\r\n        assertThat(e).hasMessageThat().isEqualTo(\"The date pattern '\" + invalidPattern + \"' is not valid\");\r\n    }\r\n\r\n    @Test\r\n    public void testSetDateFormatWithValidPattern() {\r\n        GsonBuilder builder = new GsonBuilder();\r\n        String validPattern = \"yyyy-MM-dd\";\r\n        // Should not throw an exception\r\n        builder.setDateFormat(validPattern);\r\n    }\r\n\r\n    @Test\r\n    public void testSetDateFormatNullPattern() {\r\n        GsonBuilder builder = new GsonBuilder();\r\n        @SuppressWarnings(\"JavaUtilDate\")\r\n        Date date = new Date(0);\r\n        String originalFormatted = builder.create().toJson(date);\r\n        String customFormatted = builder.setDateFormat(\"yyyy-MM-dd\").create().toJson(date);\r\n        assertThat(customFormatted).isNotEqualTo(originalFormatted);\r\n        // `null` should reset the format to the default\r\n        String resetFormatted = builder.setDateFormat(null).create().toJson(date);\r\n        assertThat(resetFormatted).isEqualTo(originalFormatted);\r\n    }\r\n\r\n    /**\r\n     * Tests behavior for an empty date pattern; this behavior is not publicly documented at the\r\n     * moment.\r\n     */\r\n    @Test\r\n    public void testSetDateFormatEmptyPattern() {\r\n        GsonBuilder builder = new GsonBuilder();\r\n        @SuppressWarnings(\"JavaUtilDate\")\r\n        Date date = new Date(0);\r\n        String originalFormatted = builder.create().toJson(date);\r\n        String emptyFormatted = builder.setDateFormat(\"    \").create().toJson(date);\r\n        // Empty pattern was ignored\r\n        assertThat(emptyFormatted).isEqualTo(originalFormatted);\r\n    }\r\n\r\n    // for GsonBuilder.setDateFormat(int)\r\n    @SuppressWarnings(\"deprecation\")\r\n    @Test\r\n    public void testSetDateFormatValidStyle() {\r\n        GsonBuilder builder = new GsonBuilder();\r\n        int[] validStyles = { DateFormat.FULL, DateFormat.LONG, DateFormat.MEDIUM, DateFormat.SHORT };\r\n        for (int style : validStyles) {\r\n            // Should not throw an exception\r\n            builder.setDateFormat(style);\r\n            builder.setDateFormat(style, style);\r\n        }\r\n    }\r\n\r\n    // for GsonBuilder.setDateFormat(int)\r\n    @SuppressWarnings(\"deprecation\")\r\n    @Test\r\n    public void testSetDateFormatInvalidStyle() {\r\n        GsonBuilder builder = new GsonBuilder();\r\n        IllegalArgumentException e = assertThrows(IllegalArgumentException.class, () -> builder.setDateFormat(-1));\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Invalid style: -1\");\r\n        e = assertThrows(IllegalArgumentException.class, () -> builder.setDateFormat(4));\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Invalid style: 4\");\r\n        e = assertThrows(IllegalArgumentException.class, () -> builder.setDateFormat(-1, DateFormat.FULL));\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Invalid style: -1\");\r\n        e = assertThrows(IllegalArgumentException.class, () -> builder.setDateFormat(DateFormat.FULL, -1));\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Invalid style: -1\");\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java"
  },
  {
    "type": "field",
    "name": "NULL_TYPE_ADAPTER",
    "start_line": 40,
    "end_line": 51,
    "code": "private static final TypeAdapter<Object> NULL_TYPE_ADAPTER = new TypeAdapter<>() {\r\n\r\n    @Override\r\n    public void write(JsonWriter out, Object value) {\r\n        throw new AssertionError();\r\n    }\r\n\r\n    @Override\r\n    public Object read(JsonReader in) {\r\n        throw new AssertionError();\r\n    }\r\n};",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java"
  },
  {
    "type": "method",
    "name": "testCreatingMoreThanOnce",
    "start_line": 53,
    "end_line": 66,
    "code": "@Test\r\npublic void testCreatingMoreThanOnce() {\r\n    GsonBuilder builder = new GsonBuilder();\r\n    Gson gson = builder.create();\r\n    assertThat(gson).isNotNull();\r\n    assertThat(builder.create()).isNotNull();\r\n    builder.setFieldNamingStrategy(f -> \"test\");\r\n    Gson otherGson = builder.create();\r\n    assertThat(otherGson).isNotNull();\r\n    // Should be different instances because builder has been modified in the meantime\r\n    assertThat(gson).isNotSameInstanceAs(otherGson);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java"
  },
  {
    "type": "method",
    "name": "testModificationAfterCreate",
    "start_line": 72,
    "end_line": 108,
    "code": "/**\r\n * Gson instances should not be affected by subsequent modification of GsonBuilder which created\r\n * them.\r\n */\r\n@Test\r\npublic void testModificationAfterCreate() {\r\n    GsonBuilder gsonBuilder = new GsonBuilder();\r\n    Gson gson = gsonBuilder.create();\r\n    // Modifications of `gsonBuilder` should not affect `gson` object\r\n    gsonBuilder.registerTypeAdapter(CustomClass1.class, new TypeAdapter<CustomClass1>() {\r\n\r\n        @Override\r\n        public CustomClass1 read(JsonReader in) {\r\n            throw new UnsupportedOperationException();\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, CustomClass1 value) throws IOException {\r\n            out.value(\"custom-adapter\");\r\n        }\r\n    });\r\n    gsonBuilder.registerTypeHierarchyAdapter(CustomClass2.class, (JsonSerializer<CustomClass2>) (src, typeOfSrc, context) -> new JsonPrimitive(\"custom-hierarchy-adapter\"));\r\n    gsonBuilder.registerTypeAdapter(CustomClass3.class, (InstanceCreator<CustomClass3>) type -> new CustomClass3(\"custom-instance\"));\r\n    assertDefaultGson(gson);\r\n    // New GsonBuilder created from `gson` should not have been affected by changes\r\n    // to `gsonBuilder` either\r\n    assertDefaultGson(gson.newBuilder().create());\r\n    // New Gson instance from modified GsonBuilder should be affected by changes\r\n    assertCustomGson(gsonBuilder.create());\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java"
  },
  {
    "type": "method",
    "name": "assertDefaultGson",
    "start_line": 110,
    "end_line": 122,
    "code": "private static void assertDefaultGson(Gson gson) {\r\n    // Should use default reflective adapter\r\n    String json1 = gson.toJson(new CustomClass1());\r\n    assertThat(json1).isEqualTo(\"{}\");\r\n    // Should use default reflective adapter\r\n    String json2 = gson.toJson(new CustomClass2());\r\n    assertThat(json2).isEqualTo(\"{}\");\r\n    // Should use default instance creator\r\n    CustomClass3 customClass3 = gson.fromJson(\"{}\", CustomClass3.class);\r\n    assertThat(customClass3.s).isEqualTo(CustomClass3.NO_ARG_CONSTRUCTOR_VALUE);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java"
  },
  {
    "type": "method",
    "name": "assertCustomGson",
    "start_line": 124,
    "end_line": 133,
    "code": "private static void assertCustomGson(Gson gson) {\r\n    String json1 = gson.toJson(new CustomClass1());\r\n    assertThat(json1).isEqualTo(\"\\\"custom-adapter\\\"\");\r\n    String json2 = gson.toJson(new CustomClass2());\r\n    assertThat(json2).isEqualTo(\"\\\"custom-hierarchy-adapter\\\"\");\r\n    CustomClass3 customClass3 = gson.fromJson(\"{}\", CustomClass3.class);\r\n    assertThat(customClass3.s).isEqualTo(\"custom-instance\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java"
  },
  {
    "type": "method",
    "name": "testExcludeFieldsWithModifiers",
    "start_line": 153,
    "end_line": 158,
    "code": "@Test\r\npublic void testExcludeFieldsWithModifiers() {\r\n    Gson gson = new GsonBuilder().excludeFieldsWithModifiers(Modifier.VOLATILE, Modifier.PRIVATE).create();\r\n    assertThat(gson.toJson(new HasModifiers())).isEqualTo(\"{\\\"d\\\":\\\"d\\\"}\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java"
  },
  {
    "type": "method",
    "name": "testTransientFieldExclusion",
    "start_line": 168,
    "end_line": 172,
    "code": "@Test\r\npublic void testTransientFieldExclusion() {\r\n    Gson gson = new GsonBuilder().excludeFieldsWithModifiers().create();\r\n    assertThat(gson.toJson(new HasTransients())).isEqualTo(\"{\\\"a\\\":\\\"a\\\"}\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java"
  },
  {
    "type": "method",
    "name": "testRegisterTypeAdapterForCoreType",
    "start_line": 178,
    "end_line": 186,
    "code": "@Test\r\npublic void testRegisterTypeAdapterForCoreType() {\r\n    Type[] types = { byte.class, int.class, double.class, Short.class, Long.class, String.class };\r\n    for (Type type : types) {\r\n        new GsonBuilder().registerTypeAdapter(type, NULL_TYPE_ADAPTER);\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java"
  },
  {
    "type": "method",
    "name": "testDisableJdkUnsafe",
    "start_line": 188,
    "end_line": 202,
    "code": "@Test\r\npublic void testDisableJdkUnsafe() {\r\n    Gson gson = new GsonBuilder().disableJdkUnsafe().create();\r\n    var e = assertThrows(JsonIOException.class, () -> gson.fromJson(\"{}\", ClassWithoutNoArgsConstructor.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Unable to create instance of class\" + \" com.google.gson.GsonBuilderTest$ClassWithoutNoArgsConstructor; usage of JDK\" + \" Unsafe is disabled. Registering an InstanceCreator or a TypeAdapter for this\" + \" type, adding a no-args constructor, or enabling usage of JDK Unsafe may fix\" + \" this problem.\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java"
  },
  {
    "type": "method",
    "name": "testSetVersionInvalid",
    "start_line": 209,
    "end_line": 217,
    "code": "@Test\r\npublic void testSetVersionInvalid() {\r\n    GsonBuilder builder = new GsonBuilder();\r\n    var e = assertThrows(IllegalArgumentException.class, () -> builder.setVersion(Double.NaN));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Invalid version: NaN\");\r\n    e = assertThrows(IllegalArgumentException.class, () -> builder.setVersion(-0.1));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Invalid version: -0.1\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java"
  },
  {
    "type": "method",
    "name": "testDefaultStrictness",
    "start_line": 219,
    "end_line": 227,
    "code": "@Test\r\npublic void testDefaultStrictness() throws IOException {\r\n    GsonBuilder builder = new GsonBuilder();\r\n    Gson gson = builder.create();\r\n    assertThat(gson.newJsonReader(new StringReader(\"{}\")).getStrictness()).isEqualTo(Strictness.LEGACY_STRICT);\r\n    assertThat(gson.newJsonWriter(new StringWriter()).getStrictness()).isEqualTo(Strictness.LEGACY_STRICT);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java"
  },
  {
    "type": "method",
    "name": "testSetLenient",
    "start_line": 229,
    "end_line": 239,
    "code": "// for GsonBuilder.setLenient\r\n@SuppressWarnings({ \"deprecation\", \"InlineMeInliner\" })\r\n@Test\r\npublic void testSetLenient() throws IOException {\r\n    GsonBuilder builder = new GsonBuilder();\r\n    builder.setLenient();\r\n    Gson gson = builder.create();\r\n    assertThat(gson.newJsonReader(new StringReader(\"{}\")).getStrictness()).isEqualTo(Strictness.LENIENT);\r\n    assertThat(gson.newJsonWriter(new StringWriter()).getStrictness()).isEqualTo(Strictness.LENIENT);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java"
  },
  {
    "type": "method",
    "name": "testSetStrictness",
    "start_line": 241,
    "end_line": 249,
    "code": "@Test\r\npublic void testSetStrictness() throws IOException {\r\n    Strictness strictness = Strictness.STRICT;\r\n    GsonBuilder builder = new GsonBuilder();\r\n    builder.setStrictness(strictness);\r\n    Gson gson = builder.create();\r\n    assertThat(gson.newJsonReader(new StringReader(\"{}\")).getStrictness()).isEqualTo(strictness);\r\n    assertThat(gson.newJsonWriter(new StringWriter()).getStrictness()).isEqualTo(strictness);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java"
  },
  {
    "type": "method",
    "name": "testRegisterTypeAdapterNotAdapterClass",
    "start_line": 251,
    "end_line": 263,
    "code": "@Test\r\npublic void testRegisterTypeAdapterNotAdapterClass() {\r\n    GsonBuilder gsonBuilder = new GsonBuilder();\r\n    IllegalArgumentException e = assertThrows(IllegalArgumentException.class, () -> gsonBuilder.registerTypeAdapter(Integer.class, \"test\"));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Class java.lang.String does not implement any supported type adapter class or\" + \" interface\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java"
  },
  {
    "type": "method",
    "name": "testRegisterTypeAdapterForObjectAndJsonElements",
    "start_line": 265,
    "end_line": 282,
    "code": "@Test\r\npublic void testRegisterTypeAdapterForObjectAndJsonElements() {\r\n    String errorMessage = \"Cannot override built-in adapter for \";\r\n    Type[] types = { Object.class // TODO: Registering adapter for JsonElement is allowed (for now) for backward compatibility,\r\n    //   see https://github.com/google/gson/issues/2787\r\n    // JsonElement.class, JsonArray.class,\r\n    };\r\n    GsonBuilder gsonBuilder = new GsonBuilder();\r\n    for (Type type : types) {\r\n        IllegalArgumentException e = assertThrows(IllegalArgumentException.class, () -> gsonBuilder.registerTypeAdapter(type, NULL_TYPE_ADAPTER));\r\n        assertThat(e).hasMessageThat().isEqualTo(errorMessage + type);\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java"
  },
  {
    "type": "method",
    "name": "testRegisterTypeAdapterForJsonElements",
    "start_line": 288,
    "end_line": 295,
    "code": "/**\r\n * Verifies that (for now) registering adapter for {@link JsonElement} and subclasses is possible,\r\n * but has no effect. See {@link #testRegisterTypeAdapterForObjectAndJsonElements()}.\r\n */\r\n@Test\r\npublic void testRegisterTypeAdapterForJsonElements() {\r\n    Gson gson = new GsonBuilder().registerTypeAdapter(JsonArray.class, NULL_TYPE_ADAPTER).create();\r\n    TypeAdapter<JsonArray> adapter = gson.getAdapter(JsonArray.class);\r\n    // Does not use registered adapter\r\n    assertThat(adapter).isNotSameInstanceAs(NULL_TYPE_ADAPTER);\r\n    assertThat(adapter.toJson(new JsonArray())).isEqualTo(\"[]\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java"
  },
  {
    "type": "method",
    "name": "testRegisterTypeHierarchyAdapterNotAdapterClass",
    "start_line": 297,
    "end_line": 309,
    "code": "@Test\r\npublic void testRegisterTypeHierarchyAdapterNotAdapterClass() {\r\n    GsonBuilder gsonBuilder = new GsonBuilder();\r\n    IllegalArgumentException e = assertThrows(IllegalArgumentException.class, () -> gsonBuilder.registerTypeHierarchyAdapter(Integer.class, \"test\"));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Class java.lang.String does not implement any supported type adapter class or\" + \" interface\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java"
  },
  {
    "type": "method",
    "name": "testRegisterTypeHierarchyAdapterJsonElements",
    "start_line": 311,
    "end_line": 331,
    "code": "@Ignore(\"Registering adapter for JsonElement is allowed (for now) for backward compatibility, see\" + \" https://github.com/google/gson/issues/2787\")\r\n@Test\r\npublic void testRegisterTypeHierarchyAdapterJsonElements() {\r\n    String errorMessage = \"Cannot override built-in adapter for \";\r\n    Class<?>[] types = { JsonElement.class, JsonArray.class };\r\n    GsonBuilder gsonBuilder = new GsonBuilder();\r\n    for (Class<?> type : types) {\r\n        IllegalArgumentException e = assertThrows(IllegalArgumentException.class, () -> gsonBuilder.registerTypeHierarchyAdapter(type, NULL_TYPE_ADAPTER));\r\n        assertThat(e).hasMessageThat().isEqualTo(errorMessage + type);\r\n    }\r\n    // But registering type hierarchy adapter for Object should be allowed\r\n    gsonBuilder.registerTypeHierarchyAdapter(Object.class, NULL_TYPE_ADAPTER);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java"
  },
  {
    "type": "method",
    "name": "testRegisterTypeHierarchyAdapterJsonElements_Allowed",
    "start_line": 337,
    "end_line": 345,
    "code": "/**\r\n * Verifies that (for now) registering hierarchy adapter for {@link JsonElement} and subclasses is\r\n * possible, but has no effect. See {@link #testRegisterTypeHierarchyAdapterJsonElements()}.\r\n */\r\n@Test\r\npublic void testRegisterTypeHierarchyAdapterJsonElements_Allowed() {\r\n    Gson gson = new GsonBuilder().registerTypeHierarchyAdapter(JsonArray.class, NULL_TYPE_ADAPTER).create();\r\n    TypeAdapter<JsonArray> adapter = gson.getAdapter(JsonArray.class);\r\n    // Does not use registered adapter\r\n    assertThat(adapter).isNotSameInstanceAs(NULL_TYPE_ADAPTER);\r\n    assertThat(adapter.toJson(new JsonArray())).isEqualTo(\"[]\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java"
  },
  {
    "type": "method",
    "name": "testSetDateFormatWithInvalidPattern",
    "start_line": 347,
    "end_line": 356,
    "code": "@Test\r\npublic void testSetDateFormatWithInvalidPattern() {\r\n    GsonBuilder builder = new GsonBuilder();\r\n    String invalidPattern = \"This is an invalid Pattern\";\r\n    IllegalArgumentException e = assertThrows(IllegalArgumentException.class, () -> builder.setDateFormat(invalidPattern));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"The date pattern '\" + invalidPattern + \"' is not valid\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java"
  },
  {
    "type": "method",
    "name": "testSetDateFormatWithValidPattern",
    "start_line": 358,
    "end_line": 364,
    "code": "@Test\r\npublic void testSetDateFormatWithValidPattern() {\r\n    GsonBuilder builder = new GsonBuilder();\r\n    String validPattern = \"yyyy-MM-dd\";\r\n    // Should not throw an exception\r\n    builder.setDateFormat(validPattern);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java"
  },
  {
    "type": "method",
    "name": "testSetDateFormatNullPattern",
    "start_line": 366,
    "end_line": 379,
    "code": "@Test\r\npublic void testSetDateFormatNullPattern() {\r\n    GsonBuilder builder = new GsonBuilder();\r\n    @SuppressWarnings(\"JavaUtilDate\")\r\n    Date date = new Date(0);\r\n    String originalFormatted = builder.create().toJson(date);\r\n    String customFormatted = builder.setDateFormat(\"yyyy-MM-dd\").create().toJson(date);\r\n    assertThat(customFormatted).isNotEqualTo(originalFormatted);\r\n    // `null` should reset the format to the default\r\n    String resetFormatted = builder.setDateFormat(null).create().toJson(date);\r\n    assertThat(resetFormatted).isEqualTo(originalFormatted);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java"
  },
  {
    "type": "method",
    "name": "testSetDateFormatEmptyPattern",
    "start_line": 385,
    "end_line": 395,
    "code": "/**\r\n * Tests behavior for an empty date pattern; this behavior is not publicly documented at the\r\n * moment.\r\n */\r\n@Test\r\npublic void testSetDateFormatEmptyPattern() {\r\n    GsonBuilder builder = new GsonBuilder();\r\n    @SuppressWarnings(\"JavaUtilDate\")\r\n    Date date = new Date(0);\r\n    String originalFormatted = builder.create().toJson(date);\r\n    String emptyFormatted = builder.setDateFormat(\"    \").create().toJson(date);\r\n    // Empty pattern was ignored\r\n    assertThat(emptyFormatted).isEqualTo(originalFormatted);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java"
  },
  {
    "type": "method",
    "name": "testSetDateFormatValidStyle",
    "start_line": 397,
    "end_line": 408,
    "code": "// for GsonBuilder.setDateFormat(int)\r\n@SuppressWarnings(\"deprecation\")\r\n@Test\r\npublic void testSetDateFormatValidStyle() {\r\n    GsonBuilder builder = new GsonBuilder();\r\n    int[] validStyles = { DateFormat.FULL, DateFormat.LONG, DateFormat.MEDIUM, DateFormat.SHORT };\r\n    for (int style : validStyles) {\r\n        // Should not throw an exception\r\n        builder.setDateFormat(style);\r\n        builder.setDateFormat(style, style);\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java"
  },
  {
    "type": "method",
    "name": "testSetDateFormatInvalidStyle",
    "start_line": 410,
    "end_line": 431,
    "code": "// for GsonBuilder.setDateFormat(int)\r\n@SuppressWarnings(\"deprecation\")\r\n@Test\r\npublic void testSetDateFormatInvalidStyle() {\r\n    GsonBuilder builder = new GsonBuilder();\r\n    IllegalArgumentException e = assertThrows(IllegalArgumentException.class, () -> builder.setDateFormat(-1));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Invalid style: -1\");\r\n    e = assertThrows(IllegalArgumentException.class, () -> builder.setDateFormat(4));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Invalid style: 4\");\r\n    e = assertThrows(IllegalArgumentException.class, () -> builder.setDateFormat(-1, DateFormat.FULL));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Invalid style: -1\");\r\n    e = assertThrows(IllegalArgumentException.class, () -> builder.setDateFormat(DateFormat.FULL, -1));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Invalid style: -1\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonBuilderTest.java"
  }
]