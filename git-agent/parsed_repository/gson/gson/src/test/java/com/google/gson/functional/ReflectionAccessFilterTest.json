[
  {
    "type": "package",
    "name": "com.google.gson.functional",
    "start_line": 17,
    "end_line": 17,
    "code": "package com.google.gson.functional;\r\n\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "import",
    "name": "com.google.common.truth.Truth.assertThat",
    "start_line": 19,
    "end_line": 19,
    "code": "import static com.google.common.truth.Truth.assertThat;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "import",
    "name": "org.junit.Assert.assertThrows",
    "start_line": 20,
    "end_line": 20,
    "code": "import static org.junit.Assert.assertThrows;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.Gson",
    "start_line": 22,
    "end_line": 22,
    "code": "import com.google.gson.Gson;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.GsonBuilder",
    "start_line": 23,
    "end_line": 23,
    "code": "import com.google.gson.GsonBuilder;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.InstanceCreator",
    "start_line": 24,
    "end_line": 24,
    "code": "import com.google.gson.InstanceCreator;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.JsonElement",
    "start_line": 25,
    "end_line": 25,
    "code": "import com.google.gson.JsonElement;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.JsonIOException",
    "start_line": 26,
    "end_line": 26,
    "code": "import com.google.gson.JsonIOException;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.JsonPrimitive",
    "start_line": 27,
    "end_line": 27,
    "code": "import com.google.gson.JsonPrimitive;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.JsonSerializationContext",
    "start_line": 28,
    "end_line": 28,
    "code": "import com.google.gson.JsonSerializationContext;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.JsonSerializer",
    "start_line": 29,
    "end_line": 29,
    "code": "import com.google.gson.JsonSerializer;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.ReflectionAccessFilter",
    "start_line": 30,
    "end_line": 30,
    "code": "import com.google.gson.ReflectionAccessFilter;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.ReflectionAccessFilter.FilterResult",
    "start_line": 31,
    "end_line": 31,
    "code": "import com.google.gson.ReflectionAccessFilter.FilterResult;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.TypeAdapter",
    "start_line": 32,
    "end_line": 32,
    "code": "import com.google.gson.TypeAdapter;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.internal.ConstructorConstructor",
    "start_line": 33,
    "end_line": 33,
    "code": "import com.google.gson.internal.ConstructorConstructor;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.stream.JsonReader",
    "start_line": 34,
    "end_line": 34,
    "code": "import com.google.gson.stream.JsonReader;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.stream.JsonWriter",
    "start_line": 35,
    "end_line": 35,
    "code": "import com.google.gson.stream.JsonWriter;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "import",
    "name": "java.io.File",
    "start_line": 36,
    "end_line": 36,
    "code": "import java.io.File;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "import",
    "name": "java.io.IOException",
    "start_line": 37,
    "end_line": 37,
    "code": "import java.io.IOException;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "import",
    "name": "java.io.Reader",
    "start_line": 38,
    "end_line": 38,
    "code": "import java.io.Reader;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "import",
    "name": "java.lang.reflect.Constructor",
    "start_line": 39,
    "end_line": 39,
    "code": "import java.lang.reflect.Constructor;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "import",
    "name": "java.lang.reflect.Field",
    "start_line": 40,
    "end_line": 40,
    "code": "import java.lang.reflect.Field;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "import",
    "name": "java.lang.reflect.Type",
    "start_line": 41,
    "end_line": 41,
    "code": "import java.lang.reflect.Type;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "import",
    "name": "java.util.ArrayList",
    "start_line": 42,
    "end_line": 42,
    "code": "import java.util.ArrayList;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "import",
    "name": "java.util.LinkedList",
    "start_line": 43,
    "end_line": 43,
    "code": "import java.util.LinkedList;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "import",
    "name": "java.util.List",
    "start_line": 44,
    "end_line": 44,
    "code": "import java.util.List;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "import",
    "name": "org.junit.AssumptionViolatedException",
    "start_line": 45,
    "end_line": 45,
    "code": "import org.junit.AssumptionViolatedException;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "import",
    "name": "org.junit.Test",
    "start_line": 46,
    "end_line": 46,
    "code": "import org.junit.Test;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "class",
    "name": "ReflectionAccessFilterTest",
    "start_line": 48,
    "end_line": 529,
    "code": "public class ReflectionAccessFilterTest {\r\n\r\n    // Reader has protected `lock` field which cannot be accessed\r\n    private static class ClassExtendingJdkClass extends Reader {\r\n\r\n        @Override\r\n        public int read(char[] cbuf, int off, int len) throws IOException {\r\n            return 0;\r\n        }\r\n\r\n        @Override\r\n        public void close() throws IOException {\r\n        }\r\n    }\r\n\r\n    @Test\r\n    public void testBlockInaccessibleJava() {\r\n        Gson gson = new GsonBuilder().addReflectionAccessFilter(ReflectionAccessFilter.BLOCK_INACCESSIBLE_JAVA).create();\r\n        // Serialization should fail for classes with non-public fields\r\n        // Note: This test is rather brittle and depends on the JDK implementation\r\n        var e = assertThrows(\"Expected exception; test needs to be run with Java >= 9\", JsonIOException.class, () -> gson.toJson(new File(\"a\")));\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Field 'java.io.File#path' is not accessible and ReflectionAccessFilter does not\" + \" permit making it accessible. Register a TypeAdapter for the declaring type,\" + \" adjust the access filter or increase the visibility of the element and its\" + \" declaring type.\");\r\n    }\r\n\r\n    @Test\r\n    public void testDontBlockAccessibleJava() throws ReflectiveOperationException {\r\n        Gson gson = new GsonBuilder().addReflectionAccessFilter(ReflectionAccessFilter.BLOCK_INACCESSIBLE_JAVA).create();\r\n        // Serialization should succeed for classes with only public fields.\r\n        // Not many JDK classes have mutable public fields, thank goodness, but java.awt.Point does.\r\n        Class<?> pointClass;\r\n        try {\r\n            pointClass = Class.forName(\"java.awt.Point\");\r\n        } catch (ClassNotFoundException e) {\r\n            // If not found then we don't have AWT and the rest of the test can be skipped.\r\n            throw new AssumptionViolatedException(\"java.awt.Point not present\", e);\r\n        }\r\n        Constructor<?> pointConstructor = pointClass.getConstructor(int.class, int.class);\r\n        Object point = pointConstructor.newInstance(1, 2);\r\n        String json = gson.toJson(point);\r\n        assertThat(json).isEqualTo(\"{\\\"x\\\":1,\\\"y\\\":2}\");\r\n    }\r\n\r\n    @Test\r\n    public void testBlockInaccessibleJavaExtendingJdkClass() {\r\n        Gson gson = new GsonBuilder().addReflectionAccessFilter(ReflectionAccessFilter.BLOCK_INACCESSIBLE_JAVA).create();\r\n        var e = assertThrows(\"Expected exception; test needs to be run with Java >= 9\", JsonIOException.class, () -> gson.toJson(new ClassExtendingJdkClass()));\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Field 'java.io.Reader#lock' is not accessible and ReflectionAccessFilter does not\" + \" permit making it accessible. Register a TypeAdapter for the declaring type,\" + \" adjust the access filter or increase the visibility of the element and its\" + \" declaring type.\");\r\n    }\r\n\r\n    @Test\r\n    public void testBlockAllJava() {\r\n        Gson gson = new GsonBuilder().addReflectionAccessFilter(ReflectionAccessFilter.BLOCK_ALL_JAVA).create();\r\n        // Serialization should fail for any Java class without custom adapter\r\n        var e = assertThrows(JsonIOException.class, () -> gson.toJson(Thread.currentThread()));\r\n        assertThat(e).hasMessageThat().isEqualTo(\"ReflectionAccessFilter does not permit using reflection for class java.lang.Thread.\" + \" Register a TypeAdapter for this type or adjust the access filter.\");\r\n    }\r\n\r\n    @Test\r\n    public void testBlockAllJavaExtendingJdkClass() {\r\n        Gson gson = new GsonBuilder().addReflectionAccessFilter(ReflectionAccessFilter.BLOCK_ALL_JAVA).create();\r\n        var e = assertThrows(JsonIOException.class, () -> gson.toJson(new ClassExtendingJdkClass()));\r\n        assertThat(e).hasMessageThat().isEqualTo(\"ReflectionAccessFilter does not permit using reflection for class java.io.Reader\" + \" (supertype of class\" + \" com.google.gson.functional.ReflectionAccessFilterTest$ClassExtendingJdkClass).\" + \" Register a TypeAdapter for this type or adjust the access filter.\");\r\n    }\r\n\r\n    private static class ClassWithStaticField {\r\n\r\n        @SuppressWarnings({ \"unused\", \"NonFinalStaticField\" })\r\n        private static int i = 1;\r\n    }\r\n\r\n    @Test\r\n    public void testBlockInaccessibleStaticField() {\r\n        Gson gson = new GsonBuilder().addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n            @Override\r\n            public FilterResult check(Class<?> rawClass) {\r\n                return FilterResult.BLOCK_INACCESSIBLE;\r\n            }\r\n        }).// Include static fields\r\n        excludeFieldsWithModifiers(0).create();\r\n        var e = assertThrows(\"Expected exception; test needs to be run with Java >= 9\", JsonIOException.class, () -> gson.toJson(new ClassWithStaticField()));\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Field 'com.google.gson.functional.ReflectionAccessFilterTest$ClassWithStaticField#i'\" + \" is not accessible and ReflectionAccessFilter does not permit making it\" + \" accessible. Register a TypeAdapter for the declaring type, adjust the access\" + \" filter or increase the visibility of the element and its declaring type.\");\r\n    }\r\n\r\n    private static class SuperTestClass {\r\n    }\r\n\r\n    private static class SubTestClass extends SuperTestClass {\r\n\r\n        @SuppressWarnings(\"unused\")\r\n        public int i = 1;\r\n    }\r\n\r\n    private static class OtherClass {\r\n\r\n        @SuppressWarnings(\"unused\")\r\n        public int i = 2;\r\n    }\r\n\r\n    @Test\r\n    public void testDelegation() {\r\n        Gson gson = new GsonBuilder().addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n            @Override\r\n            public FilterResult check(Class<?> rawClass) {\r\n                // INDECISIVE in last filter should act like ALLOW\r\n                return SuperTestClass.class.isAssignableFrom(rawClass) ? FilterResult.BLOCK_ALL : FilterResult.INDECISIVE;\r\n            }\r\n        }).addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n            @Override\r\n            public FilterResult check(Class<?> rawClass) {\r\n                // INDECISIVE should delegate to previous filter\r\n                return rawClass == SubTestClass.class ? FilterResult.ALLOW : FilterResult.INDECISIVE;\r\n            }\r\n        }).create();\r\n        // Filter disallows SuperTestClass\r\n        var e = assertThrows(JsonIOException.class, () -> gson.toJson(new SuperTestClass()));\r\n        assertThat(e).hasMessageThat().isEqualTo(\"ReflectionAccessFilter does not permit using reflection for class\" + \" com.google.gson.functional.ReflectionAccessFilterTest$SuperTestClass.\" + \" Register a TypeAdapter for this type or adjust the access filter.\");\r\n        // But registration order is reversed, so filter for SubTestClass allows reflection\r\n        String json = gson.toJson(new SubTestClass());\r\n        assertThat(json).isEqualTo(\"{\\\"i\\\":1}\");\r\n        // And unrelated class should not be affected\r\n        json = gson.toJson(new OtherClass());\r\n        assertThat(json).isEqualTo(\"{\\\"i\\\":2}\");\r\n    }\r\n\r\n    private static class ClassWithPrivateField {\r\n\r\n        @SuppressWarnings(\"unused\")\r\n        private int i = 1;\r\n    }\r\n\r\n    private static class ExtendingClassWithPrivateField extends ClassWithPrivateField {\r\n    }\r\n\r\n    @Test\r\n    public void testAllowForSupertype() {\r\n        Gson gson = new GsonBuilder().addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n            @Override\r\n            public FilterResult check(Class<?> rawClass) {\r\n                return FilterResult.BLOCK_INACCESSIBLE;\r\n            }\r\n        }).create();\r\n        // First make sure test is implemented correctly and access is blocked\r\n        var e = assertThrows(\"Expected exception; test needs to be run with Java >= 9\", JsonIOException.class, () -> gson.toJson(new ExtendingClassWithPrivateField()));\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Field\" + \" 'com.google.gson.functional.ReflectionAccessFilterTest$ClassWithPrivateField#i'\" + \" is not accessible and ReflectionAccessFilter does not permit making it\" + \" accessible. Register a TypeAdapter for the declaring type, adjust the access\" + \" filter or increase the visibility of the element and its declaring type.\");\r\n        Gson gson2 = gson.newBuilder().// Allow reflective access for supertype\r\n        addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n            @Override\r\n            public FilterResult check(Class<?> rawClass) {\r\n                return rawClass == ClassWithPrivateField.class ? FilterResult.ALLOW : FilterResult.INDECISIVE;\r\n            }\r\n        }).create();\r\n        // Inherited (inaccessible) private field should have been made accessible\r\n        String json = gson2.toJson(new ExtendingClassWithPrivateField());\r\n        assertThat(json).isEqualTo(\"{\\\"i\\\":1}\");\r\n    }\r\n\r\n    private static class ClassWithPrivateNoArgsConstructor {\r\n\r\n        private ClassWithPrivateNoArgsConstructor() {\r\n        }\r\n    }\r\n\r\n    @Test\r\n    public void testInaccessibleNoArgsConstructor() {\r\n        Gson gson = new GsonBuilder().addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n            @Override\r\n            public FilterResult check(Class<?> rawClass) {\r\n                return FilterResult.BLOCK_INACCESSIBLE;\r\n            }\r\n        }).create();\r\n        var e = assertThrows(\"Expected exception; test needs to be run with Java >= 9\", JsonIOException.class, () -> gson.fromJson(\"{}\", ClassWithPrivateNoArgsConstructor.class));\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Unable to invoke no-args constructor of class\" + \" com.google.gson.functional.ReflectionAccessFilterTest$ClassWithPrivateNoArgsConstructor;\" + \" constructor is not accessible and ReflectionAccessFilter does not permit making\" + \" it accessible. Register an InstanceCreator or a TypeAdapter for this type,\" + \" change the visibility of the constructor or adjust the access filter.\");\r\n    }\r\n\r\n    private static class ClassWithoutNoArgsConstructor {\r\n\r\n        public String s;\r\n\r\n        public ClassWithoutNoArgsConstructor(String s) {\r\n            this.s = s;\r\n        }\r\n    }\r\n\r\n    @Test\r\n    public void testClassWithoutNoArgsConstructor() {\r\n        GsonBuilder gsonBuilder = new GsonBuilder().addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n            @Override\r\n            public FilterResult check(Class<?> rawClass) {\r\n                // Even BLOCK_INACCESSIBLE should prevent usage of Unsafe for object creation\r\n                return FilterResult.BLOCK_INACCESSIBLE;\r\n            }\r\n        });\r\n        Gson gson = gsonBuilder.create();\r\n        var e = assertThrows(JsonIOException.class, () -> gson.fromJson(\"{}\", ClassWithoutNoArgsConstructor.class));\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Unable to create instance of class\" + \" com.google.gson.functional.ReflectionAccessFilterTest$ClassWithoutNoArgsConstructor;\" + \" ReflectionAccessFilter does not permit using reflection or Unsafe. Register an\" + \" InstanceCreator or a TypeAdapter for this type or adjust the access filter to\" + \" allow using reflection.\");\r\n        // But should not fail when custom TypeAdapter is specified\r\n        Gson gson2 = gson.newBuilder().registerTypeAdapter(ClassWithoutNoArgsConstructor.class, new TypeAdapter<ClassWithoutNoArgsConstructor>() {\r\n\r\n            @Override\r\n            public ClassWithoutNoArgsConstructor read(JsonReader in) throws IOException {\r\n                in.skipValue();\r\n                return new ClassWithoutNoArgsConstructor(\"TypeAdapter\");\r\n            }\r\n\r\n            @Override\r\n            public void write(JsonWriter out, ClassWithoutNoArgsConstructor value) {\r\n                throw new AssertionError(\"Not needed for test\");\r\n            }\r\n        }).create();\r\n        ClassWithoutNoArgsConstructor deserialized = gson2.fromJson(\"{}\", ClassWithoutNoArgsConstructor.class);\r\n        assertThat(deserialized.s).isEqualTo(\"TypeAdapter\");\r\n        // But should not fail when custom InstanceCreator is specified\r\n        gson2 = gsonBuilder.registerTypeAdapter(ClassWithoutNoArgsConstructor.class, new InstanceCreator<ClassWithoutNoArgsConstructor>() {\r\n\r\n            @Override\r\n            public ClassWithoutNoArgsConstructor createInstance(Type type) {\r\n                return new ClassWithoutNoArgsConstructor(\"InstanceCreator\");\r\n            }\r\n        }).create();\r\n        deserialized = gson2.fromJson(\"{}\", ClassWithoutNoArgsConstructor.class);\r\n        assertThat(deserialized.s).isEqualTo(\"InstanceCreator\");\r\n    }\r\n\r\n    /**\r\n     * When using {@link FilterResult#BLOCK_ALL}, registering only a {@link JsonSerializer} but not\r\n     * performing any deserialization should not throw any exception.\r\n     */\r\n    @Test\r\n    public void testBlockAllPartial() {\r\n        Gson gson = new GsonBuilder().addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n            @Override\r\n            public FilterResult check(Class<?> rawClass) {\r\n                return FilterResult.BLOCK_ALL;\r\n            }\r\n        }).registerTypeAdapter(OtherClass.class, new JsonSerializer<OtherClass>() {\r\n\r\n            @Override\r\n            public JsonElement serialize(OtherClass src, Type typeOfSrc, JsonSerializationContext context) {\r\n                return new JsonPrimitive(123);\r\n            }\r\n        }).create();\r\n        String json = gson.toJson(new OtherClass());\r\n        assertThat(json).isEqualTo(\"123\");\r\n        // But deserialization should fail\r\n        var e = assertThrows(JsonIOException.class, () -> gson.fromJson(\"{}\", OtherClass.class));\r\n        assertThat(e).hasMessageThat().isEqualTo(\"ReflectionAccessFilter does not permit using reflection for class\" + \" com.google.gson.functional.ReflectionAccessFilterTest$OtherClass. Register a\" + \" TypeAdapter for this type or adjust the access filter.\");\r\n    }\r\n\r\n    /**\r\n     * Should not fail when deserializing collection interface (even though this goes through {@link\r\n     * ConstructorConstructor} as well)\r\n     */\r\n    @Test\r\n    public void testBlockAllCollectionInterface() {\r\n        Gson gson = new GsonBuilder().addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n            @Override\r\n            public FilterResult check(Class<?> rawClass) {\r\n                return FilterResult.BLOCK_ALL;\r\n            }\r\n        }).create();\r\n        List<?> deserialized = gson.fromJson(\"[1.0]\", List.class);\r\n        assertThat(deserialized.get(0)).isEqualTo(1.0);\r\n    }\r\n\r\n    /**\r\n     * Should not fail when deserializing specific collection implementation (even though this goes\r\n     * through {@link ConstructorConstructor} as well)\r\n     */\r\n    @Test\r\n    public void testBlockAllCollectionImplementation() {\r\n        Gson gson = new GsonBuilder().addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n            @Override\r\n            public FilterResult check(Class<?> rawClass) {\r\n                return FilterResult.BLOCK_ALL;\r\n            }\r\n        }).create();\r\n        List<?> deserialized = gson.fromJson(\"[1.0]\", LinkedList.class);\r\n        assertThat(deserialized.get(0)).isEqualTo(1.0);\r\n    }\r\n\r\n    /**\r\n     * When trying to deserialize interface, an exception for the missing adapter should be thrown,\r\n     * even if {@link FilterResult#BLOCK_INACCESSIBLE} is used.\r\n     */\r\n    @Test\r\n    public void testBlockInaccessibleInterface() {\r\n        Gson gson = new GsonBuilder().addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n            @Override\r\n            public FilterResult check(Class<?> rawClass) {\r\n                return FilterResult.BLOCK_INACCESSIBLE;\r\n            }\r\n        }).create();\r\n        var e = assertThrows(JsonIOException.class, () -> gson.fromJson(\"{}\", Runnable.class));\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Interfaces can't be instantiated! Register an InstanceCreator or a TypeAdapter for\" + \" this type. Interface name: java.lang.Runnable\");\r\n    }\r\n\r\n    /**\r\n     * Verifies that the predefined filter constants have meaningful {@code toString()} output to make\r\n     * debugging easier.\r\n     */\r\n    @Test\r\n    public void testConstantsToString() throws Exception {\r\n        List<Field> constantFields = new ArrayList<>();\r\n        for (Field f : ReflectionAccessFilter.class.getFields()) {\r\n            // Only include ReflectionAccessFilter constants (in case any other fields are added in the\r\n            // future)\r\n            if (f.getType() == ReflectionAccessFilter.class) {\r\n                constantFields.add(f);\r\n            }\r\n        }\r\n        assertThat(constantFields).isNotEmpty();\r\n        for (Field f : constantFields) {\r\n            Object constant = f.get(null);\r\n            assertThat(constant.toString()).isEqualTo(\"ReflectionAccessFilter#\" + f.getName());\r\n        }\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "method",
    "name": "testBlockInaccessibleJava",
    "start_line": 60,
    "end_line": 81,
    "code": "@Test\r\npublic void testBlockInaccessibleJava() {\r\n    Gson gson = new GsonBuilder().addReflectionAccessFilter(ReflectionAccessFilter.BLOCK_INACCESSIBLE_JAVA).create();\r\n    // Serialization should fail for classes with non-public fields\r\n    // Note: This test is rather brittle and depends on the JDK implementation\r\n    var e = assertThrows(\"Expected exception; test needs to be run with Java >= 9\", JsonIOException.class, () -> gson.toJson(new File(\"a\")));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Field 'java.io.File#path' is not accessible and ReflectionAccessFilter does not\" + \" permit making it accessible. Register a TypeAdapter for the declaring type,\" + \" adjust the access filter or increase the visibility of the element and its\" + \" declaring type.\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "method",
    "name": "testDontBlockAccessibleJava",
    "start_line": 83,
    "end_line": 103,
    "code": "@Test\r\npublic void testDontBlockAccessibleJava() throws ReflectiveOperationException {\r\n    Gson gson = new GsonBuilder().addReflectionAccessFilter(ReflectionAccessFilter.BLOCK_INACCESSIBLE_JAVA).create();\r\n    // Serialization should succeed for classes with only public fields.\r\n    // Not many JDK classes have mutable public fields, thank goodness, but java.awt.Point does.\r\n    Class<?> pointClass;\r\n    try {\r\n        pointClass = Class.forName(\"java.awt.Point\");\r\n    } catch (ClassNotFoundException e) {\r\n        // If not found then we don't have AWT and the rest of the test can be skipped.\r\n        throw new AssumptionViolatedException(\"java.awt.Point not present\", e);\r\n    }\r\n    Constructor<?> pointConstructor = pointClass.getConstructor(int.class, int.class);\r\n    Object point = pointConstructor.newInstance(1, 2);\r\n    String json = gson.toJson(point);\r\n    assertThat(json).isEqualTo(\"{\\\"x\\\":1,\\\"y\\\":2}\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "method",
    "name": "testBlockInaccessibleJavaExtendingJdkClass",
    "start_line": 105,
    "end_line": 124,
    "code": "@Test\r\npublic void testBlockInaccessibleJavaExtendingJdkClass() {\r\n    Gson gson = new GsonBuilder().addReflectionAccessFilter(ReflectionAccessFilter.BLOCK_INACCESSIBLE_JAVA).create();\r\n    var e = assertThrows(\"Expected exception; test needs to be run with Java >= 9\", JsonIOException.class, () -> gson.toJson(new ClassExtendingJdkClass()));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Field 'java.io.Reader#lock' is not accessible and ReflectionAccessFilter does not\" + \" permit making it accessible. Register a TypeAdapter for the declaring type,\" + \" adjust the access filter or increase the visibility of the element and its\" + \" declaring type.\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "method",
    "name": "testBlockAllJava",
    "start_line": 126,
    "end_line": 138,
    "code": "@Test\r\npublic void testBlockAllJava() {\r\n    Gson gson = new GsonBuilder().addReflectionAccessFilter(ReflectionAccessFilter.BLOCK_ALL_JAVA).create();\r\n    // Serialization should fail for any Java class without custom adapter\r\n    var e = assertThrows(JsonIOException.class, () -> gson.toJson(Thread.currentThread()));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"ReflectionAccessFilter does not permit using reflection for class java.lang.Thread.\" + \" Register a TypeAdapter for this type or adjust the access filter.\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "method",
    "name": "testBlockAllJavaExtendingJdkClass",
    "start_line": 140,
    "end_line": 153,
    "code": "@Test\r\npublic void testBlockAllJavaExtendingJdkClass() {\r\n    Gson gson = new GsonBuilder().addReflectionAccessFilter(ReflectionAccessFilter.BLOCK_ALL_JAVA).create();\r\n    var e = assertThrows(JsonIOException.class, () -> gson.toJson(new ClassExtendingJdkClass()));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"ReflectionAccessFilter does not permit using reflection for class java.io.Reader\" + \" (supertype of class\" + \" com.google.gson.functional.ReflectionAccessFilterTest$ClassExtendingJdkClass).\" + \" Register a TypeAdapter for this type or adjust the access filter.\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "method",
    "name": "testBlockInaccessibleStaticField",
    "start_line": 160,
    "end_line": 187,
    "code": "@Test\r\npublic void testBlockInaccessibleStaticField() {\r\n    Gson gson = new GsonBuilder().addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n        @Override\r\n        public FilterResult check(Class<?> rawClass) {\r\n            return FilterResult.BLOCK_INACCESSIBLE;\r\n        }\r\n    }).// Include static fields\r\n    excludeFieldsWithModifiers(0).create();\r\n    var e = assertThrows(\"Expected exception; test needs to be run with Java >= 9\", JsonIOException.class, () -> gson.toJson(new ClassWithStaticField()));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Field 'com.google.gson.functional.ReflectionAccessFilterTest$ClassWithStaticField#i'\" + \" is not accessible and ReflectionAccessFilter does not permit making it\" + \" accessible. Register a TypeAdapter for the declaring type, adjust the access\" + \" filter or increase the visibility of the element and its declaring type.\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "method",
    "name": "testDelegation",
    "start_line": 201,
    "end_line": 243,
    "code": "@Test\r\npublic void testDelegation() {\r\n    Gson gson = new GsonBuilder().addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n        @Override\r\n        public FilterResult check(Class<?> rawClass) {\r\n            // INDECISIVE in last filter should act like ALLOW\r\n            return SuperTestClass.class.isAssignableFrom(rawClass) ? FilterResult.BLOCK_ALL : FilterResult.INDECISIVE;\r\n        }\r\n    }).addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n        @Override\r\n        public FilterResult check(Class<?> rawClass) {\r\n            // INDECISIVE should delegate to previous filter\r\n            return rawClass == SubTestClass.class ? FilterResult.ALLOW : FilterResult.INDECISIVE;\r\n        }\r\n    }).create();\r\n    // Filter disallows SuperTestClass\r\n    var e = assertThrows(JsonIOException.class, () -> gson.toJson(new SuperTestClass()));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"ReflectionAccessFilter does not permit using reflection for class\" + \" com.google.gson.functional.ReflectionAccessFilterTest$SuperTestClass.\" + \" Register a TypeAdapter for this type or adjust the access filter.\");\r\n    // But registration order is reversed, so filter for SubTestClass allows reflection\r\n    String json = gson.toJson(new SubTestClass());\r\n    assertThat(json).isEqualTo(\"{\\\"i\\\":1}\");\r\n    // And unrelated class should not be affected\r\n    json = gson.toJson(new OtherClass());\r\n    assertThat(json).isEqualTo(\"{\\\"i\\\":2}\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "method",
    "name": "testAllowForSupertype",
    "start_line": 252,
    "end_line": 297,
    "code": "@Test\r\npublic void testAllowForSupertype() {\r\n    Gson gson = new GsonBuilder().addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n        @Override\r\n        public FilterResult check(Class<?> rawClass) {\r\n            return FilterResult.BLOCK_INACCESSIBLE;\r\n        }\r\n    }).create();\r\n    // First make sure test is implemented correctly and access is blocked\r\n    var e = assertThrows(\"Expected exception; test needs to be run with Java >= 9\", JsonIOException.class, () -> gson.toJson(new ExtendingClassWithPrivateField()));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Field\" + \" 'com.google.gson.functional.ReflectionAccessFilterTest$ClassWithPrivateField#i'\" + \" is not accessible and ReflectionAccessFilter does not permit making it\" + \" accessible. Register a TypeAdapter for the declaring type, adjust the access\" + \" filter or increase the visibility of the element and its declaring type.\");\r\n    Gson gson2 = gson.newBuilder().// Allow reflective access for supertype\r\n    addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n        @Override\r\n        public FilterResult check(Class<?> rawClass) {\r\n            return rawClass == ClassWithPrivateField.class ? FilterResult.ALLOW : FilterResult.INDECISIVE;\r\n        }\r\n    }).create();\r\n    // Inherited (inaccessible) private field should have been made accessible\r\n    String json = gson2.toJson(new ExtendingClassWithPrivateField());\r\n    assertThat(json).isEqualTo(\"{\\\"i\\\":1}\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "method",
    "name": "testInaccessibleNoArgsConstructor",
    "start_line": 303,
    "end_line": 329,
    "code": "@Test\r\npublic void testInaccessibleNoArgsConstructor() {\r\n    Gson gson = new GsonBuilder().addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n        @Override\r\n        public FilterResult check(Class<?> rawClass) {\r\n            return FilterResult.BLOCK_INACCESSIBLE;\r\n        }\r\n    }).create();\r\n    var e = assertThrows(\"Expected exception; test needs to be run with Java >= 9\", JsonIOException.class, () -> gson.fromJson(\"{}\", ClassWithPrivateNoArgsConstructor.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Unable to invoke no-args constructor of class\" + \" com.google.gson.functional.ReflectionAccessFilterTest$ClassWithPrivateNoArgsConstructor;\" + \" constructor is not accessible and ReflectionAccessFilter does not permit making\" + \" it accessible. Register an InstanceCreator or a TypeAdapter for this type,\" + \" change the visibility of the constructor or adjust the access filter.\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "method",
    "name": "testClassWithoutNoArgsConstructor",
    "start_line": 339,
    "end_line": 401,
    "code": "@Test\r\npublic void testClassWithoutNoArgsConstructor() {\r\n    GsonBuilder gsonBuilder = new GsonBuilder().addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n        @Override\r\n        public FilterResult check(Class<?> rawClass) {\r\n            // Even BLOCK_INACCESSIBLE should prevent usage of Unsafe for object creation\r\n            return FilterResult.BLOCK_INACCESSIBLE;\r\n        }\r\n    });\r\n    Gson gson = gsonBuilder.create();\r\n    var e = assertThrows(JsonIOException.class, () -> gson.fromJson(\"{}\", ClassWithoutNoArgsConstructor.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Unable to create instance of class\" + \" com.google.gson.functional.ReflectionAccessFilterTest$ClassWithoutNoArgsConstructor;\" + \" ReflectionAccessFilter does not permit using reflection or Unsafe. Register an\" + \" InstanceCreator or a TypeAdapter for this type or adjust the access filter to\" + \" allow using reflection.\");\r\n    // But should not fail when custom TypeAdapter is specified\r\n    Gson gson2 = gson.newBuilder().registerTypeAdapter(ClassWithoutNoArgsConstructor.class, new TypeAdapter<ClassWithoutNoArgsConstructor>() {\r\n\r\n        @Override\r\n        public ClassWithoutNoArgsConstructor read(JsonReader in) throws IOException {\r\n            in.skipValue();\r\n            return new ClassWithoutNoArgsConstructor(\"TypeAdapter\");\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, ClassWithoutNoArgsConstructor value) {\r\n            throw new AssertionError(\"Not needed for test\");\r\n        }\r\n    }).create();\r\n    ClassWithoutNoArgsConstructor deserialized = gson2.fromJson(\"{}\", ClassWithoutNoArgsConstructor.class);\r\n    assertThat(deserialized.s).isEqualTo(\"TypeAdapter\");\r\n    // But should not fail when custom InstanceCreator is specified\r\n    gson2 = gsonBuilder.registerTypeAdapter(ClassWithoutNoArgsConstructor.class, new InstanceCreator<ClassWithoutNoArgsConstructor>() {\r\n\r\n        @Override\r\n        public ClassWithoutNoArgsConstructor createInstance(Type type) {\r\n            return new ClassWithoutNoArgsConstructor(\"InstanceCreator\");\r\n        }\r\n    }).create();\r\n    deserialized = gson2.fromJson(\"{}\", ClassWithoutNoArgsConstructor.class);\r\n    assertThat(deserialized.s).isEqualTo(\"InstanceCreator\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "method",
    "name": "testBlockAllPartial",
    "start_line": 407,
    "end_line": 440,
    "code": "/**\r\n * When using {@link FilterResult#BLOCK_ALL}, registering only a {@link JsonSerializer} but not\r\n * performing any deserialization should not throw any exception.\r\n */\r\n@Test\r\npublic void testBlockAllPartial() {\r\n    Gson gson = new GsonBuilder().addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n        @Override\r\n        public FilterResult check(Class<?> rawClass) {\r\n            return FilterResult.BLOCK_ALL;\r\n        }\r\n    }).registerTypeAdapter(OtherClass.class, new JsonSerializer<OtherClass>() {\r\n\r\n        @Override\r\n        public JsonElement serialize(OtherClass src, Type typeOfSrc, JsonSerializationContext context) {\r\n            return new JsonPrimitive(123);\r\n        }\r\n    }).create();\r\n    String json = gson.toJson(new OtherClass());\r\n    assertThat(json).isEqualTo(\"123\");\r\n    // But deserialization should fail\r\n    var e = assertThrows(JsonIOException.class, () -> gson.fromJson(\"{}\", OtherClass.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"ReflectionAccessFilter does not permit using reflection for class\" + \" com.google.gson.functional.ReflectionAccessFilterTest$OtherClass. Register a\" + \" TypeAdapter for this type or adjust the access filter.\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "method",
    "name": "testBlockAllCollectionInterface",
    "start_line": 446,
    "end_line": 460,
    "code": "/**\r\n * Should not fail when deserializing collection interface (even though this goes through {@link\r\n * ConstructorConstructor} as well)\r\n */\r\n@Test\r\npublic void testBlockAllCollectionInterface() {\r\n    Gson gson = new GsonBuilder().addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n        @Override\r\n        public FilterResult check(Class<?> rawClass) {\r\n            return FilterResult.BLOCK_ALL;\r\n        }\r\n    }).create();\r\n    List<?> deserialized = gson.fromJson(\"[1.0]\", List.class);\r\n    assertThat(deserialized.get(0)).isEqualTo(1.0);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "method",
    "name": "testBlockAllCollectionImplementation",
    "start_line": 466,
    "end_line": 480,
    "code": "/**\r\n * Should not fail when deserializing specific collection implementation (even though this goes\r\n * through {@link ConstructorConstructor} as well)\r\n */\r\n@Test\r\npublic void testBlockAllCollectionImplementation() {\r\n    Gson gson = new GsonBuilder().addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n        @Override\r\n        public FilterResult check(Class<?> rawClass) {\r\n            return FilterResult.BLOCK_ALL;\r\n        }\r\n    }).create();\r\n    List<?> deserialized = gson.fromJson(\"[1.0]\", LinkedList.class);\r\n    assertThat(deserialized.get(0)).isEqualTo(1.0);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "method",
    "name": "testBlockInaccessibleInterface",
    "start_line": 486,
    "end_line": 505,
    "code": "/**\r\n * When trying to deserialize interface, an exception for the missing adapter should be thrown,\r\n * even if {@link FilterResult#BLOCK_INACCESSIBLE} is used.\r\n */\r\n@Test\r\npublic void testBlockInaccessibleInterface() {\r\n    Gson gson = new GsonBuilder().addReflectionAccessFilter(new ReflectionAccessFilter() {\r\n\r\n        @Override\r\n        public FilterResult check(Class<?> rawClass) {\r\n            return FilterResult.BLOCK_INACCESSIBLE;\r\n        }\r\n    }).create();\r\n    var e = assertThrows(JsonIOException.class, () -> gson.fromJson(\"{}\", Runnable.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Interfaces can't be instantiated! Register an InstanceCreator or a TypeAdapter for\" + \" this type. Interface name: java.lang.Runnable\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  },
  {
    "type": "method",
    "name": "testConstantsToString",
    "start_line": 511,
    "end_line": 528,
    "code": "/**\r\n * Verifies that the predefined filter constants have meaningful {@code toString()} output to make\r\n * debugging easier.\r\n */\r\n@Test\r\npublic void testConstantsToString() throws Exception {\r\n    List<Field> constantFields = new ArrayList<>();\r\n    for (Field f : ReflectionAccessFilter.class.getFields()) {\r\n        // Only include ReflectionAccessFilter constants (in case any other fields are added in the\r\n        // future)\r\n        if (f.getType() == ReflectionAccessFilter.class) {\r\n            constantFields.add(f);\r\n        }\r\n    }\r\n    assertThat(constantFields).isNotEmpty();\r\n    for (Field f : constantFields) {\r\n        Object constant = f.get(null);\r\n        assertThat(constant.toString()).isEqualTo(\"ReflectionAccessFilter#\" + f.getName());\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\ReflectionAccessFilterTest.java"
  }
]