[
  {
    "type": "package",
    "name": "com.google.gson",
    "start_line": 17,
    "end_line": 17,
    "code": "package com.google.gson;\r\n\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  },
  {
    "type": "import",
    "name": "com.google.common.truth.Truth.assertThat",
    "start_line": 19,
    "end_line": 19,
    "code": "import static com.google.common.truth.Truth.assertThat;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  },
  {
    "type": "import",
    "name": "org.junit.Assert.assertThrows",
    "start_line": 20,
    "end_line": 20,
    "code": "import static org.junit.Assert.assertThrows;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.Gson.FutureTypeAdapter",
    "start_line": 22,
    "end_line": 22,
    "code": "import com.google.gson.Gson.FutureTypeAdapter;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.internal.Excluder",
    "start_line": 23,
    "end_line": 23,
    "code": "import com.google.gson.internal.Excluder;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.reflect.TypeToken",
    "start_line": 24,
    "end_line": 24,
    "code": "import com.google.gson.reflect.TypeToken;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.stream.JsonReader",
    "start_line": 25,
    "end_line": 25,
    "code": "import com.google.gson.stream.JsonReader;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.stream.JsonWriter",
    "start_line": 26,
    "end_line": 26,
    "code": "import com.google.gson.stream.JsonWriter;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.stream.MalformedJsonException",
    "start_line": 27,
    "end_line": 27,
    "code": "import com.google.gson.stream.MalformedJsonException;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  },
  {
    "type": "import",
    "name": "java.io.IOException",
    "start_line": 28,
    "end_line": 28,
    "code": "import java.io.IOException;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  },
  {
    "type": "import",
    "name": "java.io.StringReader",
    "start_line": 29,
    "end_line": 29,
    "code": "import java.io.StringReader;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  },
  {
    "type": "import",
    "name": "java.io.StringWriter",
    "start_line": 30,
    "end_line": 30,
    "code": "import java.io.StringWriter;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  },
  {
    "type": "import",
    "name": "java.text.DateFormat",
    "start_line": 31,
    "end_line": 31,
    "code": "import java.text.DateFormat;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  },
  {
    "type": "import",
    "name": "java.util.ArrayList",
    "start_line": 32,
    "end_line": 32,
    "code": "import java.util.ArrayList;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  },
  {
    "type": "import",
    "name": "java.util.Collections",
    "start_line": 33,
    "end_line": 33,
    "code": "import java.util.Collections;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  },
  {
    "type": "import",
    "name": "java.util.HashMap",
    "start_line": 34,
    "end_line": 34,
    "code": "import java.util.HashMap;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  },
  {
    "type": "import",
    "name": "java.util.concurrent.CountDownLatch",
    "start_line": 35,
    "end_line": 35,
    "code": "import java.util.concurrent.CountDownLatch;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  },
  {
    "type": "import",
    "name": "java.util.concurrent.atomic.AtomicInteger",
    "start_line": 36,
    "end_line": 36,
    "code": "import java.util.concurrent.atomic.AtomicInteger;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  },
  {
    "type": "import",
    "name": "java.util.concurrent.atomic.AtomicReference",
    "start_line": 37,
    "end_line": 37,
    "code": "import java.util.concurrent.atomic.AtomicReference;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  },
  {
    "type": "import",
    "name": "org.junit.Test",
    "start_line": 38,
    "end_line": 38,
    "code": "import org.junit.Test;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  },
  {
    "type": "class",
    "name": "GsonTest",
    "start_line": 45,
    "end_line": 676,
    "code": "/**\r\n * Unit tests for {@link Gson}.\r\n *\r\n * @author Ryan Harter\r\n */\r\npublic final class GsonTest {\r\n\r\n    private static final Excluder CUSTOM_EXCLUDER = Excluder.DEFAULT.excludeFieldsWithoutExposeAnnotation().disableInnerClassSerialization();\r\n\r\n    private static final FieldNamingStrategy CUSTOM_FIELD_NAMING_STRATEGY = f -> \"foo\";\r\n\r\n    private static final ToNumberStrategy CUSTOM_OBJECT_TO_NUMBER_STRATEGY = ToNumberPolicy.DOUBLE;\r\n\r\n    private static final ToNumberStrategy CUSTOM_NUMBER_TO_NUMBER_STRATEGY = ToNumberPolicy.LAZILY_PARSED_NUMBER;\r\n\r\n    @Test\r\n    public void testStrictnessDefault() {\r\n        assertThat(new Gson().strictness).isNull();\r\n    }\r\n\r\n    @Test\r\n    public void testOverridesDefaultExcluder() {\r\n        Gson gson = new Gson(CUSTOM_EXCLUDER, CUSTOM_FIELD_NAMING_STRATEGY, new HashMap<>(), true, false, true, false, FormattingStyle.PRETTY, Strictness.LENIENT, false, true, LongSerializationPolicy.DEFAULT, null, DateFormat.DEFAULT, DateFormat.DEFAULT, new ArrayList<>(), new ArrayList<>(), new ArrayList<>(), CUSTOM_OBJECT_TO_NUMBER_STRATEGY, CUSTOM_NUMBER_TO_NUMBER_STRATEGY, Collections.emptyList());\r\n        assertThat(gson.excluder).isEqualTo(CUSTOM_EXCLUDER);\r\n        assertThat(gson.fieldNamingStrategy()).isEqualTo(CUSTOM_FIELD_NAMING_STRATEGY);\r\n        assertThat(gson.serializeNulls()).isTrue();\r\n        assertThat(gson.htmlSafe()).isFalse();\r\n    }\r\n\r\n    @Test\r\n    public void testClonedTypeAdapterFactoryListsAreIndependent() {\r\n        Gson original = new Gson(CUSTOM_EXCLUDER, CUSTOM_FIELD_NAMING_STRATEGY, new HashMap<>(), true, false, true, false, FormattingStyle.PRETTY, Strictness.LENIENT, false, true, LongSerializationPolicy.DEFAULT, null, DateFormat.DEFAULT, DateFormat.DEFAULT, new ArrayList<>(), new ArrayList<>(), new ArrayList<>(), CUSTOM_OBJECT_TO_NUMBER_STRATEGY, CUSTOM_NUMBER_TO_NUMBER_STRATEGY, Collections.emptyList());\r\n        Gson clone = original.newBuilder().registerTypeAdapter(int.class, new TestTypeAdapter()).create();\r\n        assertThat(clone.factories).hasSize(original.factories.size() + 1);\r\n    }\r\n\r\n    private static final class TestTypeAdapter extends TypeAdapter<Object> {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Object value) {\r\n            // Test stub.\r\n        }\r\n\r\n        @Override\r\n        public Object read(JsonReader in) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    @Test\r\n    public void testFromJson_WrongResultType() {\r\n        class IntegerAdapter extends TypeAdapter<Integer> {\r\n\r\n            @Override\r\n            public Integer read(JsonReader in) throws IOException {\r\n                in.skipValue();\r\n                return 3;\r\n            }\r\n\r\n            @Override\r\n            public void write(JsonWriter out, Integer value) {\r\n                throw new AssertionError(\"not needed for test\");\r\n            }\r\n\r\n            @Override\r\n            public String toString() {\r\n                return \"custom-adapter\";\r\n            }\r\n        }\r\n        Gson gson = new GsonBuilder().registerTypeAdapter(Boolean.class, new IntegerAdapter()).create();\r\n        // Use `Class<?>` here to avoid that the JVM itself creates the ClassCastException (though the\r\n        // check below for the custom message would detect that as well)\r\n        Class<?> deserializedClass = Boolean.class;\r\n        var exception = assertThrows(ClassCastException.class, () -> gson.fromJson(\"true\", deserializedClass));\r\n        assertThat(exception).hasMessageThat().isEqualTo(\"Type adapter 'custom-adapter' returned wrong type; requested class java.lang.Boolean\" + \" but got instance of class java.lang.Integer\\n\" + \"Verify that the adapter was registered for the correct type.\");\r\n        // Returning boxed primitive should be allowed (e.g. returning `Integer` for `int`)\r\n        Gson gson2 = new GsonBuilder().registerTypeAdapter(int.class, new IntegerAdapter()).create();\r\n        assertThat(gson2.fromJson(\"0\", int.class)).isEqualTo(3);\r\n        class NullAdapter extends TypeAdapter<Object> {\r\n\r\n            @Override\r\n            public Object read(JsonReader in) throws IOException {\r\n                in.skipValue();\r\n                return null;\r\n            }\r\n\r\n            @Override\r\n            public void write(JsonWriter out, Object value) {\r\n                throw new AssertionError(\"not needed for test\");\r\n            }\r\n        }\r\n        // Returning `null` should be allowed\r\n        Gson gson3 = new GsonBuilder().registerTypeAdapter(Boolean.class, new NullAdapter()).create();\r\n        assertThat(gson3.fromJson(\"true\", Boolean.class)).isNull();\r\n    }\r\n\r\n    @Test\r\n    public void testGetAdapter_Null() {\r\n        Gson gson = new Gson();\r\n        NullPointerException e = assertThrows(NullPointerException.class, () -> gson.getAdapter((TypeToken<?>) null));\r\n        assertThat(e).hasMessageThat().isEqualTo(\"type must not be null\");\r\n    }\r\n\r\n    @Test\r\n    public void testGetAdapter_Concurrency() {\r\n        class DummyAdapter<T> extends TypeAdapter<T> {\r\n\r\n            @Override\r\n            public void write(JsonWriter out, T value) throws IOException {\r\n                throw new AssertionError(\"not needed for this test\");\r\n            }\r\n\r\n            @Override\r\n            public T read(JsonReader in) throws IOException {\r\n                throw new AssertionError(\"not needed for this test\");\r\n            }\r\n        }\r\n        AtomicInteger adapterInstancesCreated = new AtomicInteger(0);\r\n        AtomicReference<TypeAdapter<?>> threadAdapter = new AtomicReference<>();\r\n        Class<?> requestedType = Number.class;\r\n        Gson gson = new GsonBuilder().registerTypeAdapterFactory(new TypeAdapterFactory() {\r\n\r\n            private volatile boolean isFirstCall = true;\r\n\r\n            @Override\r\n            public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\r\n                if (isFirstCall) {\r\n                    isFirstCall = false;\r\n                    // Create a separate thread which requests an adapter for the same type\r\n                    // This will cause this factory to return a different adapter instance than\r\n                    // the one it is currently creating\r\n                    Thread thread = new Thread() {\r\n\r\n                        @Override\r\n                        public void run() {\r\n                            threadAdapter.set(gson.getAdapter(requestedType));\r\n                        }\r\n                    };\r\n                    thread.start();\r\n                    try {\r\n                        thread.join();\r\n                    } catch (InterruptedException e) {\r\n                        throw new RuntimeException(e);\r\n                    }\r\n                }\r\n                // Create a new dummy adapter instance\r\n                adapterInstancesCreated.incrementAndGet();\r\n                return new DummyAdapter<>();\r\n            }\r\n        }).create();\r\n        TypeAdapter<?> adapter = gson.getAdapter(requestedType);\r\n        assertThat(adapterInstancesCreated.get()).isEqualTo(2);\r\n        assertThat(adapter).isInstanceOf(DummyAdapter.class);\r\n        assertThat(threadAdapter.get()).isInstanceOf(DummyAdapter.class);\r\n    }\r\n\r\n    /**\r\n     * Verifies that two threads calling {@link Gson#getAdapter(TypeToken)} do not see the same\r\n     * unresolved {@link FutureTypeAdapter} instance, since that would not be thread-safe.\r\n     *\r\n     * <p>This test constructs the cyclic dependency {@literal CustomClass1 -> CustomClass2 ->\r\n     * CustomClass1} and lets one thread wait after the adapter for CustomClass2 has been obtained\r\n     * (which still refers to the nested unresolved FutureTypeAdapter for CustomClass1).\r\n     */\r\n    @Test\r\n    public void testGetAdapter_FutureAdapterConcurrency() throws Exception {\r\n        /**\r\n         * Adapter which wraps another adapter. Can be imagined as a simplified version of the {@code\r\n         * ReflectiveTypeAdapterFactory$Adapter}.\r\n         */\r\n        class WrappingAdapter<T> extends TypeAdapter<T> {\r\n\r\n            final TypeAdapter<?> wrapped;\r\n\r\n            boolean isFirstCall = true;\r\n\r\n            WrappingAdapter(TypeAdapter<?> wrapped) {\r\n                this.wrapped = wrapped;\r\n            }\r\n\r\n            @Override\r\n            public void write(JsonWriter out, T value) throws IOException {\r\n                // Due to how this test is set up there is infinite recursion, therefore\r\n                // need to track how deeply nested this call is\r\n                if (isFirstCall) {\r\n                    isFirstCall = false;\r\n                    out.beginArray();\r\n                    wrapped.write(out, null);\r\n                    out.endArray();\r\n                    isFirstCall = true;\r\n                } else {\r\n                    out.value(\"wrapped-nested\");\r\n                }\r\n            }\r\n\r\n            @Override\r\n            public T read(JsonReader in) throws IOException {\r\n                throw new AssertionError(\"not needed for this test\");\r\n            }\r\n        }\r\n        CountDownLatch isThreadWaiting = new CountDownLatch(1);\r\n        CountDownLatch canThreadProceed = new CountDownLatch(1);\r\n        Gson gson = new GsonBuilder().registerTypeAdapterFactory(new TypeAdapterFactory() {\r\n\r\n            // volatile instead of AtomicBoolean is safe here because CountDownLatch prevents\r\n            // \"true\" concurrency\r\n            volatile boolean isFirstCaller = true;\r\n\r\n            @Override\r\n            public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\r\n                Class<?> raw = type.getRawType();\r\n                if (raw == CustomClass1.class) {\r\n                    // Retrieves a WrappingAdapter containing a nested FutureAdapter for\r\n                    // CustomClass1\r\n                    TypeAdapter<?> adapter = gson.getAdapter(CustomClass2.class);\r\n                    // Let thread wait so the FutureAdapter for CustomClass1 nested in the adapter\r\n                    // for CustomClass2 is not resolved yet\r\n                    if (isFirstCaller) {\r\n                        isFirstCaller = false;\r\n                        isThreadWaiting.countDown();\r\n                        try {\r\n                            canThreadProceed.await();\r\n                        } catch (InterruptedException e) {\r\n                            throw new RuntimeException(e);\r\n                        }\r\n                    }\r\n                    return new WrappingAdapter<>(adapter);\r\n                } else if (raw == CustomClass2.class) {\r\n                    TypeAdapter<?> adapter = gson.getAdapter(CustomClass1.class);\r\n                    assertThat(adapter).isInstanceOf(FutureTypeAdapter.class);\r\n                    return new WrappingAdapter<>(adapter);\r\n                } else {\r\n                    throw new AssertionError(\"Adapter for unexpected type requested: \" + raw);\r\n                }\r\n            }\r\n        }).create();\r\n        AtomicReference<TypeAdapter<?>> otherThreadAdapter = new AtomicReference<>();\r\n        Thread thread = new Thread() {\r\n\r\n            @Override\r\n            public void run() {\r\n                otherThreadAdapter.set(gson.getAdapter(CustomClass1.class));\r\n            }\r\n        };\r\n        thread.start();\r\n        // Wait until other thread has obtained FutureAdapter\r\n        isThreadWaiting.await();\r\n        TypeAdapter<?> adapter = gson.getAdapter(CustomClass1.class);\r\n        // Should not fail due to referring to unresolved FutureTypeAdapter\r\n        assertThat(adapter.toJson(null)).isEqualTo(\"[[\\\"wrapped-nested\\\"]]\");\r\n        // Let other thread proceed and have it resolve its FutureTypeAdapter\r\n        canThreadProceed.countDown();\r\n        thread.join();\r\n        assertThat(otherThreadAdapter.get().toJson(null)).isEqualTo(\"[[\\\"wrapped-nested\\\"]]\");\r\n    }\r\n\r\n    @Test\r\n    public void testGetDelegateAdapter() {\r\n        class DummyAdapter extends TypeAdapter<Number> {\r\n\r\n            private final int number;\r\n\r\n            DummyAdapter(int number) {\r\n                this.number = number;\r\n            }\r\n\r\n            @Override\r\n            public Number read(JsonReader in) throws IOException {\r\n                throw new AssertionError(\"not needed for test\");\r\n            }\r\n\r\n            @Override\r\n            public void write(JsonWriter out, Number value) throws IOException {\r\n                throw new AssertionError(\"not needed for test\");\r\n            }\r\n\r\n            // Override toString() for better assertion error messages\r\n            @Override\r\n            public String toString() {\r\n                return \"adapter-\" + number;\r\n            }\r\n        }\r\n        class DummyFactory implements TypeAdapterFactory {\r\n\r\n            private final DummyAdapter adapter;\r\n\r\n            DummyFactory(DummyAdapter adapter) {\r\n                this.adapter = adapter;\r\n            }\r\n\r\n            @SuppressWarnings(\"unchecked\")\r\n            @Override\r\n            public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\r\n                return (TypeAdapter<T>) adapter;\r\n            }\r\n\r\n            // Override equals to verify that reference equality check is performed by Gson,\r\n            // and this method is ignored\r\n            @Override\r\n            public boolean equals(Object obj) {\r\n                return obj instanceof DummyFactory && ((DummyFactory) obj).adapter.equals(adapter);\r\n            }\r\n\r\n            @Override\r\n            public int hashCode() {\r\n                return adapter.hashCode();\r\n            }\r\n        }\r\n        DummyAdapter adapter1 = new DummyAdapter(1);\r\n        DummyFactory factory1 = new DummyFactory(adapter1);\r\n        DummyAdapter adapter2 = new DummyAdapter(2);\r\n        DummyFactory factory2 = new DummyFactory(adapter2);\r\n        Gson gson = new GsonBuilder().// Note: This is 'last in, first out' order; Gson will first use factory2, then factory1\r\n        registerTypeAdapterFactory(factory1).registerTypeAdapterFactory(factory2).create();\r\n        TypeToken<?> type = TypeToken.get(Number.class);\r\n        assertThrows(NullPointerException.class, () -> gson.getDelegateAdapter(null, type));\r\n        assertThrows(NullPointerException.class, () -> gson.getDelegateAdapter(factory1, null));\r\n        // For unknown factory the first adapter for that type should be returned\r\n        assertThat(gson.getDelegateAdapter(new DummyFactory(new DummyAdapter(0)), type)).isEqualTo(adapter2);\r\n        assertThat(gson.getDelegateAdapter(factory2, type)).isEqualTo(adapter1);\r\n        // Default Gson adapter should be returned\r\n        assertThat(gson.getDelegateAdapter(factory1, type)).isNotInstanceOf(DummyAdapter.class);\r\n        DummyFactory factory1Eq = new DummyFactory(adapter1);\r\n        // Verify that test setup is correct\r\n        assertThat(factory1.equals(factory1Eq)).isTrue();\r\n        // Should only consider reference equality and ignore that custom `equals` method considers\r\n        // factories to be equal, therefore returning `adapter2` which came from `factory2` instead\r\n        // of skipping past `factory1`\r\n        assertThat(gson.getDelegateAdapter(factory1Eq, type)).isEqualTo(adapter2);\r\n    }\r\n\r\n    @Test\r\n    public void testNewJsonWriter_Default() throws IOException {\r\n        StringWriter writer = new StringWriter();\r\n        JsonWriter jsonWriter = new Gson().newJsonWriter(writer);\r\n        jsonWriter.beginObject();\r\n        jsonWriter.name(\"test\");\r\n        jsonWriter.nullValue();\r\n        jsonWriter.name(\"<test2\");\r\n        jsonWriter.value(true);\r\n        jsonWriter.endObject();\r\n        // Additional top-level value\r\n        IllegalStateException e = assertThrows(IllegalStateException.class, () -> jsonWriter.value(1));\r\n        assertThat(e).hasMessageThat().isEqualTo(\"JSON must have only one top-level value.\");\r\n        jsonWriter.close();\r\n        assertThat(writer.toString()).isEqualTo(\"{\\\"\\\\u003ctest2\\\":true}\");\r\n    }\r\n\r\n    // for GsonBuilder.setLenient\r\n    @SuppressWarnings({ \"deprecation\", \"InlineMeInliner\" })\r\n    @Test\r\n    public void testNewJsonWriter_Custom() throws IOException {\r\n        StringWriter writer = new StringWriter();\r\n        JsonWriter jsonWriter = new GsonBuilder().disableHtmlEscaping().generateNonExecutableJson().setPrettyPrinting().serializeNulls().setLenient().create().newJsonWriter(writer);\r\n        jsonWriter.beginObject();\r\n        jsonWriter.name(\"test\");\r\n        jsonWriter.nullValue();\r\n        jsonWriter.name(\"<test2\");\r\n        jsonWriter.value(true);\r\n        jsonWriter.endObject();\r\n        // Additional top-level value\r\n        jsonWriter.value(1);\r\n        jsonWriter.close();\r\n        assertThat(writer.toString()).isEqualTo(\")]}'\\n{\\n  \\\"test\\\": null,\\n  \\\"<test2\\\": true\\n}1\");\r\n    }\r\n\r\n    @Test\r\n    public void testNewJsonReader_Default() throws IOException {\r\n        // String without quotes\r\n        String json = \"test\";\r\n        JsonReader jsonReader = new Gson().newJsonReader(new StringReader(json));\r\n        assertThrows(MalformedJsonException.class, jsonReader::nextString);\r\n        jsonReader.close();\r\n    }\r\n\r\n    // for GsonBuilder.setLenient\r\n    @SuppressWarnings({ \"deprecation\", \"InlineMeInliner\" })\r\n    @Test\r\n    public void testNewJsonReader_Custom() throws IOException {\r\n        // String without quotes\r\n        String json = \"test\";\r\n        JsonReader jsonReader = new GsonBuilder().setLenient().create().newJsonReader(new StringReader(json));\r\n        assertThat(jsonReader.nextString()).isEqualTo(\"test\");\r\n        jsonReader.close();\r\n    }\r\n\r\n    /**\r\n     * Modifying a GsonBuilder obtained from {@link Gson#newBuilder()} of a {@code new Gson()} should\r\n     * not affect the Gson instance it came from.\r\n     */\r\n    @Test\r\n    public void testDefaultGsonNewBuilderModification() {\r\n        Gson gson = new Gson();\r\n        GsonBuilder gsonBuilder = gson.newBuilder();\r\n        // Modifications of `gsonBuilder` should not affect `gson` object\r\n        gsonBuilder.registerTypeAdapter(CustomClass1.class, new TypeAdapter<CustomClass1>() {\r\n\r\n            @Override\r\n            public CustomClass1 read(JsonReader in) throws IOException {\r\n                throw new UnsupportedOperationException();\r\n            }\r\n\r\n            @Override\r\n            public void write(JsonWriter out, CustomClass1 value) throws IOException {\r\n                out.value(\"custom-adapter\");\r\n            }\r\n        });\r\n        gsonBuilder.registerTypeHierarchyAdapter(CustomClass2.class, (JsonSerializer<CustomClass2>) (src, typeOfSrc, context) -> new JsonPrimitive(\"custom-hierarchy-adapter\"));\r\n        gsonBuilder.registerTypeAdapter(CustomClass3.class, (InstanceCreator<CustomClass3>) type -> new CustomClass3(\"custom-instance\"));\r\n        assertDefaultGson(gson);\r\n        // New GsonBuilder created from `gson` should not have been affected by changes either\r\n        assertDefaultGson(gson.newBuilder().create());\r\n        // But new Gson instance from `gsonBuilder` should use custom adapters\r\n        assertCustomGson(gsonBuilder.create());\r\n    }\r\n\r\n    private static void assertDefaultGson(Gson gson) {\r\n        // Should use default reflective adapter\r\n        String json1 = gson.toJson(new CustomClass1());\r\n        assertThat(json1).isEqualTo(\"{}\");\r\n        // Should use default reflective adapter\r\n        String json2 = gson.toJson(new CustomClass2());\r\n        assertThat(json2).isEqualTo(\"{}\");\r\n        // Should use default instance creator\r\n        CustomClass3 customClass3 = gson.fromJson(\"{}\", CustomClass3.class);\r\n        assertThat(customClass3.s).isEqualTo(CustomClass3.NO_ARG_CONSTRUCTOR_VALUE);\r\n    }\r\n\r\n    /**\r\n     * Modifying a GsonBuilder obtained from {@link Gson#newBuilder()} of a custom Gson instance\r\n     * (created using a GsonBuilder) should not affect the Gson instance it came from.\r\n     */\r\n    @Test\r\n    public void testNewBuilderModification() {\r\n        Gson gson = new GsonBuilder().registerTypeAdapter(CustomClass1.class, new TypeAdapter<CustomClass1>() {\r\n\r\n            @Override\r\n            public CustomClass1 read(JsonReader in) throws IOException {\r\n                throw new UnsupportedOperationException();\r\n            }\r\n\r\n            @Override\r\n            public void write(JsonWriter out, CustomClass1 value) throws IOException {\r\n                out.value(\"custom-adapter\");\r\n            }\r\n        }).registerTypeHierarchyAdapter(CustomClass2.class, (JsonSerializer<CustomClass2>) (src, typeOfSrc, context) -> new JsonPrimitive(\"custom-hierarchy-adapter\")).registerTypeAdapter(CustomClass3.class, (InstanceCreator<CustomClass3>) type -> new CustomClass3(\"custom-instance\")).create();\r\n        assertCustomGson(gson);\r\n        // Modify `gson.newBuilder()`\r\n        GsonBuilder gsonBuilder = gson.newBuilder();\r\n        gsonBuilder.registerTypeAdapter(CustomClass1.class, new TypeAdapter<CustomClass1>() {\r\n\r\n            @Override\r\n            public CustomClass1 read(JsonReader in) throws IOException {\r\n                throw new UnsupportedOperationException();\r\n            }\r\n\r\n            @Override\r\n            public void write(JsonWriter out, CustomClass1 value) throws IOException {\r\n                out.value(\"overwritten custom-adapter\");\r\n            }\r\n        });\r\n        gsonBuilder.registerTypeHierarchyAdapter(CustomClass2.class, (JsonSerializer<CustomClass2>) (src, typeOfSrc, context) -> new JsonPrimitive(\"overwritten custom-hierarchy-adapter\"));\r\n        gsonBuilder.registerTypeAdapter(CustomClass3.class, (InstanceCreator<CustomClass3>) type -> new CustomClass3(\"overwritten custom-instance\"));\r\n        // `gson` object should not have been affected by changes to new GsonBuilder\r\n        assertCustomGson(gson);\r\n        // New GsonBuilder based on `gson` should not have been affected either\r\n        assertCustomGson(gson.newBuilder().create());\r\n        // But new Gson instance from `gsonBuilder` should be affected by changes\r\n        Gson otherGson = gsonBuilder.create();\r\n        String json1 = otherGson.toJson(new CustomClass1());\r\n        assertThat(json1).isEqualTo(\"\\\"overwritten custom-adapter\\\"\");\r\n        String json2 = otherGson.toJson(new CustomClass2());\r\n        assertThat(json2).isEqualTo(\"\\\"overwritten custom-hierarchy-adapter\\\"\");\r\n        CustomClass3 customClass3 = otherGson.fromJson(\"{}\", CustomClass3.class);\r\n        assertThat(customClass3.s).isEqualTo(\"overwritten custom-instance\");\r\n    }\r\n\r\n    private static void assertCustomGson(Gson gson) {\r\n        String json1 = gson.toJson(new CustomClass1());\r\n        assertThat(json1).isEqualTo(\"\\\"custom-adapter\\\"\");\r\n        String json2 = gson.toJson(new CustomClass2());\r\n        assertThat(json2).isEqualTo(\"\\\"custom-hierarchy-adapter\\\"\");\r\n        CustomClass3 customClass3 = gson.fromJson(\"{}\", CustomClass3.class);\r\n        assertThat(customClass3.s).isEqualTo(\"custom-instance\");\r\n    }\r\n\r\n    private static class CustomClass1 {\r\n    }\r\n\r\n    private static class CustomClass2 {\r\n    }\r\n\r\n    private static class CustomClass3 {\r\n\r\n        static final String NO_ARG_CONSTRUCTOR_VALUE = \"default instance\";\r\n\r\n        final String s;\r\n\r\n        public CustomClass3(String s) {\r\n            this.s = s;\r\n        }\r\n\r\n        // called by Gson\r\n        @SuppressWarnings(\"unused\")\r\n        public CustomClass3() {\r\n            this(NO_ARG_CONSTRUCTOR_VALUE);\r\n        }\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  },
  {
    "type": "field",
    "name": "CUSTOM_EXCLUDER",
    "start_line": 47,
    "end_line": 48,
    "code": "private static final Excluder CUSTOM_EXCLUDER = Excluder.DEFAULT.excludeFieldsWithoutExposeAnnotation().disableInnerClassSerialization();",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  },
  {
    "type": "field",
    "name": "CUSTOM_FIELD_NAMING_STRATEGY",
    "start_line": 50,
    "end_line": 50,
    "code": "private static final FieldNamingStrategy CUSTOM_FIELD_NAMING_STRATEGY = f -> \"foo\";",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  },
  {
    "type": "field",
    "name": "CUSTOM_OBJECT_TO_NUMBER_STRATEGY",
    "start_line": 52,
    "end_line": 52,
    "code": "private static final ToNumberStrategy CUSTOM_OBJECT_TO_NUMBER_STRATEGY = ToNumberPolicy.DOUBLE;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  },
  {
    "type": "field",
    "name": "CUSTOM_NUMBER_TO_NUMBER_STRATEGY",
    "start_line": 53,
    "end_line": 54,
    "code": "private static final ToNumberStrategy CUSTOM_NUMBER_TO_NUMBER_STRATEGY = ToNumberPolicy.LAZILY_PARSED_NUMBER;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  },
  {
    "type": "method",
    "name": "testStrictnessDefault",
    "start_line": 56,
    "end_line": 59,
    "code": "@Test\r\npublic void testStrictnessDefault() {\r\n    assertThat(new Gson().strictness).isNull();\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  },
  {
    "type": "method",
    "name": "testOverridesDefaultExcluder",
    "start_line": 61,
    "end_line": 91,
    "code": "@Test\r\npublic void testOverridesDefaultExcluder() {\r\n    Gson gson = new Gson(CUSTOM_EXCLUDER, CUSTOM_FIELD_NAMING_STRATEGY, new HashMap<>(), true, false, true, false, FormattingStyle.PRETTY, Strictness.LENIENT, false, true, LongSerializationPolicy.DEFAULT, null, DateFormat.DEFAULT, DateFormat.DEFAULT, new ArrayList<>(), new ArrayList<>(), new ArrayList<>(), CUSTOM_OBJECT_TO_NUMBER_STRATEGY, CUSTOM_NUMBER_TO_NUMBER_STRATEGY, Collections.emptyList());\r\n    assertThat(gson.excluder).isEqualTo(CUSTOM_EXCLUDER);\r\n    assertThat(gson.fieldNamingStrategy()).isEqualTo(CUSTOM_FIELD_NAMING_STRATEGY);\r\n    assertThat(gson.serializeNulls()).isTrue();\r\n    assertThat(gson.htmlSafe()).isFalse();\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  },
  {
    "type": "method",
    "name": "testClonedTypeAdapterFactoryListsAreIndependent",
    "start_line": 93,
    "end_line": 123,
    "code": "@Test\r\npublic void testClonedTypeAdapterFactoryListsAreIndependent() {\r\n    Gson original = new Gson(CUSTOM_EXCLUDER, CUSTOM_FIELD_NAMING_STRATEGY, new HashMap<>(), true, false, true, false, FormattingStyle.PRETTY, Strictness.LENIENT, false, true, LongSerializationPolicy.DEFAULT, null, DateFormat.DEFAULT, DateFormat.DEFAULT, new ArrayList<>(), new ArrayList<>(), new ArrayList<>(), CUSTOM_OBJECT_TO_NUMBER_STRATEGY, CUSTOM_NUMBER_TO_NUMBER_STRATEGY, Collections.emptyList());\r\n    Gson clone = original.newBuilder().registerTypeAdapter(int.class, new TestTypeAdapter()).create();\r\n    assertThat(clone.factories).hasSize(original.factories.size() + 1);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  },
  {
    "type": "method",
    "name": "testFromJson_WrongResultType",
    "start_line": 137,
    "end_line": 190,
    "code": "@Test\r\npublic void testFromJson_WrongResultType() {\r\n    class IntegerAdapter extends TypeAdapter<Integer> {\r\n\r\n        @Override\r\n        public Integer read(JsonReader in) throws IOException {\r\n            in.skipValue();\r\n            return 3;\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Integer value) {\r\n            throw new AssertionError(\"not needed for test\");\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"custom-adapter\";\r\n        }\r\n    }\r\n    Gson gson = new GsonBuilder().registerTypeAdapter(Boolean.class, new IntegerAdapter()).create();\r\n    // Use `Class<?>` here to avoid that the JVM itself creates the ClassCastException (though the\r\n    // check below for the custom message would detect that as well)\r\n    Class<?> deserializedClass = Boolean.class;\r\n    var exception = assertThrows(ClassCastException.class, () -> gson.fromJson(\"true\", deserializedClass));\r\n    assertThat(exception).hasMessageThat().isEqualTo(\"Type adapter 'custom-adapter' returned wrong type; requested class java.lang.Boolean\" + \" but got instance of class java.lang.Integer\\n\" + \"Verify that the adapter was registered for the correct type.\");\r\n    // Returning boxed primitive should be allowed (e.g. returning `Integer` for `int`)\r\n    Gson gson2 = new GsonBuilder().registerTypeAdapter(int.class, new IntegerAdapter()).create();\r\n    assertThat(gson2.fromJson(\"0\", int.class)).isEqualTo(3);\r\n    class NullAdapter extends TypeAdapter<Object> {\r\n\r\n        @Override\r\n        public Object read(JsonReader in) throws IOException {\r\n            in.skipValue();\r\n            return null;\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Object value) {\r\n            throw new AssertionError(\"not needed for test\");\r\n        }\r\n    }\r\n    // Returning `null` should be allowed\r\n    Gson gson3 = new GsonBuilder().registerTypeAdapter(Boolean.class, new NullAdapter()).create();\r\n    assertThat(gson3.fromJson(\"true\", Boolean.class)).isNull();\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  },
  {
    "type": "method",
    "name": "testGetAdapter_Null",
    "start_line": 192,
    "end_line": 198,
    "code": "@Test\r\npublic void testGetAdapter_Null() {\r\n    Gson gson = new Gson();\r\n    NullPointerException e = assertThrows(NullPointerException.class, () -> gson.getAdapter((TypeToken<?>) null));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"type must not be null\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  },
  {
    "type": "method",
    "name": "testGetAdapter_Concurrency",
    "start_line": 200,
    "end_line": 258,
    "code": "@Test\r\npublic void testGetAdapter_Concurrency() {\r\n    class DummyAdapter<T> extends TypeAdapter<T> {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, T value) throws IOException {\r\n            throw new AssertionError(\"not needed for this test\");\r\n        }\r\n\r\n        @Override\r\n        public T read(JsonReader in) throws IOException {\r\n            throw new AssertionError(\"not needed for this test\");\r\n        }\r\n    }\r\n    AtomicInteger adapterInstancesCreated = new AtomicInteger(0);\r\n    AtomicReference<TypeAdapter<?>> threadAdapter = new AtomicReference<>();\r\n    Class<?> requestedType = Number.class;\r\n    Gson gson = new GsonBuilder().registerTypeAdapterFactory(new TypeAdapterFactory() {\r\n\r\n        private volatile boolean isFirstCall = true;\r\n\r\n        @Override\r\n        public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\r\n            if (isFirstCall) {\r\n                isFirstCall = false;\r\n                // Create a separate thread which requests an adapter for the same type\r\n                // This will cause this factory to return a different adapter instance than\r\n                // the one it is currently creating\r\n                Thread thread = new Thread() {\r\n\r\n                    @Override\r\n                    public void run() {\r\n                        threadAdapter.set(gson.getAdapter(requestedType));\r\n                    }\r\n                };\r\n                thread.start();\r\n                try {\r\n                    thread.join();\r\n                } catch (InterruptedException e) {\r\n                    throw new RuntimeException(e);\r\n                }\r\n            }\r\n            // Create a new dummy adapter instance\r\n            adapterInstancesCreated.incrementAndGet();\r\n            return new DummyAdapter<>();\r\n        }\r\n    }).create();\r\n    TypeAdapter<?> adapter = gson.getAdapter(requestedType);\r\n    assertThat(adapterInstancesCreated.get()).isEqualTo(2);\r\n    assertThat(adapter).isInstanceOf(DummyAdapter.class);\r\n    assertThat(threadAdapter.get()).isInstanceOf(DummyAdapter.class);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  },
  {
    "type": "method",
    "name": "testGetAdapter_FutureAdapterConcurrency",
    "start_line": 268,
    "end_line": 368,
    "code": "/**\r\n * Verifies that two threads calling {@link Gson#getAdapter(TypeToken)} do not see the same\r\n * unresolved {@link FutureTypeAdapter} instance, since that would not be thread-safe.\r\n *\r\n * <p>This test constructs the cyclic dependency {@literal CustomClass1 -> CustomClass2 ->\r\n * CustomClass1} and lets one thread wait after the adapter for CustomClass2 has been obtained\r\n * (which still refers to the nested unresolved FutureTypeAdapter for CustomClass1).\r\n */\r\n@Test\r\npublic void testGetAdapter_FutureAdapterConcurrency() throws Exception {\r\n    /**\r\n     * Adapter which wraps another adapter. Can be imagined as a simplified version of the {@code\r\n     * ReflectiveTypeAdapterFactory$Adapter}.\r\n     */\r\n    class WrappingAdapter<T> extends TypeAdapter<T> {\r\n\r\n        final TypeAdapter<?> wrapped;\r\n\r\n        boolean isFirstCall = true;\r\n\r\n        WrappingAdapter(TypeAdapter<?> wrapped) {\r\n            this.wrapped = wrapped;\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, T value) throws IOException {\r\n            // Due to how this test is set up there is infinite recursion, therefore\r\n            // need to track how deeply nested this call is\r\n            if (isFirstCall) {\r\n                isFirstCall = false;\r\n                out.beginArray();\r\n                wrapped.write(out, null);\r\n                out.endArray();\r\n                isFirstCall = true;\r\n            } else {\r\n                out.value(\"wrapped-nested\");\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public T read(JsonReader in) throws IOException {\r\n            throw new AssertionError(\"not needed for this test\");\r\n        }\r\n    }\r\n    CountDownLatch isThreadWaiting = new CountDownLatch(1);\r\n    CountDownLatch canThreadProceed = new CountDownLatch(1);\r\n    Gson gson = new GsonBuilder().registerTypeAdapterFactory(new TypeAdapterFactory() {\r\n\r\n        // volatile instead of AtomicBoolean is safe here because CountDownLatch prevents\r\n        // \"true\" concurrency\r\n        volatile boolean isFirstCaller = true;\r\n\r\n        @Override\r\n        public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\r\n            Class<?> raw = type.getRawType();\r\n            if (raw == CustomClass1.class) {\r\n                // Retrieves a WrappingAdapter containing a nested FutureAdapter for\r\n                // CustomClass1\r\n                TypeAdapter<?> adapter = gson.getAdapter(CustomClass2.class);\r\n                // Let thread wait so the FutureAdapter for CustomClass1 nested in the adapter\r\n                // for CustomClass2 is not resolved yet\r\n                if (isFirstCaller) {\r\n                    isFirstCaller = false;\r\n                    isThreadWaiting.countDown();\r\n                    try {\r\n                        canThreadProceed.await();\r\n                    } catch (InterruptedException e) {\r\n                        throw new RuntimeException(e);\r\n                    }\r\n                }\r\n                return new WrappingAdapter<>(adapter);\r\n            } else if (raw == CustomClass2.class) {\r\n                TypeAdapter<?> adapter = gson.getAdapter(CustomClass1.class);\r\n                assertThat(adapter).isInstanceOf(FutureTypeAdapter.class);\r\n                return new WrappingAdapter<>(adapter);\r\n            } else {\r\n                throw new AssertionError(\"Adapter for unexpected type requested: \" + raw);\r\n            }\r\n        }\r\n    }).create();\r\n    AtomicReference<TypeAdapter<?>> otherThreadAdapter = new AtomicReference<>();\r\n    Thread thread = new Thread() {\r\n\r\n        @Override\r\n        public void run() {\r\n            otherThreadAdapter.set(gson.getAdapter(CustomClass1.class));\r\n        }\r\n    };\r\n    thread.start();\r\n    // Wait until other thread has obtained FutureAdapter\r\n    isThreadWaiting.await();\r\n    TypeAdapter<?> adapter = gson.getAdapter(CustomClass1.class);\r\n    // Should not fail due to referring to unresolved FutureTypeAdapter\r\n    assertThat(adapter.toJson(null)).isEqualTo(\"[[\\\"wrapped-nested\\\"]]\");\r\n    // Let other thread proceed and have it resolve its FutureTypeAdapter\r\n    canThreadProceed.countDown();\r\n    thread.join();\r\n    assertThat(otherThreadAdapter.get().toJson(null)).isEqualTo(\"[[\\\"wrapped-nested\\\"]]\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  },
  {
    "type": "method",
    "name": "testGetDelegateAdapter",
    "start_line": 370,
    "end_line": 454,
    "code": "@Test\r\npublic void testGetDelegateAdapter() {\r\n    class DummyAdapter extends TypeAdapter<Number> {\r\n\r\n        private final int number;\r\n\r\n        DummyAdapter(int number) {\r\n            this.number = number;\r\n        }\r\n\r\n        @Override\r\n        public Number read(JsonReader in) throws IOException {\r\n            throw new AssertionError(\"not needed for test\");\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Number value) throws IOException {\r\n            throw new AssertionError(\"not needed for test\");\r\n        }\r\n\r\n        // Override toString() for better assertion error messages\r\n        @Override\r\n        public String toString() {\r\n            return \"adapter-\" + number;\r\n        }\r\n    }\r\n    class DummyFactory implements TypeAdapterFactory {\r\n\r\n        private final DummyAdapter adapter;\r\n\r\n        DummyFactory(DummyAdapter adapter) {\r\n            this.adapter = adapter;\r\n        }\r\n\r\n        @SuppressWarnings(\"unchecked\")\r\n        @Override\r\n        public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\r\n            return (TypeAdapter<T>) adapter;\r\n        }\r\n\r\n        // Override equals to verify that reference equality check is performed by Gson,\r\n        // and this method is ignored\r\n        @Override\r\n        public boolean equals(Object obj) {\r\n            return obj instanceof DummyFactory && ((DummyFactory) obj).adapter.equals(adapter);\r\n        }\r\n\r\n        @Override\r\n        public int hashCode() {\r\n            return adapter.hashCode();\r\n        }\r\n    }\r\n    DummyAdapter adapter1 = new DummyAdapter(1);\r\n    DummyFactory factory1 = new DummyFactory(adapter1);\r\n    DummyAdapter adapter2 = new DummyAdapter(2);\r\n    DummyFactory factory2 = new DummyFactory(adapter2);\r\n    Gson gson = new GsonBuilder().// Note: This is 'last in, first out' order; Gson will first use factory2, then factory1\r\n    registerTypeAdapterFactory(factory1).registerTypeAdapterFactory(factory2).create();\r\n    TypeToken<?> type = TypeToken.get(Number.class);\r\n    assertThrows(NullPointerException.class, () -> gson.getDelegateAdapter(null, type));\r\n    assertThrows(NullPointerException.class, () -> gson.getDelegateAdapter(factory1, null));\r\n    // For unknown factory the first adapter for that type should be returned\r\n    assertThat(gson.getDelegateAdapter(new DummyFactory(new DummyAdapter(0)), type)).isEqualTo(adapter2);\r\n    assertThat(gson.getDelegateAdapter(factory2, type)).isEqualTo(adapter1);\r\n    // Default Gson adapter should be returned\r\n    assertThat(gson.getDelegateAdapter(factory1, type)).isNotInstanceOf(DummyAdapter.class);\r\n    DummyFactory factory1Eq = new DummyFactory(adapter1);\r\n    // Verify that test setup is correct\r\n    assertThat(factory1.equals(factory1Eq)).isTrue();\r\n    // Should only consider reference equality and ignore that custom `equals` method considers\r\n    // factories to be equal, therefore returning `adapter2` which came from `factory2` instead\r\n    // of skipping past `factory1`\r\n    assertThat(gson.getDelegateAdapter(factory1Eq, type)).isEqualTo(adapter2);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  },
  {
    "type": "method",
    "name": "testNewJsonWriter_Default",
    "start_line": 456,
    "end_line": 473,
    "code": "@Test\r\npublic void testNewJsonWriter_Default() throws IOException {\r\n    StringWriter writer = new StringWriter();\r\n    JsonWriter jsonWriter = new Gson().newJsonWriter(writer);\r\n    jsonWriter.beginObject();\r\n    jsonWriter.name(\"test\");\r\n    jsonWriter.nullValue();\r\n    jsonWriter.name(\"<test2\");\r\n    jsonWriter.value(true);\r\n    jsonWriter.endObject();\r\n    // Additional top-level value\r\n    IllegalStateException e = assertThrows(IllegalStateException.class, () -> jsonWriter.value(1));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"JSON must have only one top-level value.\");\r\n    jsonWriter.close();\r\n    assertThat(writer.toString()).isEqualTo(\"{\\\"\\\\u003ctest2\\\":true}\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  },
  {
    "type": "method",
    "name": "testNewJsonWriter_Custom",
    "start_line": 475,
    "end_line": 500,
    "code": "// for GsonBuilder.setLenient\r\n@SuppressWarnings({ \"deprecation\", \"InlineMeInliner\" })\r\n@Test\r\npublic void testNewJsonWriter_Custom() throws IOException {\r\n    StringWriter writer = new StringWriter();\r\n    JsonWriter jsonWriter = new GsonBuilder().disableHtmlEscaping().generateNonExecutableJson().setPrettyPrinting().serializeNulls().setLenient().create().newJsonWriter(writer);\r\n    jsonWriter.beginObject();\r\n    jsonWriter.name(\"test\");\r\n    jsonWriter.nullValue();\r\n    jsonWriter.name(\"<test2\");\r\n    jsonWriter.value(true);\r\n    jsonWriter.endObject();\r\n    // Additional top-level value\r\n    jsonWriter.value(1);\r\n    jsonWriter.close();\r\n    assertThat(writer.toString()).isEqualTo(\")]}'\\n{\\n  \\\"test\\\": null,\\n  \\\"<test2\\\": true\\n}1\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  },
  {
    "type": "method",
    "name": "testNewJsonReader_Default",
    "start_line": 502,
    "end_line": 508,
    "code": "@Test\r\npublic void testNewJsonReader_Default() throws IOException {\r\n    // String without quotes\r\n    String json = \"test\";\r\n    JsonReader jsonReader = new Gson().newJsonReader(new StringReader(json));\r\n    assertThrows(MalformedJsonException.class, jsonReader::nextString);\r\n    jsonReader.close();\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  },
  {
    "type": "method",
    "name": "testNewJsonReader_Custom",
    "start_line": 510,
    "end_line": 518,
    "code": "// for GsonBuilder.setLenient\r\n@SuppressWarnings({ \"deprecation\", \"InlineMeInliner\" })\r\n@Test\r\npublic void testNewJsonReader_Custom() throws IOException {\r\n    // String without quotes\r\n    String json = \"test\";\r\n    JsonReader jsonReader = new GsonBuilder().setLenient().create().newJsonReader(new StringReader(json));\r\n    assertThat(jsonReader.nextString()).isEqualTo(\"test\");\r\n    jsonReader.close();\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  },
  {
    "type": "method",
    "name": "testDefaultGsonNewBuilderModification",
    "start_line": 524,
    "end_line": 559,
    "code": "/**\r\n * Modifying a GsonBuilder obtained from {@link Gson#newBuilder()} of a {@code new Gson()} should\r\n * not affect the Gson instance it came from.\r\n */\r\n@Test\r\npublic void testDefaultGsonNewBuilderModification() {\r\n    Gson gson = new Gson();\r\n    GsonBuilder gsonBuilder = gson.newBuilder();\r\n    // Modifications of `gsonBuilder` should not affect `gson` object\r\n    gsonBuilder.registerTypeAdapter(CustomClass1.class, new TypeAdapter<CustomClass1>() {\r\n\r\n        @Override\r\n        public CustomClass1 read(JsonReader in) throws IOException {\r\n            throw new UnsupportedOperationException();\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, CustomClass1 value) throws IOException {\r\n            out.value(\"custom-adapter\");\r\n        }\r\n    });\r\n    gsonBuilder.registerTypeHierarchyAdapter(CustomClass2.class, (JsonSerializer<CustomClass2>) (src, typeOfSrc, context) -> new JsonPrimitive(\"custom-hierarchy-adapter\"));\r\n    gsonBuilder.registerTypeAdapter(CustomClass3.class, (InstanceCreator<CustomClass3>) type -> new CustomClass3(\"custom-instance\"));\r\n    assertDefaultGson(gson);\r\n    // New GsonBuilder created from `gson` should not have been affected by changes either\r\n    assertDefaultGson(gson.newBuilder().create());\r\n    // But new Gson instance from `gsonBuilder` should use custom adapters\r\n    assertCustomGson(gsonBuilder.create());\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  },
  {
    "type": "method",
    "name": "assertDefaultGson",
    "start_line": 561,
    "end_line": 573,
    "code": "private static void assertDefaultGson(Gson gson) {\r\n    // Should use default reflective adapter\r\n    String json1 = gson.toJson(new CustomClass1());\r\n    assertThat(json1).isEqualTo(\"{}\");\r\n    // Should use default reflective adapter\r\n    String json2 = gson.toJson(new CustomClass2());\r\n    assertThat(json2).isEqualTo(\"{}\");\r\n    // Should use default instance creator\r\n    CustomClass3 customClass3 = gson.fromJson(\"{}\", CustomClass3.class);\r\n    assertThat(customClass3.s).isEqualTo(CustomClass3.NO_ARG_CONSTRUCTOR_VALUE);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  },
  {
    "type": "method",
    "name": "testNewBuilderModification",
    "start_line": 579,
    "end_line": 645,
    "code": "/**\r\n * Modifying a GsonBuilder obtained from {@link Gson#newBuilder()} of a custom Gson instance\r\n * (created using a GsonBuilder) should not affect the Gson instance it came from.\r\n */\r\n@Test\r\npublic void testNewBuilderModification() {\r\n    Gson gson = new GsonBuilder().registerTypeAdapter(CustomClass1.class, new TypeAdapter<CustomClass1>() {\r\n\r\n        @Override\r\n        public CustomClass1 read(JsonReader in) throws IOException {\r\n            throw new UnsupportedOperationException();\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, CustomClass1 value) throws IOException {\r\n            out.value(\"custom-adapter\");\r\n        }\r\n    }).registerTypeHierarchyAdapter(CustomClass2.class, (JsonSerializer<CustomClass2>) (src, typeOfSrc, context) -> new JsonPrimitive(\"custom-hierarchy-adapter\")).registerTypeAdapter(CustomClass3.class, (InstanceCreator<CustomClass3>) type -> new CustomClass3(\"custom-instance\")).create();\r\n    assertCustomGson(gson);\r\n    // Modify `gson.newBuilder()`\r\n    GsonBuilder gsonBuilder = gson.newBuilder();\r\n    gsonBuilder.registerTypeAdapter(CustomClass1.class, new TypeAdapter<CustomClass1>() {\r\n\r\n        @Override\r\n        public CustomClass1 read(JsonReader in) throws IOException {\r\n            throw new UnsupportedOperationException();\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, CustomClass1 value) throws IOException {\r\n            out.value(\"overwritten custom-adapter\");\r\n        }\r\n    });\r\n    gsonBuilder.registerTypeHierarchyAdapter(CustomClass2.class, (JsonSerializer<CustomClass2>) (src, typeOfSrc, context) -> new JsonPrimitive(\"overwritten custom-hierarchy-adapter\"));\r\n    gsonBuilder.registerTypeAdapter(CustomClass3.class, (InstanceCreator<CustomClass3>) type -> new CustomClass3(\"overwritten custom-instance\"));\r\n    // `gson` object should not have been affected by changes to new GsonBuilder\r\n    assertCustomGson(gson);\r\n    // New GsonBuilder based on `gson` should not have been affected either\r\n    assertCustomGson(gson.newBuilder().create());\r\n    // But new Gson instance from `gsonBuilder` should be affected by changes\r\n    Gson otherGson = gsonBuilder.create();\r\n    String json1 = otherGson.toJson(new CustomClass1());\r\n    assertThat(json1).isEqualTo(\"\\\"overwritten custom-adapter\\\"\");\r\n    String json2 = otherGson.toJson(new CustomClass2());\r\n    assertThat(json2).isEqualTo(\"\\\"overwritten custom-hierarchy-adapter\\\"\");\r\n    CustomClass3 customClass3 = otherGson.fromJson(\"{}\", CustomClass3.class);\r\n    assertThat(customClass3.s).isEqualTo(\"overwritten custom-instance\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  },
  {
    "type": "method",
    "name": "assertCustomGson",
    "start_line": 647,
    "end_line": 656,
    "code": "private static void assertCustomGson(Gson gson) {\r\n    String json1 = gson.toJson(new CustomClass1());\r\n    assertThat(json1).isEqualTo(\"\\\"custom-adapter\\\"\");\r\n    String json2 = gson.toJson(new CustomClass2());\r\n    assertThat(json2).isEqualTo(\"\\\"custom-hierarchy-adapter\\\"\");\r\n    CustomClass3 customClass3 = gson.fromJson(\"{}\", CustomClass3.class);\r\n    assertThat(customClass3.s).isEqualTo(\"custom-instance\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\GsonTest.java"
  }
]