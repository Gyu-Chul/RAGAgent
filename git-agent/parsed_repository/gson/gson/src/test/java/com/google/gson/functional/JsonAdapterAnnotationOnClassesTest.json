[
  {
    "type": "package",
    "name": "com.google.gson.functional",
    "start_line": 17,
    "end_line": 17,
    "code": "package com.google.gson.functional;\r\n\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "import",
    "name": "com.google.common.truth.Truth.assertThat",
    "start_line": 19,
    "end_line": 19,
    "code": "import static com.google.common.truth.Truth.assertThat;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "import",
    "name": "org.junit.Assert.assertThrows",
    "start_line": 20,
    "end_line": 20,
    "code": "import static org.junit.Assert.assertThrows;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "import",
    "name": "com.google.common.base.Splitter",
    "start_line": 22,
    "end_line": 22,
    "code": "import com.google.common.base.Splitter;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.Gson",
    "start_line": 23,
    "end_line": 23,
    "code": "import com.google.gson.Gson;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.GsonBuilder",
    "start_line": 24,
    "end_line": 24,
    "code": "import com.google.gson.GsonBuilder;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.InstanceCreator",
    "start_line": 25,
    "end_line": 25,
    "code": "import com.google.gson.InstanceCreator;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.JsonDeserializationContext",
    "start_line": 26,
    "end_line": 26,
    "code": "import com.google.gson.JsonDeserializationContext;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.JsonDeserializer",
    "start_line": 27,
    "end_line": 27,
    "code": "import com.google.gson.JsonDeserializer;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.JsonElement",
    "start_line": 28,
    "end_line": 28,
    "code": "import com.google.gson.JsonElement;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.JsonPrimitive",
    "start_line": 29,
    "end_line": 29,
    "code": "import com.google.gson.JsonPrimitive;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.JsonSerializationContext",
    "start_line": 30,
    "end_line": 30,
    "code": "import com.google.gson.JsonSerializationContext;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.JsonSerializer",
    "start_line": 31,
    "end_line": 31,
    "code": "import com.google.gson.JsonSerializer;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.TypeAdapter",
    "start_line": 32,
    "end_line": 32,
    "code": "import com.google.gson.TypeAdapter;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.TypeAdapterFactory",
    "start_line": 33,
    "end_line": 33,
    "code": "import com.google.gson.TypeAdapterFactory;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.annotations.JsonAdapter",
    "start_line": 34,
    "end_line": 34,
    "code": "import com.google.gson.annotations.JsonAdapter;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.reflect.TypeToken",
    "start_line": 35,
    "end_line": 35,
    "code": "import com.google.gson.reflect.TypeToken;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.stream.JsonReader",
    "start_line": 36,
    "end_line": 36,
    "code": "import com.google.gson.stream.JsonReader;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.stream.JsonWriter",
    "start_line": 37,
    "end_line": 37,
    "code": "import com.google.gson.stream.JsonWriter;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "import",
    "name": "java.io.IOException",
    "start_line": 38,
    "end_line": 38,
    "code": "import java.io.IOException;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "import",
    "name": "java.lang.reflect.ParameterizedType",
    "start_line": 39,
    "end_line": 39,
    "code": "import java.lang.reflect.ParameterizedType;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "import",
    "name": "java.lang.reflect.Type",
    "start_line": 40,
    "end_line": 40,
    "code": "import java.lang.reflect.Type;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "import",
    "name": "java.util.List",
    "start_line": 41,
    "end_line": 41,
    "code": "import java.util.List;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "import",
    "name": "java.util.Locale",
    "start_line": 42,
    "end_line": 42,
    "code": "import java.util.Locale;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "import",
    "name": "org.junit.Test",
    "start_line": 43,
    "end_line": 43,
    "code": "import org.junit.Test;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "class",
    "name": "JsonAdapterAnnotationOnClassesTest",
    "start_line": 46,
    "end_line": 806,
    "code": "/**\r\n * Functional tests for the {@link JsonAdapter} annotation on classes.\r\n */\r\n// for dummy classes A, B, ...\r\n@SuppressWarnings(\"ClassNamedLikeTypeParameter\")\r\npublic final class JsonAdapterAnnotationOnClassesTest {\r\n\r\n    @Test\r\n    public void testJsonAdapterInvoked() {\r\n        Gson gson = new Gson();\r\n        String json = gson.toJson(new A(\"bar\"));\r\n        assertThat(json).isEqualTo(\"\\\"jsonAdapter\\\"\");\r\n        // Also invoke the JsonAdapter javadoc sample\r\n        json = gson.toJson(new User(\"Inderjeet\", \"Singh\"));\r\n        assertThat(json).isEqualTo(\"{\\\"name\\\":\\\"Inderjeet Singh\\\"}\");\r\n        User user = gson.fromJson(\"{'name':'Joel Leitch'}\", User.class);\r\n        assertThat(user.firstName).isEqualTo(\"Joel\");\r\n        assertThat(user.lastName).isEqualTo(\"Leitch\");\r\n        json = gson.toJson(Foo.BAR);\r\n        assertThat(json).isEqualTo(\"\\\"bar\\\"\");\r\n        Foo baz = gson.fromJson(\"\\\"baz\\\"\", Foo.class);\r\n        assertThat(baz).isEqualTo(Foo.BAZ);\r\n    }\r\n\r\n    @Test\r\n    public void testJsonAdapterFactoryInvoked() {\r\n        Gson gson = new Gson();\r\n        String json = gson.toJson(new C(\"bar\"));\r\n        assertThat(json).isEqualTo(\"\\\"jsonAdapterFactory\\\"\");\r\n        C c = gson.fromJson(\"\\\"bar\\\"\", C.class);\r\n        assertThat(c.value).isEqualTo(\"jsonAdapterFactory\");\r\n    }\r\n\r\n    @Test\r\n    public void testRegisteredAdapterOverridesJsonAdapter() {\r\n        TypeAdapter<A> typeAdapter = new TypeAdapter<>() {\r\n\r\n            @Override\r\n            public void write(JsonWriter out, A value) throws IOException {\r\n                out.value(\"registeredAdapter\");\r\n            }\r\n\r\n            @Override\r\n            public A read(JsonReader in) throws IOException {\r\n                return new A(in.nextString());\r\n            }\r\n        };\r\n        Gson gson = new GsonBuilder().registerTypeAdapter(A.class, typeAdapter).create();\r\n        String json = gson.toJson(new A(\"abcd\"));\r\n        assertThat(json).isEqualTo(\"\\\"registeredAdapter\\\"\");\r\n    }\r\n\r\n    /**\r\n     * The serializer overrides field adapter, but for deserializer the fieldAdapter is used.\r\n     */\r\n    @Test\r\n    public void testRegisteredSerializerOverridesJsonAdapter() {\r\n        JsonSerializer<A> serializer = (src, typeOfSrc, context) -> new JsonPrimitive(\"registeredSerializer\");\r\n        Gson gson = new GsonBuilder().registerTypeAdapter(A.class, serializer).create();\r\n        String json = gson.toJson(new A(\"abcd\"));\r\n        assertThat(json).isEqualTo(\"\\\"registeredSerializer\\\"\");\r\n        A target = gson.fromJson(\"abcd\", A.class);\r\n        assertThat(target.value).isEqualTo(\"jsonAdapter\");\r\n    }\r\n\r\n    /**\r\n     * The deserializer overrides Json adapter, but for serializer the jsonAdapter is used.\r\n     */\r\n    @Test\r\n    public void testRegisteredDeserializerOverridesJsonAdapter() {\r\n        JsonDeserializer<A> deserializer = (json, typeOfT, context) -> new A(\"registeredDeserializer\");\r\n        Gson gson = new GsonBuilder().registerTypeAdapter(A.class, deserializer).create();\r\n        String json = gson.toJson(new A(\"abcd\"));\r\n        assertThat(json).isEqualTo(\"\\\"jsonAdapter\\\"\");\r\n        A target = gson.fromJson(\"abcd\", A.class);\r\n        assertThat(target.value).isEqualTo(\"registeredDeserializer\");\r\n    }\r\n\r\n    @Test\r\n    public void testIncorrectTypeAdapterFails() {\r\n        Gson gson = new Gson();\r\n        ClassWithIncorrectJsonAdapter obj = new ClassWithIncorrectJsonAdapter(\"bar\");\r\n        assertThrows(ClassCastException.class, () -> gson.toJson(obj));\r\n    }\r\n\r\n    @Test\r\n    public void testSuperclassTypeAdapterNotInvoked() {\r\n        String json = new Gson().toJson(new B(\"bar\"));\r\n        assertThat(json).doesNotContain(\"jsonAdapter\");\r\n    }\r\n\r\n    @Test\r\n    public void testNullSafeObject() {\r\n        Gson gson = new Gson();\r\n        NullableClass fromJson = gson.fromJson(\"null\", NullableClass.class);\r\n        assertThat(fromJson).isNull();\r\n        fromJson = gson.fromJson(\"\\\"ignored\\\"\", NullableClass.class);\r\n        assertThat(fromJson).isNotNull();\r\n        String json = gson.toJson(null, NullableClass.class);\r\n        assertThat(json).isEqualTo(\"null\");\r\n        json = gson.toJson(new NullableClass());\r\n        assertThat(json).isEqualTo(\"\\\"nullable\\\"\");\r\n    }\r\n\r\n    /**\r\n     * Tests behavior when a {@link TypeAdapterFactory} registered with {@code @JsonAdapter} returns\r\n     * {@code null}, indicating that it cannot handle the type and Gson should try a different factory\r\n     * instead.\r\n     */\r\n    @Test\r\n    public void testFactoryReturningNull() {\r\n        Gson gson = new Gson();\r\n        assertThat(gson.fromJson(\"null\", WithNullReturningFactory.class)).isNull();\r\n        assertThat(gson.toJson(null, WithNullReturningFactory.class)).isEqualTo(\"null\");\r\n        TypeToken<WithNullReturningFactory<String>> stringTypeArg = new TypeToken<>() {\r\n        };\r\n        WithNullReturningFactory<?> deserialized = gson.fromJson(\"\\\"a\\\"\", stringTypeArg);\r\n        assertThat(deserialized.t).isEqualTo(\"custom-read:a\");\r\n        assertThat(gson.fromJson(\"null\", stringTypeArg)).isNull();\r\n        assertThat(gson.toJson(new WithNullReturningFactory<>(\"b\"), stringTypeArg.getType())).isEqualTo(\"\\\"custom-write:b\\\"\");\r\n        assertThat(gson.toJson(null, stringTypeArg.getType())).isEqualTo(\"null\");\r\n        // Factory should return `null` for this type and Gson should fall back to reflection-based\r\n        // adapter\r\n        TypeToken<WithNullReturningFactory<Integer>> numberTypeArg = new TypeToken<>() {\r\n        };\r\n        deserialized = gson.fromJson(\"{\\\"t\\\":1}\", numberTypeArg);\r\n        assertThat(deserialized.t).isEqualTo(1);\r\n        assertThat(gson.toJson(new WithNullReturningFactory<>(2), numberTypeArg.getType())).isEqualTo(\"{\\\"t\\\":2}\");\r\n    }\r\n\r\n    // Also set `nullSafe = true` to verify that this does not cause a NullPointerException if the\r\n    // factory would accidentally call `nullSafe()` on null adapter\r\n    @JsonAdapter(value = WithNullReturningFactory.NullReturningFactory.class, nullSafe = true)\r\n    private static class WithNullReturningFactory<T> {\r\n\r\n        T t;\r\n\r\n        public WithNullReturningFactory(T t) {\r\n            this.t = t;\r\n        }\r\n\r\n        static class NullReturningFactory implements TypeAdapterFactory {\r\n\r\n            @Override\r\n            public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\r\n                // Don't handle raw (non-parameterized) type\r\n                if (type.getType() instanceof Class) {\r\n                    return null;\r\n                }\r\n                ParameterizedType parameterizedType = (ParameterizedType) type.getType();\r\n                // Makes this test a bit more realistic by only conditionally returning null (instead of\r\n                // always)\r\n                if (parameterizedType.getActualTypeArguments()[0] != String.class) {\r\n                    return null;\r\n                }\r\n                @SuppressWarnings(\"unchecked\")\r\n                TypeAdapter<T> adapter = (TypeAdapter<T>) new TypeAdapter<WithNullReturningFactory<String>>() {\r\n\r\n                    @Override\r\n                    public void write(JsonWriter out, WithNullReturningFactory<String> value) throws IOException {\r\n                        out.value(\"custom-write:\" + value.t);\r\n                    }\r\n\r\n                    @Override\r\n                    public WithNullReturningFactory<String> read(JsonReader in) throws IOException {\r\n                        return new WithNullReturningFactory<>(\"custom-read:\" + in.nextString());\r\n                    }\r\n                };\r\n                return adapter;\r\n            }\r\n        }\r\n    }\r\n\r\n    @JsonAdapter(A.JsonAdapter.class)\r\n    private static class A {\r\n\r\n        final String value;\r\n\r\n        A(String value) {\r\n            this.value = value;\r\n        }\r\n\r\n        static final class JsonAdapter extends TypeAdapter<A> {\r\n\r\n            @Override\r\n            public void write(JsonWriter out, A value) throws IOException {\r\n                out.value(\"jsonAdapter\");\r\n            }\r\n\r\n            @Override\r\n            public A read(JsonReader in) throws IOException {\r\n                String unused = in.nextString();\r\n                return new A(\"jsonAdapter\");\r\n            }\r\n        }\r\n    }\r\n\r\n    @JsonAdapter(C.JsonAdapterFactory.class)\r\n    private static class C {\r\n\r\n        final String value;\r\n\r\n        C(String value) {\r\n            this.value = value;\r\n        }\r\n\r\n        static final class JsonAdapterFactory implements TypeAdapterFactory {\r\n\r\n            @Override\r\n            public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\r\n                return new TypeAdapter<>() {\r\n\r\n                    @Override\r\n                    public void write(JsonWriter out, T value) throws IOException {\r\n                        out.value(\"jsonAdapterFactory\");\r\n                    }\r\n\r\n                    @SuppressWarnings(\"unchecked\")\r\n                    @Override\r\n                    public T read(JsonReader in) throws IOException {\r\n                        String unused = in.nextString();\r\n                        return (T) new C(\"jsonAdapterFactory\");\r\n                    }\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    private static final class B extends A {\r\n\r\n        B(String value) {\r\n            super(value);\r\n        }\r\n    }\r\n\r\n    // Note that the type is NOT TypeAdapter<ClassWithIncorrectJsonAdapter> so this\r\n    // should cause error\r\n    @JsonAdapter(A.JsonAdapter.class)\r\n    private static final class ClassWithIncorrectJsonAdapter {\r\n\r\n        @SuppressWarnings(\"unused\")\r\n        final String value;\r\n\r\n        ClassWithIncorrectJsonAdapter(String value) {\r\n            this.value = value;\r\n        }\r\n    }\r\n\r\n    // This class is used in JsonAdapter Javadoc as an example\r\n    @JsonAdapter(UserJsonAdapter.class)\r\n    private static class User {\r\n\r\n        final String firstName;\r\n\r\n        final String lastName;\r\n\r\n        User(String firstName, String lastName) {\r\n            this.firstName = firstName;\r\n            this.lastName = lastName;\r\n        }\r\n    }\r\n\r\n    private static class UserJsonAdapter extends TypeAdapter<User> {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, User user) throws IOException {\r\n            // implement write: combine firstName and lastName into name\r\n            out.beginObject();\r\n            out.name(\"name\");\r\n            out.value(user.firstName + \" \" + user.lastName);\r\n            out.endObject();\r\n        }\r\n\r\n        @Override\r\n        public User read(JsonReader in) throws IOException {\r\n            // implement read: split name into firstName and lastName\r\n            in.beginObject();\r\n            String unused = in.nextName();\r\n            List<String> nameParts = Splitter.on(\" \").splitToList(in.nextString());\r\n            in.endObject();\r\n            return new User(nameParts.get(0), nameParts.get(1));\r\n        }\r\n    }\r\n\r\n    // Implicit `nullSafe=true`\r\n    @JsonAdapter(value = NullableClassJsonAdapter.class)\r\n    private static class NullableClass {\r\n    }\r\n\r\n    private static class NullableClassJsonAdapter extends TypeAdapter<NullableClass> {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, NullableClass value) throws IOException {\r\n            out.value(\"nullable\");\r\n        }\r\n\r\n        @Override\r\n        public NullableClass read(JsonReader in) throws IOException {\r\n            String unused = in.nextString();\r\n            return new NullableClass();\r\n        }\r\n    }\r\n\r\n    @JsonAdapter(FooJsonAdapter.class)\r\n    private static enum Foo {\r\n\r\n        BAR, BAZ\r\n    }\r\n\r\n    private static class FooJsonAdapter extends TypeAdapter<Foo> {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Foo value) throws IOException {\r\n            out.value(value.name().toLowerCase(Locale.US));\r\n        }\r\n\r\n        @Override\r\n        public Foo read(JsonReader in) throws IOException {\r\n            return Foo.valueOf(in.nextString().toUpperCase(Locale.US));\r\n        }\r\n    }\r\n\r\n    @Test\r\n    public void testIncorrectJsonAdapterType() {\r\n        Gson gson = new Gson();\r\n        WithInvalidAdapterClass obj = new WithInvalidAdapterClass();\r\n        var e = assertThrows(IllegalArgumentException.class, () -> gson.toJson(obj));\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Invalid attempt to bind an instance of java.lang.Integer as a @JsonAdapter for \" + WithInvalidAdapterClass.class.getName() + \". @JsonAdapter value must be a TypeAdapter, TypeAdapterFactory, JsonSerializer\" + \" or JsonDeserializer.\");\r\n    }\r\n\r\n    @JsonAdapter(Integer.class)\r\n    private static final class WithInvalidAdapterClass {\r\n\r\n        @SuppressWarnings(\"unused\")\r\n        final String value = \"a\";\r\n    }\r\n\r\n    /**\r\n     * Verifies that {@link TypeAdapterFactory} specified by {@code @JsonAdapter} can call {@link\r\n     * Gson#getDelegateAdapter} without any issues, despite the factory not being directly registered\r\n     * on Gson.\r\n     */\r\n    @Test\r\n    public void testDelegatingAdapterFactory() {\r\n        @SuppressWarnings(\"unchecked\")\r\n        WithDelegatingFactory<String> deserialized = new Gson().fromJson(\"{\\\"custom\\\":{\\\"f\\\":\\\"de\\\"}}\", WithDelegatingFactory.class);\r\n        assertThat(deserialized.f).isEqualTo(\"de\");\r\n        deserialized = new Gson().fromJson(\"{\\\"custom\\\":{\\\"f\\\":\\\"de\\\"}}\", new TypeToken<WithDelegatingFactory<String>>() {\r\n        });\r\n        assertThat(deserialized.f).isEqualTo(\"de\");\r\n        WithDelegatingFactory<String> serialized = new WithDelegatingFactory<>(\"se\");\r\n        assertThat(new Gson().toJson(serialized)).isEqualTo(\"{\\\"custom\\\":{\\\"f\\\":\\\"se\\\"}}\");\r\n    }\r\n\r\n    @JsonAdapter(WithDelegatingFactory.Factory.class)\r\n    private static class WithDelegatingFactory<T> {\r\n\r\n        T f;\r\n\r\n        WithDelegatingFactory(T f) {\r\n            this.f = f;\r\n        }\r\n\r\n        static class Factory implements TypeAdapterFactory {\r\n\r\n            @Override\r\n            public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\r\n                if (type.getRawType() != WithDelegatingFactory.class) {\r\n                    return null;\r\n                }\r\n                TypeAdapter<T> delegate = gson.getDelegateAdapter(this, type);\r\n                return new TypeAdapter<>() {\r\n\r\n                    @Override\r\n                    public T read(JsonReader in) throws IOException {\r\n                        // Perform custom deserialization\r\n                        in.beginObject();\r\n                        assertThat(in.nextName()).isEqualTo(\"custom\");\r\n                        T t = delegate.read(in);\r\n                        in.endObject();\r\n                        return t;\r\n                    }\r\n\r\n                    @Override\r\n                    public void write(JsonWriter out, T value) throws IOException {\r\n                        // Perform custom serialization\r\n                        out.beginObject();\r\n                        out.name(\"custom\");\r\n                        delegate.write(out, value);\r\n                        out.endObject();\r\n                    }\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Similar to {@link #testDelegatingAdapterFactory}, except that the delegate is not looked up in\r\n     * {@code create} but instead in the adapter methods.\r\n     */\r\n    @Test\r\n    public void testDelegatingAdapterFactory_Delayed() {\r\n        WithDelayedDelegatingFactory deserialized = new Gson().fromJson(\"{\\\"custom\\\":{\\\"f\\\":\\\"de\\\"}}\", WithDelayedDelegatingFactory.class);\r\n        assertThat(deserialized.f).isEqualTo(\"de\");\r\n        WithDelayedDelegatingFactory serialized = new WithDelayedDelegatingFactory(\"se\");\r\n        assertThat(new Gson().toJson(serialized)).isEqualTo(\"{\\\"custom\\\":{\\\"f\\\":\\\"se\\\"}}\");\r\n    }\r\n\r\n    @JsonAdapter(WithDelayedDelegatingFactory.Factory.class)\r\n    private static class WithDelayedDelegatingFactory {\r\n\r\n        String f;\r\n\r\n        WithDelayedDelegatingFactory(String f) {\r\n            this.f = f;\r\n        }\r\n\r\n        static class Factory implements TypeAdapterFactory {\r\n\r\n            @Override\r\n            public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\r\n                return new TypeAdapter<>() {\r\n\r\n                    // suppress Error Prone warning; should be clear that `Factory` refers to enclosing class\r\n                    @SuppressWarnings(\"SameNameButDifferent\")\r\n                    private TypeAdapter<T> delegate() {\r\n                        return gson.getDelegateAdapter(Factory.this, type);\r\n                    }\r\n\r\n                    @Override\r\n                    public T read(JsonReader in) throws IOException {\r\n                        // Perform custom deserialization\r\n                        in.beginObject();\r\n                        assertThat(in.nextName()).isEqualTo(\"custom\");\r\n                        T t = delegate().read(in);\r\n                        in.endObject();\r\n                        return t;\r\n                    }\r\n\r\n                    @Override\r\n                    public void write(JsonWriter out, T value) throws IOException {\r\n                        // Perform custom serialization\r\n                        out.beginObject();\r\n                        out.name(\"custom\");\r\n                        delegate().write(out, value);\r\n                        out.endObject();\r\n                    }\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Tests behavior of {@link Gson#getDelegateAdapter} when <i>different</i> instances of the same\r\n     * factory class are used; one registered on the {@code GsonBuilder} and the other implicitly\r\n     * through {@code @JsonAdapter}.\r\n     */\r\n    @Test\r\n    public void testDelegating_SameFactoryClass() {\r\n        Gson gson = new GsonBuilder().registerTypeAdapterFactory(new WithDelegatingFactory.Factory()).create();\r\n        // Should use both factories, and therefore have `{\"custom\": ... }` twice\r\n        WithDelegatingFactory<?> deserialized = gson.fromJson(\"{\\\"custom\\\":{\\\"custom\\\":{\\\"f\\\":\\\"de\\\"}}}\", WithDelegatingFactory.class);\r\n        assertThat(deserialized.f).isEqualTo(\"de\");\r\n        WithDelegatingFactory<String> serialized = new WithDelegatingFactory<>(\"se\");\r\n        assertThat(gson.toJson(serialized)).isEqualTo(\"{\\\"custom\\\":{\\\"custom\\\":{\\\"f\\\":\\\"se\\\"}}}\");\r\n    }\r\n\r\n    /**\r\n     * Tests behavior of {@link Gson#getDelegateAdapter} when the <i>same</i> instance of a factory is\r\n     * used (through {@link InstanceCreator}).\r\n     *\r\n     * <p><b>Important:</b> This situation is likely a rare corner case; the purpose of this test is\r\n     * to verify that Gson behaves reasonable, mainly that it does not cause a {@link\r\n     * StackOverflowError} due to infinite recursion. This test is not intended to dictate an expected\r\n     * behavior.\r\n     */\r\n    @Test\r\n    public void testDelegating_SameFactoryInstance() {\r\n        WithDelegatingFactory.Factory factory = new WithDelegatingFactory.Factory();\r\n        Gson gson = new GsonBuilder().registerTypeAdapterFactory(factory).// Always provides same instance for factory\r\n        registerTypeAdapter(WithDelegatingFactory.Factory.class, (InstanceCreator<?>) type -> factory).create();\r\n        // Current Gson.getDelegateAdapter implementation cannot tell when call is related to\r\n        // @JsonAdapter or not, it can only work based on the `skipPast` factory, so if the same factory\r\n        // instance is used the one registered with `GsonBuilder.registerTypeAdapterFactory` actually\r\n        // skips past the @JsonAdapter one, so the JSON string is `{\"custom\": ...}` instead of\r\n        // `{\"custom\":{\"custom\":...}}`\r\n        WithDelegatingFactory<?> deserialized = gson.fromJson(\"{\\\"custom\\\":{\\\"f\\\":\\\"de\\\"}}\", WithDelegatingFactory.class);\r\n        assertThat(deserialized.f).isEqualTo(\"de\");\r\n        WithDelegatingFactory<String> serialized = new WithDelegatingFactory<>(\"se\");\r\n        assertThat(gson.toJson(serialized)).isEqualTo(\"{\\\"custom\\\":{\\\"f\\\":\\\"se\\\"}}\");\r\n    }\r\n\r\n    /**\r\n     * Tests behavior of {@link Gson#getDelegateAdapter} when <i>different</i> instances of the same\r\n     * factory class are used; one specified with {@code @JsonAdapter} on a class, and the other\r\n     * specified with {@code @JsonAdapter} on a field of that class.\r\n     *\r\n     * <p><b>Important:</b> This situation is likely a rare corner case; the purpose of this test is\r\n     * to verify that Gson behaves reasonable, mainly that it does not cause a {@link\r\n     * StackOverflowError} due to infinite recursion. This test is not intended to dictate an expected\r\n     * behavior.\r\n     */\r\n    @Test\r\n    public void testDelegating_SameFactoryClass_OnClassAndField() {\r\n        Gson gson = new GsonBuilder().registerTypeAdapter(String.class, new TypeAdapter<String>() {\r\n\r\n            @Override\r\n            public String read(JsonReader in) throws IOException {\r\n                return in.nextString() + \"-str\";\r\n            }\r\n\r\n            @Override\r\n            public void write(JsonWriter out, String value) throws IOException {\r\n                out.value(value + \"-str\");\r\n            }\r\n        }).create();\r\n        // Should use both factories, and therefore have `{\"custom\": ... }` once for class and once for\r\n        // the field, and for field also properly delegate to custom String adapter defined above\r\n        WithDelegatingFactoryOnClassAndField deserialized = gson.fromJson(\"{\\\"custom\\\":{\\\"f\\\":{\\\"custom\\\":\\\"de\\\"}}}\", WithDelegatingFactoryOnClassAndField.class);\r\n        assertThat(deserialized.f).isEqualTo(\"de-str\");\r\n        WithDelegatingFactoryOnClassAndField serialized = new WithDelegatingFactoryOnClassAndField(\"se\");\r\n        assertThat(gson.toJson(serialized)).isEqualTo(\"{\\\"custom\\\":{\\\"f\\\":{\\\"custom\\\":\\\"se-str\\\"}}}\");\r\n    }\r\n\r\n    /**\r\n     * Tests behavior of {@link Gson#getDelegateAdapter} when the <i>same</i> instance of a factory is\r\n     * used (through {@link InstanceCreator}); specified with {@code @JsonAdapter} on a class, and\r\n     * also specified with {@code @JsonAdapter} on a field of that class.\r\n     *\r\n     * <p><b>Important:</b> This situation is likely a rare corner case; the purpose of this test is\r\n     * to verify that Gson behaves reasonable, mainly that it does not cause a {@link\r\n     * StackOverflowError} due to infinite recursion. This test is not intended to dictate an expected\r\n     * behavior.\r\n     */\r\n    @Test\r\n    public void testDelegating_SameFactoryInstance_OnClassAndField() {\r\n        WithDelegatingFactoryOnClassAndField.Factory factory = new WithDelegatingFactoryOnClassAndField.Factory();\r\n        Gson gson = new GsonBuilder().registerTypeAdapter(String.class, new TypeAdapter<String>() {\r\n\r\n            @Override\r\n            public String read(JsonReader in) throws IOException {\r\n                return in.nextString() + \"-str\";\r\n            }\r\n\r\n            @Override\r\n            public void write(JsonWriter out, String value) throws IOException {\r\n                out.value(value + \"-str\");\r\n            }\r\n        }).// Always provides same instance for factory\r\n        registerTypeAdapter(WithDelegatingFactoryOnClassAndField.Factory.class, (InstanceCreator<?>) type -> factory).create();\r\n        // Because field type (`String`) differs from declaring class,\r\n        // JsonAdapterAnnotationTypeAdapterFactory does not confuse factories and this behaves as\r\n        // expected: Both the declaring class and the field each have `{\"custom\": ...}` and delegation\r\n        // for the field to the custom String adapter defined above works properly\r\n        WithDelegatingFactoryOnClassAndField deserialized = gson.fromJson(\"{\\\"custom\\\":{\\\"f\\\":{\\\"custom\\\":\\\"de\\\"}}}\", WithDelegatingFactoryOnClassAndField.class);\r\n        assertThat(deserialized.f).isEqualTo(\"de-str\");\r\n        WithDelegatingFactoryOnClassAndField serialized = new WithDelegatingFactoryOnClassAndField(\"se\");\r\n        assertThat(gson.toJson(serialized)).isEqualTo(\"{\\\"custom\\\":{\\\"f\\\":{\\\"custom\\\":\\\"se-str\\\"}}}\");\r\n    }\r\n\r\n    // Same factory class specified on class and one of its fields\r\n    @JsonAdapter(WithDelegatingFactoryOnClassAndField.Factory.class)\r\n    private static class WithDelegatingFactoryOnClassAndField {\r\n\r\n        // suppress Error Prone warning; should be clear that `Factory` refers to nested class\r\n        @SuppressWarnings(\"SameNameButDifferent\")\r\n        @JsonAdapter(Factory.class)\r\n        String f;\r\n\r\n        WithDelegatingFactoryOnClassAndField(String f) {\r\n            this.f = f;\r\n        }\r\n\r\n        static class Factory implements TypeAdapterFactory {\r\n\r\n            @Override\r\n            public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\r\n                TypeAdapter<T> delegate = gson.getDelegateAdapter(this, type);\r\n                return new TypeAdapter<>() {\r\n\r\n                    @Override\r\n                    public T read(JsonReader in) throws IOException {\r\n                        // Perform custom deserialization\r\n                        in.beginObject();\r\n                        assertThat(in.nextName()).isEqualTo(\"custom\");\r\n                        T t = delegate.read(in);\r\n                        in.endObject();\r\n                        return t;\r\n                    }\r\n\r\n                    @Override\r\n                    public void write(JsonWriter out, T value) throws IOException {\r\n                        // Perform custom serialization\r\n                        out.beginObject();\r\n                        out.name(\"custom\");\r\n                        delegate.write(out, value);\r\n                        out.endObject();\r\n                    }\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Tests usage of {@link JsonSerializer} as {@link JsonAdapter} value\r\n     */\r\n    @Test\r\n    public void testJsonSerializer() {\r\n        Gson gson = new Gson();\r\n        // Verify that delegate deserializer (reflection deserializer) is used\r\n        WithJsonSerializer deserialized = gson.fromJson(\"{\\\"f\\\":\\\"test\\\"}\", WithJsonSerializer.class);\r\n        assertThat(deserialized.f).isEqualTo(\"test\");\r\n        String json = gson.toJson(new WithJsonSerializer());\r\n        // Uses custom serializer which always returns `true`\r\n        assertThat(json).isEqualTo(\"true\");\r\n    }\r\n\r\n    @JsonAdapter(WithJsonSerializer.Serializer.class)\r\n    private static class WithJsonSerializer {\r\n\r\n        String f = \"\";\r\n\r\n        static class Serializer implements JsonSerializer<WithJsonSerializer> {\r\n\r\n            @Override\r\n            public JsonElement serialize(WithJsonSerializer src, Type typeOfSrc, JsonSerializationContext context) {\r\n                return new JsonPrimitive(true);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Tests usage of {@link JsonDeserializer} as {@link JsonAdapter} value\r\n     */\r\n    @Test\r\n    public void testJsonDeserializer() {\r\n        Gson gson = new Gson();\r\n        WithJsonDeserializer deserialized = gson.fromJson(\"{\\\"f\\\":\\\"test\\\"}\", WithJsonDeserializer.class);\r\n        // Uses custom deserializer which always uses \"123\" as field value\r\n        assertThat(deserialized.f).isEqualTo(\"123\");\r\n        // Verify that delegate serializer (reflection serializer) is used\r\n        String json = gson.toJson(new WithJsonDeserializer(\"abc\"));\r\n        assertThat(json).isEqualTo(\"{\\\"f\\\":\\\"abc\\\"}\");\r\n    }\r\n\r\n    @JsonAdapter(WithJsonDeserializer.Deserializer.class)\r\n    private static class WithJsonDeserializer {\r\n\r\n        String f;\r\n\r\n        WithJsonDeserializer(String f) {\r\n            this.f = f;\r\n        }\r\n\r\n        static class Deserializer implements JsonDeserializer<WithJsonDeserializer> {\r\n\r\n            @Override\r\n            public WithJsonDeserializer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) {\r\n                return new WithJsonDeserializer(\"123\");\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Tests creation of the adapter referenced by {@code @JsonAdapter} using an {@link\r\n     * InstanceCreator}.\r\n     */\r\n    @Test\r\n    public void testAdapterCreatedByInstanceCreator() {\r\n        CreatedByInstanceCreator.Serializer serializer = new CreatedByInstanceCreator.Serializer(\"custom\");\r\n        Gson gson = new GsonBuilder().registerTypeAdapter(CreatedByInstanceCreator.Serializer.class, (InstanceCreator<?>) t -> serializer).create();\r\n        String json = gson.toJson(new CreatedByInstanceCreator());\r\n        assertThat(json).isEqualTo(\"\\\"custom\\\"\");\r\n    }\r\n\r\n    @JsonAdapter(CreatedByInstanceCreator.Serializer.class)\r\n    private static class CreatedByInstanceCreator {\r\n\r\n        static class Serializer implements JsonSerializer<CreatedByInstanceCreator> {\r\n\r\n            private final String value;\r\n\r\n            @SuppressWarnings(\"unused\")\r\n            public Serializer() {\r\n                throw new AssertionError(\"should not be called\");\r\n            }\r\n\r\n            public Serializer(String value) {\r\n                this.value = value;\r\n            }\r\n\r\n            @Override\r\n            public JsonElement serialize(CreatedByInstanceCreator src, Type typeOfSrc, JsonSerializationContext context) {\r\n                return new JsonPrimitive(value);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Tests creation of the adapter referenced by {@code @JsonAdapter} using JDK Unsafe.\r\n     */\r\n    @Test\r\n    public void testAdapterCreatedByJdkUnsafe() {\r\n        String json = new Gson().toJson(new CreatedByJdkUnsafe());\r\n        assertThat(json).isEqualTo(\"false\");\r\n    }\r\n\r\n    @JsonAdapter(CreatedByJdkUnsafe.Serializer.class)\r\n    private static class CreatedByJdkUnsafe {\r\n\r\n        static class Serializer implements JsonSerializer<CreatedByJdkUnsafe> {\r\n\r\n            // JDK Unsafe leaves this at default value `false`\r\n            private boolean wasInitialized = true;\r\n\r\n            // Explicit constructor with args to remove implicit no-args constructor\r\n            @SuppressWarnings(\"unused\")\r\n            public Serializer(int i) {\r\n                throw new AssertionError(\"should not be called\");\r\n            }\r\n\r\n            @Override\r\n            public JsonElement serialize(CreatedByJdkUnsafe src, Type typeOfSrc, JsonSerializationContext context) {\r\n                return new JsonPrimitive(wasInitialized);\r\n            }\r\n        }\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "method",
    "name": "testJsonAdapterInvoked",
    "start_line": 49,
    "end_line": 66,
    "code": "@Test\r\npublic void testJsonAdapterInvoked() {\r\n    Gson gson = new Gson();\r\n    String json = gson.toJson(new A(\"bar\"));\r\n    assertThat(json).isEqualTo(\"\\\"jsonAdapter\\\"\");\r\n    // Also invoke the JsonAdapter javadoc sample\r\n    json = gson.toJson(new User(\"Inderjeet\", \"Singh\"));\r\n    assertThat(json).isEqualTo(\"{\\\"name\\\":\\\"Inderjeet Singh\\\"}\");\r\n    User user = gson.fromJson(\"{'name':'Joel Leitch'}\", User.class);\r\n    assertThat(user.firstName).isEqualTo(\"Joel\");\r\n    assertThat(user.lastName).isEqualTo(\"Leitch\");\r\n    json = gson.toJson(Foo.BAR);\r\n    assertThat(json).isEqualTo(\"\\\"bar\\\"\");\r\n    Foo baz = gson.fromJson(\"\\\"baz\\\"\", Foo.class);\r\n    assertThat(baz).isEqualTo(Foo.BAZ);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "method",
    "name": "testJsonAdapterFactoryInvoked",
    "start_line": 68,
    "end_line": 75,
    "code": "@Test\r\npublic void testJsonAdapterFactoryInvoked() {\r\n    Gson gson = new Gson();\r\n    String json = gson.toJson(new C(\"bar\"));\r\n    assertThat(json).isEqualTo(\"\\\"jsonAdapterFactory\\\"\");\r\n    C c = gson.fromJson(\"\\\"bar\\\"\", C.class);\r\n    assertThat(c.value).isEqualTo(\"jsonAdapterFactory\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "method",
    "name": "testRegisteredAdapterOverridesJsonAdapter",
    "start_line": 77,
    "end_line": 94,
    "code": "@Test\r\npublic void testRegisteredAdapterOverridesJsonAdapter() {\r\n    TypeAdapter<A> typeAdapter = new TypeAdapter<>() {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, A value) throws IOException {\r\n            out.value(\"registeredAdapter\");\r\n        }\r\n\r\n        @Override\r\n        public A read(JsonReader in) throws IOException {\r\n            return new A(in.nextString());\r\n        }\r\n    };\r\n    Gson gson = new GsonBuilder().registerTypeAdapter(A.class, typeAdapter).create();\r\n    String json = gson.toJson(new A(\"abcd\"));\r\n    assertThat(json).isEqualTo(\"\\\"registeredAdapter\\\"\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "method",
    "name": "testRegisteredSerializerOverridesJsonAdapter",
    "start_line": 97,
    "end_line": 106,
    "code": "/**\r\n * The serializer overrides field adapter, but for deserializer the fieldAdapter is used.\r\n */\r\n@Test\r\npublic void testRegisteredSerializerOverridesJsonAdapter() {\r\n    JsonSerializer<A> serializer = (src, typeOfSrc, context) -> new JsonPrimitive(\"registeredSerializer\");\r\n    Gson gson = new GsonBuilder().registerTypeAdapter(A.class, serializer).create();\r\n    String json = gson.toJson(new A(\"abcd\"));\r\n    assertThat(json).isEqualTo(\"\\\"registeredSerializer\\\"\");\r\n    A target = gson.fromJson(\"abcd\", A.class);\r\n    assertThat(target.value).isEqualTo(\"jsonAdapter\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "method",
    "name": "testRegisteredDeserializerOverridesJsonAdapter",
    "start_line": 109,
    "end_line": 117,
    "code": "/**\r\n * The deserializer overrides Json adapter, but for serializer the jsonAdapter is used.\r\n */\r\n@Test\r\npublic void testRegisteredDeserializerOverridesJsonAdapter() {\r\n    JsonDeserializer<A> deserializer = (json, typeOfT, context) -> new A(\"registeredDeserializer\");\r\n    Gson gson = new GsonBuilder().registerTypeAdapter(A.class, deserializer).create();\r\n    String json = gson.toJson(new A(\"abcd\"));\r\n    assertThat(json).isEqualTo(\"\\\"jsonAdapter\\\"\");\r\n    A target = gson.fromJson(\"abcd\", A.class);\r\n    assertThat(target.value).isEqualTo(\"registeredDeserializer\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "method",
    "name": "testIncorrectTypeAdapterFails",
    "start_line": 119,
    "end_line": 124,
    "code": "@Test\r\npublic void testIncorrectTypeAdapterFails() {\r\n    Gson gson = new Gson();\r\n    ClassWithIncorrectJsonAdapter obj = new ClassWithIncorrectJsonAdapter(\"bar\");\r\n    assertThrows(ClassCastException.class, () -> gson.toJson(obj));\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "method",
    "name": "testSuperclassTypeAdapterNotInvoked",
    "start_line": 126,
    "end_line": 130,
    "code": "@Test\r\npublic void testSuperclassTypeAdapterNotInvoked() {\r\n    String json = new Gson().toJson(new B(\"bar\"));\r\n    assertThat(json).doesNotContain(\"jsonAdapter\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "method",
    "name": "testNullSafeObject",
    "start_line": 132,
    "end_line": 146,
    "code": "@Test\r\npublic void testNullSafeObject() {\r\n    Gson gson = new Gson();\r\n    NullableClass fromJson = gson.fromJson(\"null\", NullableClass.class);\r\n    assertThat(fromJson).isNull();\r\n    fromJson = gson.fromJson(\"\\\"ignored\\\"\", NullableClass.class);\r\n    assertThat(fromJson).isNotNull();\r\n    String json = gson.toJson(null, NullableClass.class);\r\n    assertThat(json).isEqualTo(\"null\");\r\n    json = gson.toJson(new NullableClass());\r\n    assertThat(json).isEqualTo(\"\\\"nullable\\\"\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "method",
    "name": "testFactoryReturningNull",
    "start_line": 153,
    "end_line": 175,
    "code": "/**\r\n * Tests behavior when a {@link TypeAdapterFactory} registered with {@code @JsonAdapter} returns\r\n * {@code null}, indicating that it cannot handle the type and Gson should try a different factory\r\n * instead.\r\n */\r\n@Test\r\npublic void testFactoryReturningNull() {\r\n    Gson gson = new Gson();\r\n    assertThat(gson.fromJson(\"null\", WithNullReturningFactory.class)).isNull();\r\n    assertThat(gson.toJson(null, WithNullReturningFactory.class)).isEqualTo(\"null\");\r\n    TypeToken<WithNullReturningFactory<String>> stringTypeArg = new TypeToken<>() {\r\n    };\r\n    WithNullReturningFactory<?> deserialized = gson.fromJson(\"\\\"a\\\"\", stringTypeArg);\r\n    assertThat(deserialized.t).isEqualTo(\"custom-read:a\");\r\n    assertThat(gson.fromJson(\"null\", stringTypeArg)).isNull();\r\n    assertThat(gson.toJson(new WithNullReturningFactory<>(\"b\"), stringTypeArg.getType())).isEqualTo(\"\\\"custom-write:b\\\"\");\r\n    assertThat(gson.toJson(null, stringTypeArg.getType())).isEqualTo(\"null\");\r\n    // Factory should return `null` for this type and Gson should fall back to reflection-based\r\n    // adapter\r\n    TypeToken<WithNullReturningFactory<Integer>> numberTypeArg = new TypeToken<>() {\r\n    };\r\n    deserialized = gson.fromJson(\"{\\\"t\\\":1}\", numberTypeArg);\r\n    assertThat(deserialized.t).isEqualTo(1);\r\n    assertThat(gson.toJson(new WithNullReturningFactory<>(2), numberTypeArg.getType())).isEqualTo(\"{\\\"t\\\":2}\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "method",
    "name": "testIncorrectJsonAdapterType",
    "start_line": 357,
    "end_line": 369,
    "code": "@Test\r\npublic void testIncorrectJsonAdapterType() {\r\n    Gson gson = new Gson();\r\n    WithInvalidAdapterClass obj = new WithInvalidAdapterClass();\r\n    var e = assertThrows(IllegalArgumentException.class, () -> gson.toJson(obj));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Invalid attempt to bind an instance of java.lang.Integer as a @JsonAdapter for \" + WithInvalidAdapterClass.class.getName() + \". @JsonAdapter value must be a TypeAdapter, TypeAdapterFactory, JsonSerializer\" + \" or JsonDeserializer.\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "method",
    "name": "testDelegatingAdapterFactory",
    "start_line": 382,
    "end_line": 397,
    "code": "/**\r\n * Verifies that {@link TypeAdapterFactory} specified by {@code @JsonAdapter} can call {@link\r\n * Gson#getDelegateAdapter} without any issues, despite the factory not being directly registered\r\n * on Gson.\r\n */\r\n@Test\r\npublic void testDelegatingAdapterFactory() {\r\n    @SuppressWarnings(\"unchecked\")\r\n    WithDelegatingFactory<String> deserialized = new Gson().fromJson(\"{\\\"custom\\\":{\\\"f\\\":\\\"de\\\"}}\", WithDelegatingFactory.class);\r\n    assertThat(deserialized.f).isEqualTo(\"de\");\r\n    deserialized = new Gson().fromJson(\"{\\\"custom\\\":{\\\"f\\\":\\\"de\\\"}}\", new TypeToken<WithDelegatingFactory<String>>() {\r\n    });\r\n    assertThat(deserialized.f).isEqualTo(\"de\");\r\n    WithDelegatingFactory<String> serialized = new WithDelegatingFactory<>(\"se\");\r\n    assertThat(new Gson().toJson(serialized)).isEqualTo(\"{\\\"custom\\\":{\\\"f\\\":\\\"se\\\"}}\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "method",
    "name": "testDelegatingAdapterFactory_Delayed",
    "start_line": 445,
    "end_line": 453,
    "code": "/**\r\n * Similar to {@link #testDelegatingAdapterFactory}, except that the delegate is not looked up in\r\n * {@code create} but instead in the adapter methods.\r\n */\r\n@Test\r\npublic void testDelegatingAdapterFactory_Delayed() {\r\n    WithDelayedDelegatingFactory deserialized = new Gson().fromJson(\"{\\\"custom\\\":{\\\"f\\\":\\\"de\\\"}}\", WithDelayedDelegatingFactory.class);\r\n    assertThat(deserialized.f).isEqualTo(\"de\");\r\n    WithDelayedDelegatingFactory serialized = new WithDelayedDelegatingFactory(\"se\");\r\n    assertThat(new Gson().toJson(serialized)).isEqualTo(\"{\\\"custom\\\":{\\\"f\\\":\\\"se\\\"}}\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "method",
    "name": "testDelegating_SameFactoryClass",
    "start_line": 502,
    "end_line": 514,
    "code": "/**\r\n * Tests behavior of {@link Gson#getDelegateAdapter} when <i>different</i> instances of the same\r\n * factory class are used; one registered on the {@code GsonBuilder} and the other implicitly\r\n * through {@code @JsonAdapter}.\r\n */\r\n@Test\r\npublic void testDelegating_SameFactoryClass() {\r\n    Gson gson = new GsonBuilder().registerTypeAdapterFactory(new WithDelegatingFactory.Factory()).create();\r\n    // Should use both factories, and therefore have `{\"custom\": ... }` twice\r\n    WithDelegatingFactory<?> deserialized = gson.fromJson(\"{\\\"custom\\\":{\\\"custom\\\":{\\\"f\\\":\\\"de\\\"}}}\", WithDelegatingFactory.class);\r\n    assertThat(deserialized.f).isEqualTo(\"de\");\r\n    WithDelegatingFactory<String> serialized = new WithDelegatingFactory<>(\"se\");\r\n    assertThat(gson.toJson(serialized)).isEqualTo(\"{\\\"custom\\\":{\\\"custom\\\":{\\\"f\\\":\\\"se\\\"}}}\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "method",
    "name": "testDelegating_SameFactoryInstance",
    "start_line": 525,
    "end_line": 548,
    "code": "/**\r\n * Tests behavior of {@link Gson#getDelegateAdapter} when the <i>same</i> instance of a factory is\r\n * used (through {@link InstanceCreator}).\r\n *\r\n * <p><b>Important:</b> This situation is likely a rare corner case; the purpose of this test is\r\n * to verify that Gson behaves reasonable, mainly that it does not cause a {@link\r\n * StackOverflowError} due to infinite recursion. This test is not intended to dictate an expected\r\n * behavior.\r\n */\r\n@Test\r\npublic void testDelegating_SameFactoryInstance() {\r\n    WithDelegatingFactory.Factory factory = new WithDelegatingFactory.Factory();\r\n    Gson gson = new GsonBuilder().registerTypeAdapterFactory(factory).// Always provides same instance for factory\r\n    registerTypeAdapter(WithDelegatingFactory.Factory.class, (InstanceCreator<?>) type -> factory).create();\r\n    // Current Gson.getDelegateAdapter implementation cannot tell when call is related to\r\n    // @JsonAdapter or not, it can only work based on the `skipPast` factory, so if the same factory\r\n    // instance is used the one registered with `GsonBuilder.registerTypeAdapterFactory` actually\r\n    // skips past the @JsonAdapter one, so the JSON string is `{\"custom\": ...}` instead of\r\n    // `{\"custom\":{\"custom\":...}}`\r\n    WithDelegatingFactory<?> deserialized = gson.fromJson(\"{\\\"custom\\\":{\\\"f\\\":\\\"de\\\"}}\", WithDelegatingFactory.class);\r\n    assertThat(deserialized.f).isEqualTo(\"de\");\r\n    WithDelegatingFactory<String> serialized = new WithDelegatingFactory<>(\"se\");\r\n    assertThat(gson.toJson(serialized)).isEqualTo(\"{\\\"custom\\\":{\\\"f\\\":\\\"se\\\"}}\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "method",
    "name": "testDelegating_SameFactoryClass_OnClassAndField",
    "start_line": 560,
    "end_line": 589,
    "code": "/**\r\n * Tests behavior of {@link Gson#getDelegateAdapter} when <i>different</i> instances of the same\r\n * factory class are used; one specified with {@code @JsonAdapter} on a class, and the other\r\n * specified with {@code @JsonAdapter} on a field of that class.\r\n *\r\n * <p><b>Important:</b> This situation is likely a rare corner case; the purpose of this test is\r\n * to verify that Gson behaves reasonable, mainly that it does not cause a {@link\r\n * StackOverflowError} due to infinite recursion. This test is not intended to dictate an expected\r\n * behavior.\r\n */\r\n@Test\r\npublic void testDelegating_SameFactoryClass_OnClassAndField() {\r\n    Gson gson = new GsonBuilder().registerTypeAdapter(String.class, new TypeAdapter<String>() {\r\n\r\n        @Override\r\n        public String read(JsonReader in) throws IOException {\r\n            return in.nextString() + \"-str\";\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, String value) throws IOException {\r\n            out.value(value + \"-str\");\r\n        }\r\n    }).create();\r\n    // Should use both factories, and therefore have `{\"custom\": ... }` once for class and once for\r\n    // the field, and for field also properly delegate to custom String adapter defined above\r\n    WithDelegatingFactoryOnClassAndField deserialized = gson.fromJson(\"{\\\"custom\\\":{\\\"f\\\":{\\\"custom\\\":\\\"de\\\"}}}\", WithDelegatingFactoryOnClassAndField.class);\r\n    assertThat(deserialized.f).isEqualTo(\"de-str\");\r\n    WithDelegatingFactoryOnClassAndField serialized = new WithDelegatingFactoryOnClassAndField(\"se\");\r\n    assertThat(gson.toJson(serialized)).isEqualTo(\"{\\\"custom\\\":{\\\"f\\\":{\\\"custom\\\":\\\"se-str\\\"}}}\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "method",
    "name": "testDelegating_SameFactoryInstance_OnClassAndField",
    "start_line": 601,
    "end_line": 639,
    "code": "/**\r\n * Tests behavior of {@link Gson#getDelegateAdapter} when the <i>same</i> instance of a factory is\r\n * used (through {@link InstanceCreator}); specified with {@code @JsonAdapter} on a class, and\r\n * also specified with {@code @JsonAdapter} on a field of that class.\r\n *\r\n * <p><b>Important:</b> This situation is likely a rare corner case; the purpose of this test is\r\n * to verify that Gson behaves reasonable, mainly that it does not cause a {@link\r\n * StackOverflowError} due to infinite recursion. This test is not intended to dictate an expected\r\n * behavior.\r\n */\r\n@Test\r\npublic void testDelegating_SameFactoryInstance_OnClassAndField() {\r\n    WithDelegatingFactoryOnClassAndField.Factory factory = new WithDelegatingFactoryOnClassAndField.Factory();\r\n    Gson gson = new GsonBuilder().registerTypeAdapter(String.class, new TypeAdapter<String>() {\r\n\r\n        @Override\r\n        public String read(JsonReader in) throws IOException {\r\n            return in.nextString() + \"-str\";\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, String value) throws IOException {\r\n            out.value(value + \"-str\");\r\n        }\r\n    }).// Always provides same instance for factory\r\n    registerTypeAdapter(WithDelegatingFactoryOnClassAndField.Factory.class, (InstanceCreator<?>) type -> factory).create();\r\n    // Because field type (`String`) differs from declaring class,\r\n    // JsonAdapterAnnotationTypeAdapterFactory does not confuse factories and this behaves as\r\n    // expected: Both the declaring class and the field each have `{\"custom\": ...}` and delegation\r\n    // for the field to the custom String adapter defined above works properly\r\n    WithDelegatingFactoryOnClassAndField deserialized = gson.fromJson(\"{\\\"custom\\\":{\\\"f\\\":{\\\"custom\\\":\\\"de\\\"}}}\", WithDelegatingFactoryOnClassAndField.class);\r\n    assertThat(deserialized.f).isEqualTo(\"de-str\");\r\n    WithDelegatingFactoryOnClassAndField serialized = new WithDelegatingFactoryOnClassAndField(\"se\");\r\n    assertThat(gson.toJson(serialized)).isEqualTo(\"{\\\"custom\\\":{\\\"f\\\":{\\\"custom\\\":\\\"se-str\\\"}}}\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "method",
    "name": "testJsonSerializer",
    "start_line": 684,
    "end_line": 694,
    "code": "/**\r\n * Tests usage of {@link JsonSerializer} as {@link JsonAdapter} value\r\n */\r\n@Test\r\npublic void testJsonSerializer() {\r\n    Gson gson = new Gson();\r\n    // Verify that delegate deserializer (reflection deserializer) is used\r\n    WithJsonSerializer deserialized = gson.fromJson(\"{\\\"f\\\":\\\"test\\\"}\", WithJsonSerializer.class);\r\n    assertThat(deserialized.f).isEqualTo(\"test\");\r\n    String json = gson.toJson(new WithJsonSerializer());\r\n    // Uses custom serializer which always returns `true`\r\n    assertThat(json).isEqualTo(\"true\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "method",
    "name": "testJsonDeserializer",
    "start_line": 710,
    "end_line": 721,
    "code": "/**\r\n * Tests usage of {@link JsonDeserializer} as {@link JsonAdapter} value\r\n */\r\n@Test\r\npublic void testJsonDeserializer() {\r\n    Gson gson = new Gson();\r\n    WithJsonDeserializer deserialized = gson.fromJson(\"{\\\"f\\\":\\\"test\\\"}\", WithJsonDeserializer.class);\r\n    // Uses custom deserializer which always uses \"123\" as field value\r\n    assertThat(deserialized.f).isEqualTo(\"123\");\r\n    // Verify that delegate serializer (reflection serializer) is used\r\n    String json = gson.toJson(new WithJsonDeserializer(\"abc\"));\r\n    assertThat(json).isEqualTo(\"{\\\"f\\\":\\\"abc\\\"}\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "method",
    "name": "testAdapterCreatedByInstanceCreator",
    "start_line": 744,
    "end_line": 756,
    "code": "/**\r\n * Tests creation of the adapter referenced by {@code @JsonAdapter} using an {@link\r\n * InstanceCreator}.\r\n */\r\n@Test\r\npublic void testAdapterCreatedByInstanceCreator() {\r\n    CreatedByInstanceCreator.Serializer serializer = new CreatedByInstanceCreator.Serializer(\"custom\");\r\n    Gson gson = new GsonBuilder().registerTypeAdapter(CreatedByInstanceCreator.Serializer.class, (InstanceCreator<?>) t -> serializer).create();\r\n    String json = gson.toJson(new CreatedByInstanceCreator());\r\n    assertThat(json).isEqualTo(\"\\\"custom\\\"\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  },
  {
    "type": "method",
    "name": "testAdapterCreatedByJdkUnsafe",
    "start_line": 781,
    "end_line": 785,
    "code": "/**\r\n * Tests creation of the adapter referenced by {@code @JsonAdapter} using JDK Unsafe.\r\n */\r\n@Test\r\npublic void testAdapterCreatedByJdkUnsafe() {\r\n    String json = new Gson().toJson(new CreatedByJdkUnsafe());\r\n    assertThat(json).isEqualTo(\"false\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\functional\\JsonAdapterAnnotationOnClassesTest.java"
  }
]