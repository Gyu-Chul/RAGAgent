[
  {
    "type": "package",
    "name": "com.google.gson.reflect",
    "start_line": 17,
    "end_line": 17,
    "code": "package com.google.gson.reflect;\r\n\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\reflect\\TypeTokenTest.java"
  },
  {
    "type": "import",
    "name": "com.google.common.truth.Truth.assertThat",
    "start_line": 19,
    "end_line": 19,
    "code": "import static com.google.common.truth.Truth.assertThat;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\reflect\\TypeTokenTest.java"
  },
  {
    "type": "import",
    "name": "org.junit.Assert.assertThrows",
    "start_line": 20,
    "end_line": 20,
    "code": "import static org.junit.Assert.assertThrows;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\reflect\\TypeTokenTest.java"
  },
  {
    "type": "import",
    "name": "java.lang.reflect.GenericArrayType",
    "start_line": 22,
    "end_line": 22,
    "code": "import java.lang.reflect.GenericArrayType;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\reflect\\TypeTokenTest.java"
  },
  {
    "type": "import",
    "name": "java.lang.reflect.Method",
    "start_line": 23,
    "end_line": 23,
    "code": "import java.lang.reflect.Method;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\reflect\\TypeTokenTest.java"
  },
  {
    "type": "import",
    "name": "java.lang.reflect.ParameterizedType",
    "start_line": 24,
    "end_line": 24,
    "code": "import java.lang.reflect.ParameterizedType;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\reflect\\TypeTokenTest.java"
  },
  {
    "type": "import",
    "name": "java.lang.reflect.Type",
    "start_line": 25,
    "end_line": 25,
    "code": "import java.lang.reflect.Type;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\reflect\\TypeTokenTest.java"
  },
  {
    "type": "import",
    "name": "java.lang.reflect.TypeVariable",
    "start_line": 26,
    "end_line": 26,
    "code": "import java.lang.reflect.TypeVariable;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\reflect\\TypeTokenTest.java"
  },
  {
    "type": "import",
    "name": "java.lang.reflect.WildcardType",
    "start_line": 27,
    "end_line": 27,
    "code": "import java.lang.reflect.WildcardType;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\reflect\\TypeTokenTest.java"
  },
  {
    "type": "import",
    "name": "java.util.ArrayList",
    "start_line": 28,
    "end_line": 28,
    "code": "import java.util.ArrayList;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\reflect\\TypeTokenTest.java"
  },
  {
    "type": "import",
    "name": "java.util.List",
    "start_line": 29,
    "end_line": 29,
    "code": "import java.util.List;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\reflect\\TypeTokenTest.java"
  },
  {
    "type": "import",
    "name": "java.util.Map",
    "start_line": 30,
    "end_line": 30,
    "code": "import java.util.Map;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\reflect\\TypeTokenTest.java"
  },
  {
    "type": "import",
    "name": "java.util.RandomAccess",
    "start_line": 31,
    "end_line": 31,
    "code": "import java.util.RandomAccess;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\reflect\\TypeTokenTest.java"
  },
  {
    "type": "import",
    "name": "java.util.Set",
    "start_line": 32,
    "end_line": 32,
    "code": "import java.util.Set;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\reflect\\TypeTokenTest.java"
  },
  {
    "type": "import",
    "name": "org.junit.Test",
    "start_line": 33,
    "end_line": 33,
    "code": "import org.junit.Test;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\reflect\\TypeTokenTest.java"
  },
  {
    "type": "class",
    "name": "TypeTokenTest",
    "start_line": 42,
    "end_line": 462,
    "code": "/**\r\n * Tests for {@link TypeToken}.\r\n *\r\n * @author Jesse Wilson\r\n */\r\n// Suppress because these classes are only needed for this test, but must be top-level classes\r\n// to not have an enclosing type\r\n@SuppressWarnings(\"MultipleTopLevelClasses\")\r\npublic final class TypeTokenTest {\r\n\r\n    // These fields are accessed using reflection by the tests below\r\n    List<Integer> listOfInteger = null;\r\n\r\n    List<Number> listOfNumber = null;\r\n\r\n    List<String> listOfString = null;\r\n\r\n    List<?> listOfUnknown = null;\r\n\r\n    List<Set<String>> listOfSetOfString = null;\r\n\r\n    List<Set<?>> listOfSetOfUnknown = null;\r\n\r\n    @SuppressWarnings({ \"deprecation\" })\r\n    @Test\r\n    public void testIsAssignableFromRawTypes() {\r\n        assertThat(TypeToken.get(Object.class).isAssignableFrom(String.class)).isTrue();\r\n        assertThat(TypeToken.get(String.class).isAssignableFrom(Object.class)).isFalse();\r\n        assertThat(TypeToken.get(RandomAccess.class).isAssignableFrom(ArrayList.class)).isTrue();\r\n        assertThat(TypeToken.get(ArrayList.class).isAssignableFrom(RandomAccess.class)).isFalse();\r\n    }\r\n\r\n    @SuppressWarnings({ \"deprecation\" })\r\n    @Test\r\n    public void testIsAssignableFromWithTypeParameters() throws Exception {\r\n        Type a = getClass().getDeclaredField(\"listOfInteger\").getGenericType();\r\n        Type b = getClass().getDeclaredField(\"listOfNumber\").getGenericType();\r\n        assertThat(TypeToken.get(a).isAssignableFrom(a)).isTrue();\r\n        assertThat(TypeToken.get(b).isAssignableFrom(b)).isTrue();\r\n        // listOfInteger = listOfNumber; // doesn't compile; must be false\r\n        assertThat(TypeToken.get(a).isAssignableFrom(b)).isFalse();\r\n        // listOfNumber = listOfInteger; // doesn't compile; must be false\r\n        assertThat(TypeToken.get(b).isAssignableFrom(a)).isFalse();\r\n    }\r\n\r\n    @SuppressWarnings({ \"deprecation\" })\r\n    @Test\r\n    public void testIsAssignableFromWithBasicWildcards() throws Exception {\r\n        Type a = getClass().getDeclaredField(\"listOfString\").getGenericType();\r\n        Type b = getClass().getDeclaredField(\"listOfUnknown\").getGenericType();\r\n        assertThat(TypeToken.get(a).isAssignableFrom(a)).isTrue();\r\n        assertThat(TypeToken.get(b).isAssignableFrom(b)).isTrue();\r\n        // listOfString = listOfUnknown  // doesn't compile; must be false\r\n        assertThat(TypeToken.get(a).isAssignableFrom(b)).isFalse();\r\n        // compiles; must be true\r\n        listOfUnknown = listOfString;\r\n        // The following assertion is too difficult to support reliably, so disabling\r\n        // assertThat(TypeToken.get(b).isAssignableFrom(a)).isTrue();\r\n        WildcardType wildcardType = (WildcardType) ((ParameterizedType) b).getActualTypeArguments()[0];\r\n        TypeToken<?> wildcardTypeToken = TypeToken.get(wildcardType);\r\n        IllegalArgumentException e = assertThrows(IllegalArgumentException.class, () -> wildcardTypeToken.isAssignableFrom(b));\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Unsupported type, expected one of: java.lang.Class,\" + \" java.lang.reflect.ParameterizedType, java.lang.reflect.GenericArrayType, but\" + \" got: com.google.gson.internal.GsonTypes$WildcardTypeImpl, for type token: \" + wildcardTypeToken);\r\n    }\r\n\r\n    @SuppressWarnings({ \"deprecation\" })\r\n    @Test\r\n    public void testIsAssignableFromWithNestedWildcards() throws Exception {\r\n        Type a = getClass().getDeclaredField(\"listOfSetOfString\").getGenericType();\r\n        Type b = getClass().getDeclaredField(\"listOfSetOfUnknown\").getGenericType();\r\n        assertThat(TypeToken.get(a).isAssignableFrom(a)).isTrue();\r\n        assertThat(TypeToken.get(b).isAssignableFrom(b)).isTrue();\r\n        // listOfSetOfString = listOfSetOfUnknown; // doesn't compile; must be false\r\n        assertThat(TypeToken.get(a).isAssignableFrom(b)).isFalse();\r\n        // listOfSetOfUnknown = listOfSetOfString; // doesn't compile; must be false\r\n        assertThat(TypeToken.get(b).isAssignableFrom(a)).isFalse();\r\n    }\r\n\r\n    @Test\r\n    public void testArrayFactory() {\r\n        TypeToken<?> expectedStringArray = new TypeToken<String[]>() {\r\n        };\r\n        assertThat(TypeToken.getArray(String.class)).isEqualTo(expectedStringArray);\r\n        TypeToken<?> expectedListOfStringArray = new TypeToken<List<String>[]>() {\r\n        };\r\n        Type listOfString = new TypeToken<List<String>>() {\r\n        }.getType();\r\n        assertThat(TypeToken.getArray(listOfString)).isEqualTo(expectedListOfStringArray);\r\n        TypeToken<?> expectedIntArray = new TypeToken<int[]>() {\r\n        };\r\n        assertThat(TypeToken.getArray(int.class)).isEqualTo(expectedIntArray);\r\n        assertThrows(NullPointerException.class, () -> TypeToken.getArray(null));\r\n    }\r\n\r\n    static class NestedGeneric<T> {\r\n    }\r\n\r\n    @Test\r\n    public void testParameterizedFactory() {\r\n        TypeToken<?> expectedListOfString = new TypeToken<List<String>>() {\r\n        };\r\n        assertThat(TypeToken.getParameterized(List.class, String.class)).isEqualTo(expectedListOfString);\r\n        TypeToken<?> expectedMapOfStringToString = new TypeToken<Map<String, String>>() {\r\n        };\r\n        assertThat(TypeToken.getParameterized(Map.class, String.class, String.class)).isEqualTo(expectedMapOfStringToString);\r\n        TypeToken<?> expectedListOfListOfListOfString = new TypeToken<List<List<List<String>>>>() {\r\n        };\r\n        Type listOfString = TypeToken.getParameterized(List.class, String.class).getType();\r\n        Type listOfListOfString = TypeToken.getParameterized(List.class, listOfString).getType();\r\n        assertThat(TypeToken.getParameterized(List.class, listOfListOfString)).isEqualTo(expectedListOfListOfListOfString);\r\n        TypeToken<?> expectedWithExactArg = new TypeToken<GenericWithBound<Number>>() {\r\n        };\r\n        assertThat(TypeToken.getParameterized(GenericWithBound.class, Number.class)).isEqualTo(expectedWithExactArg);\r\n        TypeToken<?> expectedWithSubclassArg = new TypeToken<GenericWithBound<Integer>>() {\r\n        };\r\n        assertThat(TypeToken.getParameterized(GenericWithBound.class, Integer.class)).isEqualTo(expectedWithSubclassArg);\r\n        TypeToken<?> expectedSatisfyingTwoBounds = new TypeToken<GenericWithMultiBound<ClassSatisfyingBounds>>() {\r\n        };\r\n        assertThat(TypeToken.getParameterized(GenericWithMultiBound.class, ClassSatisfyingBounds.class)).isEqualTo(expectedSatisfyingTwoBounds);\r\n        TypeToken<?> nestedTypeToken = TypeToken.getParameterized(NestedGeneric.class, Integer.class);\r\n        ParameterizedType nestedParameterizedType = (ParameterizedType) nestedTypeToken.getType();\r\n        // TODO: This seems to differ from how Java reflection behaves; when using\r\n        // TypeToken<NestedGeneric<Integer>>, then NestedGeneric<Integer> does have an owner type\r\n        assertThat(nestedParameterizedType.getOwnerType()).isNull();\r\n        assertThat(nestedParameterizedType.getRawType()).isEqualTo(NestedGeneric.class);\r\n        assertThat(nestedParameterizedType.getActualTypeArguments()).asList().containsExactly(Integer.class);\r\n        class LocalGenericClass<T> {\r\n        }\r\n        TypeToken<?> expectedLocalType = new TypeToken<LocalGenericClass<Integer>>() {\r\n        };\r\n        assertThat(TypeToken.getParameterized(LocalGenericClass.class, Integer.class)).isEqualTo(expectedLocalType);\r\n        // For legacy reasons, if requesting parameterized type for non-generic class, create a\r\n        // `TypeToken(Class)`\r\n        assertThat(TypeToken.getParameterized(String.class)).isEqualTo(TypeToken.get(String.class));\r\n    }\r\n\r\n    @Test\r\n    public void testParameterizedFactory_Invalid() {\r\n        assertThrows(NullPointerException.class, () -> TypeToken.getParameterized(null, new Type[0]));\r\n        assertThrows(NullPointerException.class, () -> TypeToken.getParameterized(List.class, new Type[] { null }));\r\n        GenericArrayType arrayType = (GenericArrayType) TypeToken.getArray(String.class).getType();\r\n        IllegalArgumentException e = assertThrows(IllegalArgumentException.class, () -> TypeToken.getParameterized(arrayType, new Type[0]));\r\n        assertThat(e).hasMessageThat().isEqualTo(\"rawType must be of type Class, but was java.lang.String[]\");\r\n        e = assertThrows(IllegalArgumentException.class, () -> TypeToken.getParameterized(String.class, Number.class));\r\n        assertThat(e).hasMessageThat().isEqualTo(\"java.lang.String requires 0 type arguments, but got 1\");\r\n        e = assertThrows(IllegalArgumentException.class, () -> TypeToken.getParameterized(List.class, new Type[0]));\r\n        assertThat(e).hasMessageThat().isEqualTo(\"java.util.List requires 1 type arguments, but got 0\");\r\n        e = assertThrows(IllegalArgumentException.class, () -> TypeToken.getParameterized(List.class, String.class, String.class));\r\n        assertThat(e).hasMessageThat().isEqualTo(\"java.util.List requires 1 type arguments, but got 2\");\r\n        // Primitive types must not be used as type argument\r\n        e = assertThrows(IllegalArgumentException.class, () -> TypeToken.getParameterized(List.class, int.class));\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Type argument int does not satisfy bounds for type variable E declared by \" + List.class);\r\n        e = assertThrows(IllegalArgumentException.class, () -> TypeToken.getParameterized(GenericWithBound.class, String.class));\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Type argument class java.lang.String does not satisfy bounds\" + \" for type variable T declared by \" + GenericWithBound.class);\r\n        e = assertThrows(IllegalArgumentException.class, () -> TypeToken.getParameterized(GenericWithBound.class, Object.class));\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Type argument class java.lang.Object does not satisfy bounds\" + \" for type variable T declared by \" + GenericWithBound.class);\r\n        e = assertThrows(IllegalArgumentException.class, () -> TypeToken.getParameterized(GenericWithMultiBound.class, Number.class));\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Type argument class java.lang.Number does not satisfy bounds\" + \" for type variable T declared by \" + GenericWithMultiBound.class);\r\n        e = assertThrows(IllegalArgumentException.class, () -> TypeToken.getParameterized(GenericWithMultiBound.class, CharSequence.class));\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Type argument interface java.lang.CharSequence does not satisfy bounds\" + \" for type variable T declared by \" + GenericWithMultiBound.class);\r\n        e = assertThrows(IllegalArgumentException.class, () -> TypeToken.getParameterized(GenericWithMultiBound.class, Object.class));\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Type argument class java.lang.Object does not satisfy bounds\" + \" for type variable T declared by \" + GenericWithMultiBound.class);\r\n        class Outer {\r\n\r\n            @SuppressWarnings(\"ClassCanBeStatic\")\r\n            class NonStaticInner<T> {\r\n            }\r\n        }\r\n        e = assertThrows(IllegalArgumentException.class, () -> TypeToken.getParameterized(Outer.NonStaticInner.class, Object.class));\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Raw type \" + Outer.NonStaticInner.class.getName() + \" is not supported because it requires specifying an owner type\");\r\n    }\r\n\r\n    private static class CustomTypeToken extends TypeToken<String> {\r\n    }\r\n\r\n    @Test\r\n    public void testTypeTokenNonAnonymousSubclass() {\r\n        TypeToken<?> typeToken = new CustomTypeToken();\r\n        assertThat(typeToken.getRawType()).isEqualTo(String.class);\r\n        assertThat(typeToken.getType()).isEqualTo(String.class);\r\n    }\r\n\r\n    /**\r\n     * User must only create direct subclasses of TypeToken, but not subclasses of subclasses (...) of\r\n     * TypeToken.\r\n     */\r\n    @Test\r\n    public void testTypeTokenSubSubClass() {\r\n        class SubTypeToken<T> extends TypeToken<String> {\r\n        }\r\n        class SubSubTypeToken1<T> extends SubTypeToken<T> {\r\n        }\r\n        class SubSubTypeToken2 extends SubTypeToken<Integer> {\r\n        }\r\n        IllegalStateException e = assertThrows(IllegalStateException.class, () -> new SubTypeToken<Integer>() {\r\n        });\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Must only create direct subclasses of TypeToken\");\r\n        e = assertThrows(IllegalStateException.class, () -> new SubSubTypeToken1<Integer>());\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Must only create direct subclasses of TypeToken\");\r\n        e = assertThrows(IllegalStateException.class, () -> new SubSubTypeToken2());\r\n        assertThat(e).hasMessageThat().isEqualTo(\"Must only create direct subclasses of TypeToken\");\r\n    }\r\n\r\n    private static <M> void createTypeTokenTypeVariable() {\r\n        var unused = new TypeToken<M>() {\r\n        };\r\n    }\r\n\r\n    /**\r\n     * TypeToken type argument must not contain a type variable because, due to type erasure, at\r\n     * runtime only the bound of the type variable is available which is likely not what the user\r\n     * wanted.\r\n     *\r\n     * <p>Note that type variables are allowed for the {@code TypeToken} factory methods calling\r\n     * {@code TypeToken(Type)} because for them the return type is {@code TypeToken<?>} which does not\r\n     * give a false sense of type-safety.\r\n     */\r\n    @Test\r\n    public void testTypeTokenTypeVariable() throws Exception {\r\n        // Put the test code inside generic class to be able to access `T`\r\n        class Enclosing<T> {\r\n\r\n            @SuppressWarnings(\"ClassCanBeStatic\")\r\n            class Inner {\r\n            }\r\n\r\n            void test() {\r\n                String expectedMessage = \"TypeToken type argument must not contain a type variable;\" + \" captured type variable T declared by \" + Enclosing.class + \"\\n\" + \"See https://github.com/google/gson/blob/main/Troubleshooting.md#typetoken-type-variable\";\r\n                IllegalArgumentException e = assertThrows(IllegalArgumentException.class, () -> new TypeToken<T>() {\r\n                });\r\n                assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n                e = assertThrows(IllegalArgumentException.class, () -> new TypeToken<List<List<T>>>() {\r\n                });\r\n                assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n                e = assertThrows(IllegalArgumentException.class, () -> new TypeToken<List<? extends List<T>>>() {\r\n                });\r\n                assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n                e = assertThrows(IllegalArgumentException.class, () -> new TypeToken<List<? super List<T>>>() {\r\n                });\r\n                assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n                e = assertThrows(IllegalArgumentException.class, () -> new TypeToken<List<T>[]>() {\r\n                });\r\n                assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n                e = assertThrows(IllegalArgumentException.class, () -> new TypeToken<Enclosing<T>.Inner>() {\r\n                });\r\n                assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n                String systemProperty = \"gson.allowCapturingTypeVariables\";\r\n                try {\r\n                    // Any value other than 'true' should be ignored\r\n                    System.setProperty(systemProperty, \"some-value\");\r\n                    e = assertThrows(IllegalArgumentException.class, () -> new TypeToken<T>() {\r\n                    });\r\n                    assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n                } finally {\r\n                    System.clearProperty(systemProperty);\r\n                }\r\n                try {\r\n                    System.setProperty(systemProperty, \"true\");\r\n                    TypeToken<?> typeToken = new TypeToken<T>() {\r\n                    };\r\n                    assertThat(typeToken.getType()).isEqualTo(Enclosing.class.getTypeParameters()[0]);\r\n                } finally {\r\n                    System.clearProperty(systemProperty);\r\n                }\r\n            }\r\n\r\n            <M> void testMethodTypeVariable() throws Exception {\r\n                Method testMethod = Enclosing.class.getDeclaredMethod(\"testMethodTypeVariable\");\r\n                IllegalArgumentException e = assertThrows(IllegalArgumentException.class, () -> new TypeToken<M>() {\r\n                });\r\n                assertThat(e).hasMessageThat().isAnyOf(\"TypeToken type argument must not contain a type variable;\" + \" captured type variable M declared by \" + testMethod + \"\\n\" + \"See https://github.com/google/gson/blob/main/Troubleshooting.md#typetoken-type-variable\", // Note: When running this test in Eclipse IDE or with certain Java versions it\r\n                // seems to capture `null` instead of the type variable, see\r\n                // https://github.com/eclipse-jdt/eclipse.jdt.core/issues/975\r\n                \"TypeToken captured `null` as type argument; probably a compiler / runtime bug\");\r\n            }\r\n        }\r\n        new Enclosing<>().test();\r\n        new Enclosing<>().testMethodTypeVariable();\r\n        Method testMethod = TypeTokenTest.class.getDeclaredMethod(\"createTypeTokenTypeVariable\");\r\n        IllegalArgumentException e = assertThrows(IllegalArgumentException.class, () -> createTypeTokenTypeVariable());\r\n        assertThat(e).hasMessageThat().isEqualTo(\"TypeToken type argument must not contain a type variable;\" + \" captured type variable M declared by \" + testMethod + \"\\n\" + \"See https://github.com/google/gson/blob/main/Troubleshooting.md#typetoken-type-variable\");\r\n        // Using type variable as argument for factory methods should be allowed; this is not a\r\n        // type-safety problem because the user would have to perform unsafe casts\r\n        TypeVariable<?> typeVar = Enclosing.class.getTypeParameters()[0];\r\n        TypeToken<?> typeToken = TypeToken.get(typeVar);\r\n        assertThat(typeToken.getType()).isEqualTo(typeVar);\r\n        TypeToken<?> parameterizedTypeToken = TypeToken.getParameterized(List.class, typeVar);\r\n        ParameterizedType parameterizedType = (ParameterizedType) parameterizedTypeToken.getType();\r\n        assertThat(parameterizedType.getRawType()).isEqualTo(List.class);\r\n        assertThat(parameterizedType.getActualTypeArguments()).asList().containsExactly(typeVar);\r\n    }\r\n\r\n    @SuppressWarnings(\"rawtypes\")\r\n    @Test\r\n    public void testTypeTokenRaw() {\r\n        IllegalStateException e = assertThrows(IllegalStateException.class, () -> new TypeToken() {\r\n        });\r\n        assertThat(e).hasMessageThat().isEqualTo(\"TypeToken must be created with a type argument: new TypeToken<...>() {}; When using\" + \" code shrinkers (ProGuard, R8, ...) make sure that generic signatures are\" + \" preserved.\\n\" + \"See https://github.com/google/gson/blob/main/Troubleshooting.md#type-token-raw\");\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\reflect\\TypeTokenTest.java"
  },
  {
    "type": "field",
    "name": "listOfInteger",
    "start_line": 45,
    "end_line": 45,
    "code": "// These fields are accessed using reflection by the tests below\r\nList<Integer> listOfInteger = null;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\reflect\\TypeTokenTest.java"
  },
  {
    "type": "field",
    "name": "listOfNumber",
    "start_line": 46,
    "end_line": 46,
    "code": "List<Number> listOfNumber = null;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\reflect\\TypeTokenTest.java"
  },
  {
    "type": "field",
    "name": "listOfString",
    "start_line": 47,
    "end_line": 47,
    "code": "List<String> listOfString = null;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\reflect\\TypeTokenTest.java"
  },
  {
    "type": "field",
    "name": "listOfUnknown",
    "start_line": 48,
    "end_line": 48,
    "code": "List<?> listOfUnknown = null;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\reflect\\TypeTokenTest.java"
  },
  {
    "type": "field",
    "name": "listOfSetOfString",
    "start_line": 49,
    "end_line": 49,
    "code": "List<Set<String>> listOfSetOfString = null;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\reflect\\TypeTokenTest.java"
  },
  {
    "type": "field",
    "name": "listOfSetOfUnknown",
    "start_line": 50,
    "end_line": 50,
    "code": "List<Set<?>> listOfSetOfUnknown = null;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\reflect\\TypeTokenTest.java"
  },
  {
    "type": "method",
    "name": "testIsAssignableFromRawTypes",
    "start_line": 52,
    "end_line": 59,
    "code": "@SuppressWarnings({ \"deprecation\" })\r\n@Test\r\npublic void testIsAssignableFromRawTypes() {\r\n    assertThat(TypeToken.get(Object.class).isAssignableFrom(String.class)).isTrue();\r\n    assertThat(TypeToken.get(String.class).isAssignableFrom(Object.class)).isFalse();\r\n    assertThat(TypeToken.get(RandomAccess.class).isAssignableFrom(ArrayList.class)).isTrue();\r\n    assertThat(TypeToken.get(ArrayList.class).isAssignableFrom(RandomAccess.class)).isFalse();\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\reflect\\TypeTokenTest.java"
  },
  {
    "type": "method",
    "name": "testIsAssignableFromWithTypeParameters",
    "start_line": 61,
    "end_line": 73,
    "code": "@SuppressWarnings({ \"deprecation\" })\r\n@Test\r\npublic void testIsAssignableFromWithTypeParameters() throws Exception {\r\n    Type a = getClass().getDeclaredField(\"listOfInteger\").getGenericType();\r\n    Type b = getClass().getDeclaredField(\"listOfNumber\").getGenericType();\r\n    assertThat(TypeToken.get(a).isAssignableFrom(a)).isTrue();\r\n    assertThat(TypeToken.get(b).isAssignableFrom(b)).isTrue();\r\n    // listOfInteger = listOfNumber; // doesn't compile; must be false\r\n    assertThat(TypeToken.get(a).isAssignableFrom(b)).isFalse();\r\n    // listOfNumber = listOfInteger; // doesn't compile; must be false\r\n    assertThat(TypeToken.get(b).isAssignableFrom(a)).isFalse();\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\reflect\\TypeTokenTest.java"
  },
  {
    "type": "method",
    "name": "testIsAssignableFromWithBasicWildcards",
    "start_line": 75,
    "end_line": 100,
    "code": "@SuppressWarnings({ \"deprecation\" })\r\n@Test\r\npublic void testIsAssignableFromWithBasicWildcards() throws Exception {\r\n    Type a = getClass().getDeclaredField(\"listOfString\").getGenericType();\r\n    Type b = getClass().getDeclaredField(\"listOfUnknown\").getGenericType();\r\n    assertThat(TypeToken.get(a).isAssignableFrom(a)).isTrue();\r\n    assertThat(TypeToken.get(b).isAssignableFrom(b)).isTrue();\r\n    // listOfString = listOfUnknown  // doesn't compile; must be false\r\n    assertThat(TypeToken.get(a).isAssignableFrom(b)).isFalse();\r\n    // compiles; must be true\r\n    listOfUnknown = listOfString;\r\n    // The following assertion is too difficult to support reliably, so disabling\r\n    // assertThat(TypeToken.get(b).isAssignableFrom(a)).isTrue();\r\n    WildcardType wildcardType = (WildcardType) ((ParameterizedType) b).getActualTypeArguments()[0];\r\n    TypeToken<?> wildcardTypeToken = TypeToken.get(wildcardType);\r\n    IllegalArgumentException e = assertThrows(IllegalArgumentException.class, () -> wildcardTypeToken.isAssignableFrom(b));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Unsupported type, expected one of: java.lang.Class,\" + \" java.lang.reflect.ParameterizedType, java.lang.reflect.GenericArrayType, but\" + \" got: com.google.gson.internal.GsonTypes$WildcardTypeImpl, for type token: \" + wildcardTypeToken);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\reflect\\TypeTokenTest.java"
  },
  {
    "type": "method",
    "name": "testIsAssignableFromWithNestedWildcards",
    "start_line": 102,
    "end_line": 114,
    "code": "@SuppressWarnings({ \"deprecation\" })\r\n@Test\r\npublic void testIsAssignableFromWithNestedWildcards() throws Exception {\r\n    Type a = getClass().getDeclaredField(\"listOfSetOfString\").getGenericType();\r\n    Type b = getClass().getDeclaredField(\"listOfSetOfUnknown\").getGenericType();\r\n    assertThat(TypeToken.get(a).isAssignableFrom(a)).isTrue();\r\n    assertThat(TypeToken.get(b).isAssignableFrom(b)).isTrue();\r\n    // listOfSetOfString = listOfSetOfUnknown; // doesn't compile; must be false\r\n    assertThat(TypeToken.get(a).isAssignableFrom(b)).isFalse();\r\n    // listOfSetOfUnknown = listOfSetOfString; // doesn't compile; must be false\r\n    assertThat(TypeToken.get(b).isAssignableFrom(a)).isFalse();\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\reflect\\TypeTokenTest.java"
  },
  {
    "type": "method",
    "name": "testArrayFactory",
    "start_line": 116,
    "end_line": 129,
    "code": "@Test\r\npublic void testArrayFactory() {\r\n    TypeToken<?> expectedStringArray = new TypeToken<String[]>() {\r\n    };\r\n    assertThat(TypeToken.getArray(String.class)).isEqualTo(expectedStringArray);\r\n    TypeToken<?> expectedListOfStringArray = new TypeToken<List<String>[]>() {\r\n    };\r\n    Type listOfString = new TypeToken<List<String>>() {\r\n    }.getType();\r\n    assertThat(TypeToken.getArray(listOfString)).isEqualTo(expectedListOfStringArray);\r\n    TypeToken<?> expectedIntArray = new TypeToken<int[]>() {\r\n    };\r\n    assertThat(TypeToken.getArray(int.class)).isEqualTo(expectedIntArray);\r\n    assertThrows(NullPointerException.class, () -> TypeToken.getArray(null));\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\reflect\\TypeTokenTest.java"
  },
  {
    "type": "method",
    "name": "testParameterizedFactory",
    "start_line": 133,
    "end_line": 180,
    "code": "@Test\r\npublic void testParameterizedFactory() {\r\n    TypeToken<?> expectedListOfString = new TypeToken<List<String>>() {\r\n    };\r\n    assertThat(TypeToken.getParameterized(List.class, String.class)).isEqualTo(expectedListOfString);\r\n    TypeToken<?> expectedMapOfStringToString = new TypeToken<Map<String, String>>() {\r\n    };\r\n    assertThat(TypeToken.getParameterized(Map.class, String.class, String.class)).isEqualTo(expectedMapOfStringToString);\r\n    TypeToken<?> expectedListOfListOfListOfString = new TypeToken<List<List<List<String>>>>() {\r\n    };\r\n    Type listOfString = TypeToken.getParameterized(List.class, String.class).getType();\r\n    Type listOfListOfString = TypeToken.getParameterized(List.class, listOfString).getType();\r\n    assertThat(TypeToken.getParameterized(List.class, listOfListOfString)).isEqualTo(expectedListOfListOfListOfString);\r\n    TypeToken<?> expectedWithExactArg = new TypeToken<GenericWithBound<Number>>() {\r\n    };\r\n    assertThat(TypeToken.getParameterized(GenericWithBound.class, Number.class)).isEqualTo(expectedWithExactArg);\r\n    TypeToken<?> expectedWithSubclassArg = new TypeToken<GenericWithBound<Integer>>() {\r\n    };\r\n    assertThat(TypeToken.getParameterized(GenericWithBound.class, Integer.class)).isEqualTo(expectedWithSubclassArg);\r\n    TypeToken<?> expectedSatisfyingTwoBounds = new TypeToken<GenericWithMultiBound<ClassSatisfyingBounds>>() {\r\n    };\r\n    assertThat(TypeToken.getParameterized(GenericWithMultiBound.class, ClassSatisfyingBounds.class)).isEqualTo(expectedSatisfyingTwoBounds);\r\n    TypeToken<?> nestedTypeToken = TypeToken.getParameterized(NestedGeneric.class, Integer.class);\r\n    ParameterizedType nestedParameterizedType = (ParameterizedType) nestedTypeToken.getType();\r\n    // TODO: This seems to differ from how Java reflection behaves; when using\r\n    // TypeToken<NestedGeneric<Integer>>, then NestedGeneric<Integer> does have an owner type\r\n    assertThat(nestedParameterizedType.getOwnerType()).isNull();\r\n    assertThat(nestedParameterizedType.getRawType()).isEqualTo(NestedGeneric.class);\r\n    assertThat(nestedParameterizedType.getActualTypeArguments()).asList().containsExactly(Integer.class);\r\n    class LocalGenericClass<T> {\r\n    }\r\n    TypeToken<?> expectedLocalType = new TypeToken<LocalGenericClass<Integer>>() {\r\n    };\r\n    assertThat(TypeToken.getParameterized(LocalGenericClass.class, Integer.class)).isEqualTo(expectedLocalType);\r\n    // For legacy reasons, if requesting parameterized type for non-generic class, create a\r\n    // `TypeToken(Class)`\r\n    assertThat(TypeToken.getParameterized(String.class)).isEqualTo(TypeToken.get(String.class));\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\reflect\\TypeTokenTest.java"
  },
  {
    "type": "method",
    "name": "testParameterizedFactory_Invalid",
    "start_line": 182,
    "end_line": 299,
    "code": "@Test\r\npublic void testParameterizedFactory_Invalid() {\r\n    assertThrows(NullPointerException.class, () -> TypeToken.getParameterized(null, new Type[0]));\r\n    assertThrows(NullPointerException.class, () -> TypeToken.getParameterized(List.class, new Type[] { null }));\r\n    GenericArrayType arrayType = (GenericArrayType) TypeToken.getArray(String.class).getType();\r\n    IllegalArgumentException e = assertThrows(IllegalArgumentException.class, () -> TypeToken.getParameterized(arrayType, new Type[0]));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"rawType must be of type Class, but was java.lang.String[]\");\r\n    e = assertThrows(IllegalArgumentException.class, () -> TypeToken.getParameterized(String.class, Number.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"java.lang.String requires 0 type arguments, but got 1\");\r\n    e = assertThrows(IllegalArgumentException.class, () -> TypeToken.getParameterized(List.class, new Type[0]));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"java.util.List requires 1 type arguments, but got 0\");\r\n    e = assertThrows(IllegalArgumentException.class, () -> TypeToken.getParameterized(List.class, String.class, String.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"java.util.List requires 1 type arguments, but got 2\");\r\n    // Primitive types must not be used as type argument\r\n    e = assertThrows(IllegalArgumentException.class, () -> TypeToken.getParameterized(List.class, int.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Type argument int does not satisfy bounds for type variable E declared by \" + List.class);\r\n    e = assertThrows(IllegalArgumentException.class, () -> TypeToken.getParameterized(GenericWithBound.class, String.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Type argument class java.lang.String does not satisfy bounds\" + \" for type variable T declared by \" + GenericWithBound.class);\r\n    e = assertThrows(IllegalArgumentException.class, () -> TypeToken.getParameterized(GenericWithBound.class, Object.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Type argument class java.lang.Object does not satisfy bounds\" + \" for type variable T declared by \" + GenericWithBound.class);\r\n    e = assertThrows(IllegalArgumentException.class, () -> TypeToken.getParameterized(GenericWithMultiBound.class, Number.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Type argument class java.lang.Number does not satisfy bounds\" + \" for type variable T declared by \" + GenericWithMultiBound.class);\r\n    e = assertThrows(IllegalArgumentException.class, () -> TypeToken.getParameterized(GenericWithMultiBound.class, CharSequence.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Type argument interface java.lang.CharSequence does not satisfy bounds\" + \" for type variable T declared by \" + GenericWithMultiBound.class);\r\n    e = assertThrows(IllegalArgumentException.class, () -> TypeToken.getParameterized(GenericWithMultiBound.class, Object.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Type argument class java.lang.Object does not satisfy bounds\" + \" for type variable T declared by \" + GenericWithMultiBound.class);\r\n    class Outer {\r\n\r\n        @SuppressWarnings(\"ClassCanBeStatic\")\r\n        class NonStaticInner<T> {\r\n        }\r\n    }\r\n    e = assertThrows(IllegalArgumentException.class, () -> TypeToken.getParameterized(Outer.NonStaticInner.class, Object.class));\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Raw type \" + Outer.NonStaticInner.class.getName() + \" is not supported because it requires specifying an owner type\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\reflect\\TypeTokenTest.java"
  },
  {
    "type": "method",
    "name": "testTypeTokenNonAnonymousSubclass",
    "start_line": 303,
    "end_line": 308,
    "code": "@Test\r\npublic void testTypeTokenNonAnonymousSubclass() {\r\n    TypeToken<?> typeToken = new CustomTypeToken();\r\n    assertThat(typeToken.getRawType()).isEqualTo(String.class);\r\n    assertThat(typeToken.getType()).isEqualTo(String.class);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\reflect\\TypeTokenTest.java"
  },
  {
    "type": "method",
    "name": "testTypeTokenSubSubClass",
    "start_line": 314,
    "end_line": 329,
    "code": "/**\r\n * User must only create direct subclasses of TypeToken, but not subclasses of subclasses (...) of\r\n * TypeToken.\r\n */\r\n@Test\r\npublic void testTypeTokenSubSubClass() {\r\n    class SubTypeToken<T> extends TypeToken<String> {\r\n    }\r\n    class SubSubTypeToken1<T> extends SubTypeToken<T> {\r\n    }\r\n    class SubSubTypeToken2 extends SubTypeToken<Integer> {\r\n    }\r\n    IllegalStateException e = assertThrows(IllegalStateException.class, () -> new SubTypeToken<Integer>() {\r\n    });\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Must only create direct subclasses of TypeToken\");\r\n    e = assertThrows(IllegalStateException.class, () -> new SubSubTypeToken1<Integer>());\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Must only create direct subclasses of TypeToken\");\r\n    e = assertThrows(IllegalStateException.class, () -> new SubSubTypeToken2());\r\n    assertThat(e).hasMessageThat().isEqualTo(\"Must only create direct subclasses of TypeToken\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\reflect\\TypeTokenTest.java"
  },
  {
    "type": "method",
    "name": "createTypeTokenTypeVariable",
    "start_line": 331,
    "end_line": 333,
    "code": "private static <M> void createTypeTokenTypeVariable() {\r\n    var unused = new TypeToken<M>() {\r\n    };\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\reflect\\TypeTokenTest.java"
  },
  {
    "type": "method",
    "name": "testTypeTokenTypeVariable",
    "start_line": 344,
    "end_line": 448,
    "code": "/**\r\n * TypeToken type argument must not contain a type variable because, due to type erasure, at\r\n * runtime only the bound of the type variable is available which is likely not what the user\r\n * wanted.\r\n *\r\n * <p>Note that type variables are allowed for the {@code TypeToken} factory methods calling\r\n * {@code TypeToken(Type)} because for them the return type is {@code TypeToken<?>} which does not\r\n * give a false sense of type-safety.\r\n */\r\n@Test\r\npublic void testTypeTokenTypeVariable() throws Exception {\r\n    // Put the test code inside generic class to be able to access `T`\r\n    class Enclosing<T> {\r\n\r\n        @SuppressWarnings(\"ClassCanBeStatic\")\r\n        class Inner {\r\n        }\r\n\r\n        void test() {\r\n            String expectedMessage = \"TypeToken type argument must not contain a type variable;\" + \" captured type variable T declared by \" + Enclosing.class + \"\\n\" + \"See https://github.com/google/gson/blob/main/Troubleshooting.md#typetoken-type-variable\";\r\n            IllegalArgumentException e = assertThrows(IllegalArgumentException.class, () -> new TypeToken<T>() {\r\n            });\r\n            assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n            e = assertThrows(IllegalArgumentException.class, () -> new TypeToken<List<List<T>>>() {\r\n            });\r\n            assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n            e = assertThrows(IllegalArgumentException.class, () -> new TypeToken<List<? extends List<T>>>() {\r\n            });\r\n            assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n            e = assertThrows(IllegalArgumentException.class, () -> new TypeToken<List<? super List<T>>>() {\r\n            });\r\n            assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n            e = assertThrows(IllegalArgumentException.class, () -> new TypeToken<List<T>[]>() {\r\n            });\r\n            assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n            e = assertThrows(IllegalArgumentException.class, () -> new TypeToken<Enclosing<T>.Inner>() {\r\n            });\r\n            assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n            String systemProperty = \"gson.allowCapturingTypeVariables\";\r\n            try {\r\n                // Any value other than 'true' should be ignored\r\n                System.setProperty(systemProperty, \"some-value\");\r\n                e = assertThrows(IllegalArgumentException.class, () -> new TypeToken<T>() {\r\n                });\r\n                assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\r\n            } finally {\r\n                System.clearProperty(systemProperty);\r\n            }\r\n            try {\r\n                System.setProperty(systemProperty, \"true\");\r\n                TypeToken<?> typeToken = new TypeToken<T>() {\r\n                };\r\n                assertThat(typeToken.getType()).isEqualTo(Enclosing.class.getTypeParameters()[0]);\r\n            } finally {\r\n                System.clearProperty(systemProperty);\r\n            }\r\n        }\r\n\r\n        <M> void testMethodTypeVariable() throws Exception {\r\n            Method testMethod = Enclosing.class.getDeclaredMethod(\"testMethodTypeVariable\");\r\n            IllegalArgumentException e = assertThrows(IllegalArgumentException.class, () -> new TypeToken<M>() {\r\n            });\r\n            assertThat(e).hasMessageThat().isAnyOf(\"TypeToken type argument must not contain a type variable;\" + \" captured type variable M declared by \" + testMethod + \"\\n\" + \"See https://github.com/google/gson/blob/main/Troubleshooting.md#typetoken-type-variable\", // Note: When running this test in Eclipse IDE or with certain Java versions it\r\n            // seems to capture `null` instead of the type variable, see\r\n            // https://github.com/eclipse-jdt/eclipse.jdt.core/issues/975\r\n            \"TypeToken captured `null` as type argument; probably a compiler / runtime bug\");\r\n        }\r\n    }\r\n    new Enclosing<>().test();\r\n    new Enclosing<>().testMethodTypeVariable();\r\n    Method testMethod = TypeTokenTest.class.getDeclaredMethod(\"createTypeTokenTypeVariable\");\r\n    IllegalArgumentException e = assertThrows(IllegalArgumentException.class, () -> createTypeTokenTypeVariable());\r\n    assertThat(e).hasMessageThat().isEqualTo(\"TypeToken type argument must not contain a type variable;\" + \" captured type variable M declared by \" + testMethod + \"\\n\" + \"See https://github.com/google/gson/blob/main/Troubleshooting.md#typetoken-type-variable\");\r\n    // Using type variable as argument for factory methods should be allowed; this is not a\r\n    // type-safety problem because the user would have to perform unsafe casts\r\n    TypeVariable<?> typeVar = Enclosing.class.getTypeParameters()[0];\r\n    TypeToken<?> typeToken = TypeToken.get(typeVar);\r\n    assertThat(typeToken.getType()).isEqualTo(typeVar);\r\n    TypeToken<?> parameterizedTypeToken = TypeToken.getParameterized(List.class, typeVar);\r\n    ParameterizedType parameterizedType = (ParameterizedType) parameterizedTypeToken.getType();\r\n    assertThat(parameterizedType.getRawType()).isEqualTo(List.class);\r\n    assertThat(parameterizedType.getActualTypeArguments()).asList().containsExactly(typeVar);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\reflect\\TypeTokenTest.java"
  },
  {
    "type": "method",
    "name": "testTypeTokenRaw",
    "start_line": 450,
    "end_line": 461,
    "code": "@SuppressWarnings(\"rawtypes\")\r\n@Test\r\npublic void testTypeTokenRaw() {\r\n    IllegalStateException e = assertThrows(IllegalStateException.class, () -> new TypeToken() {\r\n    });\r\n    assertThat(e).hasMessageThat().isEqualTo(\"TypeToken must be created with a type argument: new TypeToken<...>() {}; When using\" + \" code shrinkers (ProGuard, R8, ...) make sure that generic signatures are\" + \" preserved.\\n\" + \"See https://github.com/google/gson/blob/main/Troubleshooting.md#type-token-raw\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\reflect\\TypeTokenTest.java"
  },
  {
    "type": "class",
    "name": "GenericWithBound",
    "start_line": 466,
    "end_line": 466,
    "code": "// Have to declare these classes here as top-level classes because otherwise tests for\r\n// TypeToken.getParameterized fail due to owner type mismatch\r\nclass GenericWithBound<T extends Number> {\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\reflect\\TypeTokenTest.java"
  },
  {
    "type": "class",
    "name": "GenericWithMultiBound",
    "start_line": 468,
    "end_line": 468,
    "code": "class GenericWithMultiBound<T extends Number & CharSequence> {\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\reflect\\TypeTokenTest.java"
  },
  {
    "type": "class",
    "name": "ClassSatisfyingBounds",
    "start_line": 470,
    "end_line": 471,
    "code": "@SuppressWarnings(\"serial\")\r\nabstract class ClassSatisfyingBounds extends Number implements CharSequence {\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\test\\java\\com\\google\\gson\\reflect\\TypeTokenTest.java"
  }
]