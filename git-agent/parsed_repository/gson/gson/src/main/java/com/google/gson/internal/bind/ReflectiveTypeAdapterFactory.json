[
  {
    "type": "package",
    "name": "com.google.gson.internal.bind",
    "start_line": 17,
    "end_line": 17,
    "code": "package com.google.gson.internal.bind;\r\n\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.FieldNamingStrategy",
    "start_line": 19,
    "end_line": 19,
    "code": "import com.google.gson.FieldNamingStrategy;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.Gson",
    "start_line": 20,
    "end_line": 20,
    "code": "import com.google.gson.Gson;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.JsonIOException",
    "start_line": 21,
    "end_line": 21,
    "code": "import com.google.gson.JsonIOException;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.JsonParseException",
    "start_line": 22,
    "end_line": 22,
    "code": "import com.google.gson.JsonParseException;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.JsonSyntaxException",
    "start_line": 23,
    "end_line": 23,
    "code": "import com.google.gson.JsonSyntaxException;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.ReflectionAccessFilter",
    "start_line": 24,
    "end_line": 24,
    "code": "import com.google.gson.ReflectionAccessFilter;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.ReflectionAccessFilter.FilterResult",
    "start_line": 25,
    "end_line": 25,
    "code": "import com.google.gson.ReflectionAccessFilter.FilterResult;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.TypeAdapter",
    "start_line": 26,
    "end_line": 26,
    "code": "import com.google.gson.TypeAdapter;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.TypeAdapterFactory",
    "start_line": 27,
    "end_line": 27,
    "code": "import com.google.gson.TypeAdapterFactory;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.annotations.JsonAdapter",
    "start_line": 28,
    "end_line": 28,
    "code": "import com.google.gson.annotations.JsonAdapter;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.annotations.SerializedName",
    "start_line": 29,
    "end_line": 29,
    "code": "import com.google.gson.annotations.SerializedName;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.internal.ConstructorConstructor",
    "start_line": 30,
    "end_line": 30,
    "code": "import com.google.gson.internal.ConstructorConstructor;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.internal.Excluder",
    "start_line": 31,
    "end_line": 31,
    "code": "import com.google.gson.internal.Excluder;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.internal.GsonTypes",
    "start_line": 32,
    "end_line": 32,
    "code": "import com.google.gson.internal.GsonTypes;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.internal.ObjectConstructor",
    "start_line": 33,
    "end_line": 33,
    "code": "import com.google.gson.internal.ObjectConstructor;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.internal.Primitives",
    "start_line": 34,
    "end_line": 34,
    "code": "import com.google.gson.internal.Primitives;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.internal.ReflectionAccessFilterHelper",
    "start_line": 35,
    "end_line": 35,
    "code": "import com.google.gson.internal.ReflectionAccessFilterHelper;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.internal.TroubleshootingGuide",
    "start_line": 36,
    "end_line": 36,
    "code": "import com.google.gson.internal.TroubleshootingGuide;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.internal.reflect.ReflectionHelper",
    "start_line": 37,
    "end_line": 37,
    "code": "import com.google.gson.internal.reflect.ReflectionHelper;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.reflect.TypeToken",
    "start_line": 38,
    "end_line": 38,
    "code": "import com.google.gson.reflect.TypeToken;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.stream.JsonReader",
    "start_line": 39,
    "end_line": 39,
    "code": "import com.google.gson.stream.JsonReader;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.stream.JsonToken",
    "start_line": 40,
    "end_line": 40,
    "code": "import com.google.gson.stream.JsonToken;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.stream.JsonWriter",
    "start_line": 41,
    "end_line": 41,
    "code": "import com.google.gson.stream.JsonWriter;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "java.io.IOException",
    "start_line": 42,
    "end_line": 42,
    "code": "import java.io.IOException;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "java.lang.reflect.AccessibleObject",
    "start_line": 43,
    "end_line": 43,
    "code": "import java.lang.reflect.AccessibleObject;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "java.lang.reflect.Constructor",
    "start_line": 44,
    "end_line": 44,
    "code": "import java.lang.reflect.Constructor;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "java.lang.reflect.Field",
    "start_line": 45,
    "end_line": 45,
    "code": "import java.lang.reflect.Field;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "java.lang.reflect.InvocationTargetException",
    "start_line": 46,
    "end_line": 46,
    "code": "import java.lang.reflect.InvocationTargetException;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "java.lang.reflect.Member",
    "start_line": 47,
    "end_line": 47,
    "code": "import java.lang.reflect.Member;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "java.lang.reflect.Method",
    "start_line": 48,
    "end_line": 48,
    "code": "import java.lang.reflect.Method;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "java.lang.reflect.Modifier",
    "start_line": 49,
    "end_line": 49,
    "code": "import java.lang.reflect.Modifier;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "java.lang.reflect.Type",
    "start_line": 50,
    "end_line": 50,
    "code": "import java.lang.reflect.Type;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "java.util.ArrayList",
    "start_line": 51,
    "end_line": 51,
    "code": "import java.util.ArrayList;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "java.util.Arrays",
    "start_line": 52,
    "end_line": 52,
    "code": "import java.util.Arrays;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "java.util.Collections",
    "start_line": 53,
    "end_line": 53,
    "code": "import java.util.Collections;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "java.util.HashMap",
    "start_line": 54,
    "end_line": 54,
    "code": "import java.util.HashMap;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "java.util.LinkedHashMap",
    "start_line": 55,
    "end_line": 55,
    "code": "import java.util.LinkedHashMap;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "java.util.List",
    "start_line": 56,
    "end_line": 56,
    "code": "import java.util.List;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "java.util.Map",
    "start_line": 57,
    "end_line": 57,
    "code": "import java.util.Map;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "class",
    "name": "ReflectiveTypeAdapterFactory",
    "start_line": 60,
    "end_line": 672,
    "code": "/**\r\n * Type adapter that reflects over the fields and methods of a class.\r\n */\r\npublic final class ReflectiveTypeAdapterFactory implements TypeAdapterFactory {\r\n\r\n    private final ConstructorConstructor constructorConstructor;\r\n\r\n    private final FieldNamingStrategy fieldNamingPolicy;\r\n\r\n    private final Excluder excluder;\r\n\r\n    private final JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory;\r\n\r\n    private final List<ReflectionAccessFilter> reflectionFilters;\r\n\r\n    public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor, FieldNamingStrategy fieldNamingPolicy, Excluder excluder, JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory, List<ReflectionAccessFilter> reflectionFilters) {\r\n        this.constructorConstructor = constructorConstructor;\r\n        this.fieldNamingPolicy = fieldNamingPolicy;\r\n        this.excluder = excluder;\r\n        this.jsonAdapterFactory = jsonAdapterFactory;\r\n        this.reflectionFilters = reflectionFilters;\r\n    }\r\n\r\n    private boolean includeField(Field f, boolean serialize) {\r\n        return !excluder.excludeField(f, serialize);\r\n    }\r\n\r\n    /**\r\n     * first element holds the default name\r\n     */\r\n    @SuppressWarnings(\"MixedMutabilityReturnType\")\r\n    private List<String> getFieldNames(Field f) {\r\n        String fieldName;\r\n        List<String> alternates;\r\n        SerializedName annotation = f.getAnnotation(SerializedName.class);\r\n        if (annotation == null) {\r\n            fieldName = fieldNamingPolicy.translateName(f);\r\n            alternates = fieldNamingPolicy.alternateNames(f);\r\n        } else {\r\n            fieldName = annotation.value();\r\n            alternates = Arrays.asList(annotation.alternate());\r\n        }\r\n        if (alternates.isEmpty()) {\r\n            return Collections.singletonList(fieldName);\r\n        }\r\n        List<String> fieldNames = new ArrayList<>(alternates.size() + 1);\r\n        fieldNames.add(fieldName);\r\n        fieldNames.addAll(alternates);\r\n        return fieldNames;\r\n    }\r\n\r\n    @Override\r\n    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\r\n        Class<? super T> raw = type.getRawType();\r\n        if (!Object.class.isAssignableFrom(raw)) {\r\n            // it's a primitive!\r\n            return null;\r\n        }\r\n        // Don't allow using reflection on anonymous and local classes because synthetic fields for\r\n        // captured enclosing values make this unreliable\r\n        if (ReflectionHelper.isAnonymousOrNonStaticLocal(raw)) {\r\n            // This adapter just serializes and deserializes null, ignoring the actual values\r\n            // This is done for backward compatibility; troubleshooting-wise it might be better to throw\r\n            // exceptions\r\n            return new TypeAdapter<T>() {\r\n\r\n                @Override\r\n                public T read(JsonReader in) throws IOException {\r\n                    in.skipValue();\r\n                    return null;\r\n                }\r\n\r\n                @Override\r\n                public void write(JsonWriter out, T value) throws IOException {\r\n                    out.nullValue();\r\n                }\r\n\r\n                @Override\r\n                public String toString() {\r\n                    return \"AnonymousOrNonStaticLocalClassAdapter\";\r\n                }\r\n            };\r\n        }\r\n        FilterResult filterResult = ReflectionAccessFilterHelper.getFilterResult(reflectionFilters, raw);\r\n        if (filterResult == FilterResult.BLOCK_ALL) {\r\n            throw new JsonIOException(\"ReflectionAccessFilter does not permit using reflection for \" + raw + \". Register a TypeAdapter for this type or adjust the access filter.\");\r\n        }\r\n        boolean blockInaccessible = filterResult == FilterResult.BLOCK_INACCESSIBLE;\r\n        // If the type is actually a Java Record, we need to use the RecordAdapter instead. This will\r\n        // always be false on JVMs that do not support records.\r\n        if (ReflectionHelper.isRecord(raw)) {\r\n            @SuppressWarnings(\"unchecked\")\r\n            TypeAdapter<T> adapter = (TypeAdapter<T>) new RecordAdapter<>(raw, getBoundFields(gson, type, raw, blockInaccessible, true), blockInaccessible);\r\n            return adapter;\r\n        }\r\n        ObjectConstructor<T> constructor = constructorConstructor.get(type, true);\r\n        return new FieldReflectionAdapter<>(constructor, getBoundFields(gson, type, raw, blockInaccessible, false));\r\n    }\r\n\r\n    private static <M extends AccessibleObject & Member> void checkAccessible(Object object, M member) {\r\n        if (!ReflectionAccessFilterHelper.canAccess(member, Modifier.isStatic(member.getModifiers()) ? null : object)) {\r\n            String memberDescription = ReflectionHelper.getAccessibleObjectDescription(member, true);\r\n            throw new JsonIOException(memberDescription + \" is not accessible and ReflectionAccessFilter does not permit making it\" + \" accessible. Register a TypeAdapter for the declaring type, adjust the access\" + \" filter or increase the visibility of the element and its declaring type.\");\r\n        }\r\n    }\r\n\r\n    private BoundField createBoundField(Gson context, Field field, Method accessor, String serializedName, TypeToken<?> fieldType, boolean serialize, boolean blockInaccessible) {\r\n        boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\r\n        int modifiers = field.getModifiers();\r\n        boolean isStaticFinalField = Modifier.isStatic(modifiers) && Modifier.isFinal(modifiers);\r\n        JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\r\n        TypeAdapter<?> mapped = null;\r\n        if (annotation != null) {\r\n            // This is not safe; requires that user has specified correct adapter class for @JsonAdapter\r\n            mapped = jsonAdapterFactory.getTypeAdapter(constructorConstructor, context, fieldType, annotation, false);\r\n        }\r\n        boolean jsonAdapterPresent = mapped != null;\r\n        if (mapped == null) {\r\n            mapped = context.getAdapter(fieldType);\r\n        }\r\n        @SuppressWarnings(\"unchecked\")\r\n        TypeAdapter<Object> typeAdapter = (TypeAdapter<Object>) mapped;\r\n        TypeAdapter<Object> writeTypeAdapter;\r\n        if (serialize) {\r\n            writeTypeAdapter = jsonAdapterPresent ? typeAdapter : new TypeAdapterRuntimeTypeWrapper<>(context, typeAdapter, fieldType.getType());\r\n        } else {\r\n            // Will never actually be used, but we set it to avoid confusing nullness-analysis tools\r\n            writeTypeAdapter = typeAdapter;\r\n        }\r\n        return new BoundField(serializedName, field) {\r\n\r\n            @Override\r\n            void write(JsonWriter writer, Object source) throws IOException, IllegalAccessException {\r\n                if (blockInaccessible) {\r\n                    if (accessor == null) {\r\n                        checkAccessible(source, field);\r\n                    } else {\r\n                        // Note: This check might actually be redundant because access check for canonical\r\n                        // constructor should have failed already\r\n                        checkAccessible(source, accessor);\r\n                    }\r\n                }\r\n                Object fieldValue;\r\n                if (accessor != null) {\r\n                    try {\r\n                        fieldValue = accessor.invoke(source);\r\n                    } catch (InvocationTargetException e) {\r\n                        String accessorDescription = ReflectionHelper.getAccessibleObjectDescription(accessor, false);\r\n                        throw new JsonIOException(\"Accessor \" + accessorDescription + \" threw exception\", e.getCause());\r\n                    }\r\n                } else {\r\n                    fieldValue = field.get(source);\r\n                }\r\n                if (fieldValue == source) {\r\n                    // avoid direct recursion\r\n                    return;\r\n                }\r\n                writer.name(serializedName);\r\n                writeTypeAdapter.write(writer, fieldValue);\r\n            }\r\n\r\n            @Override\r\n            void readIntoArray(JsonReader reader, int index, Object[] target) throws IOException, JsonParseException {\r\n                Object fieldValue = typeAdapter.read(reader);\r\n                if (fieldValue == null && isPrimitive) {\r\n                    throw new JsonParseException(\"null is not allowed as value for record component '\" + fieldName + \"' of primitive type; at path \" + reader.getPath());\r\n                }\r\n                target[index] = fieldValue;\r\n            }\r\n\r\n            @Override\r\n            void readIntoField(JsonReader reader, Object target) throws IOException, IllegalAccessException {\r\n                Object fieldValue = typeAdapter.read(reader);\r\n                if (fieldValue != null || !isPrimitive) {\r\n                    if (blockInaccessible) {\r\n                        checkAccessible(target, field);\r\n                    } else if (isStaticFinalField) {\r\n                        // Reflection does not permit setting value of `static final` field, even after calling\r\n                        // `setAccessible`\r\n                        // Handle this here to avoid causing IllegalAccessException when calling `Field.set`\r\n                        String fieldDescription = ReflectionHelper.getAccessibleObjectDescription(field, false);\r\n                        throw new JsonIOException(\"Cannot set value of 'static final' \" + fieldDescription);\r\n                    }\r\n                    field.set(target, fieldValue);\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    private static class FieldsData {\r\n\r\n        public static final FieldsData EMPTY = new FieldsData(Collections.emptyMap(), Collections.emptyList());\r\n\r\n        /**\r\n         * Maps from JSON member name to field\r\n         */\r\n        public final Map<String, BoundField> deserializedFields;\r\n\r\n        public final List<BoundField> serializedFields;\r\n\r\n        public FieldsData(Map<String, BoundField> deserializedFields, List<BoundField> serializedFields) {\r\n            this.deserializedFields = deserializedFields;\r\n            this.serializedFields = serializedFields;\r\n        }\r\n    }\r\n\r\n    private static IllegalArgumentException createDuplicateFieldException(Class<?> declaringType, String duplicateName, Field field1, Field field2) {\r\n        throw new IllegalArgumentException(\"Class \" + declaringType.getName() + \" declares multiple JSON fields named '\" + duplicateName + \"'; conflict is caused by fields \" + ReflectionHelper.fieldToString(field1) + \" and \" + ReflectionHelper.fieldToString(field2) + \"\\nSee \" + TroubleshootingGuide.createUrl(\"duplicate-fields\"));\r\n    }\r\n\r\n    private FieldsData getBoundFields(Gson context, TypeToken<?> type, Class<?> raw, boolean blockInaccessible, boolean isRecord) {\r\n        if (raw.isInterface()) {\r\n            return FieldsData.EMPTY;\r\n        }\r\n        Map<String, BoundField> deserializedFields = new LinkedHashMap<>();\r\n        // For serialized fields use a Map to track duplicate field names; otherwise this could be a\r\n        // List<BoundField> instead\r\n        Map<String, BoundField> serializedFields = new LinkedHashMap<>();\r\n        Class<?> originalRaw = raw;\r\n        while (raw != Object.class) {\r\n            Field[] fields = raw.getDeclaredFields();\r\n            // For inherited fields, check if access to their declaring class is allowed\r\n            if (raw != originalRaw && fields.length > 0) {\r\n                FilterResult filterResult = ReflectionAccessFilterHelper.getFilterResult(reflectionFilters, raw);\r\n                if (filterResult == FilterResult.BLOCK_ALL) {\r\n                    throw new JsonIOException(\"ReflectionAccessFilter does not permit using reflection for \" + raw + \" (supertype of \" + originalRaw + \"). Register a TypeAdapter for this type or adjust the access filter.\");\r\n                }\r\n                blockInaccessible = filterResult == FilterResult.BLOCK_INACCESSIBLE;\r\n            }\r\n            for (Field field : fields) {\r\n                boolean serialize = includeField(field, true);\r\n                boolean deserialize = includeField(field, false);\r\n                if (!serialize && !deserialize) {\r\n                    continue;\r\n                }\r\n                // The accessor method is only used for records. If the type is a record, we will read out\r\n                // values via its accessor method instead of via reflection. This way we will bypass the\r\n                // accessible restrictions\r\n                Method accessor = null;\r\n                if (isRecord) {\r\n                    // If there is a static field on a record, there will not be an accessor. Instead we will\r\n                    // use the default field serialization logic, but for deserialization the field is\r\n                    // excluded for simplicity.\r\n                    // Note that Gson ignores static fields by default, but\r\n                    // GsonBuilder.excludeFieldsWithModifiers can overwrite this.\r\n                    if (Modifier.isStatic(field.getModifiers())) {\r\n                        deserialize = false;\r\n                    } else {\r\n                        accessor = ReflectionHelper.getAccessor(raw, field);\r\n                        // If blockInaccessible, skip and perform access check later\r\n                        if (!blockInaccessible) {\r\n                            ReflectionHelper.makeAccessible(accessor);\r\n                        }\r\n                        // @SerializedName can be placed on accessor method, but it is not supported there\r\n                        // If field and method have annotation it is not easily possible to determine if\r\n                        // accessor method is implicit and has inherited annotation, or if it is explicitly\r\n                        // declared with custom annotation\r\n                        if (accessor.getAnnotation(SerializedName.class) != null && field.getAnnotation(SerializedName.class) == null) {\r\n                            String methodDescription = ReflectionHelper.getAccessibleObjectDescription(accessor, false);\r\n                            throw new JsonIOException(\"@SerializedName on \" + methodDescription + \" is not supported\");\r\n                        }\r\n                    }\r\n                }\r\n                // If blockInaccessible, skip and perform access check later\r\n                // For Records if the accessor method is used the field does not have to be made accessible\r\n                if (!blockInaccessible && accessor == null) {\r\n                    ReflectionHelper.makeAccessible(field);\r\n                }\r\n                Type fieldType = GsonTypes.resolve(type.getType(), raw, field.getGenericType());\r\n                List<String> fieldNames = getFieldNames(field);\r\n                String serializedName = fieldNames.get(0);\r\n                BoundField boundField = createBoundField(context, field, accessor, serializedName, TypeToken.get(fieldType), serialize, blockInaccessible);\r\n                if (deserialize) {\r\n                    for (String name : fieldNames) {\r\n                        BoundField replaced = deserializedFields.put(name, boundField);\r\n                        if (replaced != null) {\r\n                            throw createDuplicateFieldException(originalRaw, name, replaced.field, field);\r\n                        }\r\n                    }\r\n                }\r\n                if (serialize) {\r\n                    BoundField replaced = serializedFields.put(serializedName, boundField);\r\n                    if (replaced != null) {\r\n                        throw createDuplicateFieldException(originalRaw, serializedName, replaced.field, field);\r\n                    }\r\n                }\r\n            }\r\n            type = TypeToken.get(GsonTypes.resolve(type.getType(), raw, raw.getGenericSuperclass()));\r\n            raw = type.getRawType();\r\n        }\r\n        return new FieldsData(deserializedFields, new ArrayList<>(serializedFields.values()));\r\n    }\r\n\r\n    abstract static class BoundField {\r\n\r\n        /**\r\n         * Name used for serialization (but not for deserialization)\r\n         */\r\n        final String serializedName;\r\n\r\n        final Field field;\r\n\r\n        /**\r\n         * Name of the underlying field\r\n         */\r\n        final String fieldName;\r\n\r\n        protected BoundField(String serializedName, Field field) {\r\n            this.serializedName = serializedName;\r\n            this.field = field;\r\n            this.fieldName = field.getName();\r\n        }\r\n\r\n        /**\r\n         * Read this field value from the source, and append its JSON value to the writer\r\n         */\r\n        abstract void write(JsonWriter writer, Object source) throws IOException, IllegalAccessException;\r\n\r\n        /**\r\n         * Read the value into the target array, used to provide constructor arguments for records\r\n         */\r\n        abstract void readIntoArray(JsonReader reader, int index, Object[] target) throws IOException, JsonParseException;\r\n\r\n        /**\r\n         * Read the value from the reader, and set it on the corresponding field on target via\r\n         * reflection\r\n         */\r\n        abstract void readIntoField(JsonReader reader, Object target) throws IOException, IllegalAccessException;\r\n    }\r\n\r\n    /**\r\n     * Base class for Adapters produced by this factory.\r\n     *\r\n     * <p>The {@link RecordAdapter} is a special case to handle records for JVMs that support it, for\r\n     * all other types we use the {@link FieldReflectionAdapter}. This class encapsulates the common\r\n     * logic for serialization and deserialization. During deserialization, we construct an\r\n     * accumulator A, which we use to accumulate values from the source JSON. After the object has\r\n     * been read in full, the {@link #finalize(Object)} method is used to convert the accumulator to\r\n     * an instance of T.\r\n     *\r\n     * @param <T> type of objects that this Adapter creates.\r\n     * @param <A> type of accumulator used to build the deserialization result.\r\n     */\r\n    // This class is public because external projects check for this class with `instanceof` (even\r\n    // though it is internal)\r\n    public abstract static class Adapter<T, A> extends TypeAdapter<T> {\r\n\r\n        private final FieldsData fieldsData;\r\n\r\n        Adapter(FieldsData fieldsData) {\r\n            this.fieldsData = fieldsData;\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, T value) throws IOException {\r\n            if (value == null) {\r\n                out.nullValue();\r\n                return;\r\n            }\r\n            out.beginObject();\r\n            try {\r\n                for (BoundField boundField : fieldsData.serializedFields) {\r\n                    boundField.write(out, value);\r\n                }\r\n            } catch (IllegalAccessException e) {\r\n                throw ReflectionHelper.createExceptionForUnexpectedIllegalAccess(e);\r\n            }\r\n            out.endObject();\r\n        }\r\n\r\n        @Override\r\n        public T read(JsonReader in) throws IOException {\r\n            if (in.peek() == JsonToken.NULL) {\r\n                in.nextNull();\r\n                return null;\r\n            }\r\n            A accumulator = createAccumulator();\r\n            Map<String, BoundField> deserializedFields = fieldsData.deserializedFields;\r\n            try {\r\n                in.beginObject();\r\n                while (in.hasNext()) {\r\n                    String name = in.nextName();\r\n                    BoundField field = deserializedFields.get(name);\r\n                    if (field == null) {\r\n                        in.skipValue();\r\n                    } else {\r\n                        readField(accumulator, in, field);\r\n                    }\r\n                }\r\n            } catch (IllegalStateException e) {\r\n                throw new JsonSyntaxException(e);\r\n            } catch (IllegalAccessException e) {\r\n                throw ReflectionHelper.createExceptionForUnexpectedIllegalAccess(e);\r\n            }\r\n            in.endObject();\r\n            return finalize(accumulator);\r\n        }\r\n\r\n        /**\r\n         * Create the Object that will be used to collect each field value\r\n         */\r\n        abstract A createAccumulator();\r\n\r\n        /**\r\n         * Read a single BoundField into the accumulator. The JsonReader will be pointed at the start of\r\n         * the value for the BoundField to read from.\r\n         */\r\n        abstract void readField(A accumulator, JsonReader in, BoundField field) throws IllegalAccessException, IOException;\r\n\r\n        /**\r\n         * Convert the accumulator to a final instance of T.\r\n         */\r\n        abstract T finalize(A accumulator);\r\n    }\r\n\r\n    private static final class FieldReflectionAdapter<T> extends Adapter<T, T> {\r\n\r\n        private final ObjectConstructor<T> constructor;\r\n\r\n        FieldReflectionAdapter(ObjectConstructor<T> constructor, FieldsData fieldsData) {\r\n            super(fieldsData);\r\n            this.constructor = constructor;\r\n        }\r\n\r\n        @Override\r\n        T createAccumulator() {\r\n            return constructor.construct();\r\n        }\r\n\r\n        @Override\r\n        void readField(T accumulator, JsonReader in, BoundField field) throws IllegalAccessException, IOException {\r\n            field.readIntoField(in, accumulator);\r\n        }\r\n\r\n        @Override\r\n        T finalize(T accumulator) {\r\n            return accumulator;\r\n        }\r\n    }\r\n\r\n    private static final class RecordAdapter<T> extends Adapter<T, Object[]> {\r\n\r\n        static final Map<Class<?>, Object> PRIMITIVE_DEFAULTS = primitiveDefaults();\r\n\r\n        // The canonical constructor of the record\r\n        private final Constructor<T> constructor;\r\n\r\n        // Array of arguments to the constructor, initialized with default values for primitives\r\n        private final Object[] constructorArgsDefaults;\r\n\r\n        // Map from component names to index into the constructors arguments.\r\n        private final Map<String, Integer> componentIndices = new HashMap<>();\r\n\r\n        RecordAdapter(Class<T> raw, FieldsData fieldsData, boolean blockInaccessible) {\r\n            super(fieldsData);\r\n            constructor = ReflectionHelper.getCanonicalRecordConstructor(raw);\r\n            if (blockInaccessible) {\r\n                checkAccessible(null, constructor);\r\n            } else {\r\n                // Ensure the constructor is accessible\r\n                ReflectionHelper.makeAccessible(constructor);\r\n            }\r\n            String[] componentNames = ReflectionHelper.getRecordComponentNames(raw);\r\n            for (int i = 0; i < componentNames.length; i++) {\r\n                componentIndices.put(componentNames[i], i);\r\n            }\r\n            Class<?>[] parameterTypes = constructor.getParameterTypes();\r\n            // We need to ensure that we are passing non-null values to primitive fields in the\r\n            // constructor. To do this, we create an Object[] where all primitives are initialized to\r\n            // non-null values.\r\n            constructorArgsDefaults = new Object[parameterTypes.length];\r\n            for (int i = 0; i < parameterTypes.length; i++) {\r\n                // This will correctly be null for non-primitive types:\r\n                constructorArgsDefaults[i] = PRIMITIVE_DEFAULTS.get(parameterTypes[i]);\r\n            }\r\n        }\r\n\r\n        private static Map<Class<?>, Object> primitiveDefaults() {\r\n            Map<Class<?>, Object> zeroes = new HashMap<>();\r\n            zeroes.put(byte.class, (byte) 0);\r\n            zeroes.put(short.class, (short) 0);\r\n            zeroes.put(int.class, 0);\r\n            zeroes.put(long.class, 0L);\r\n            zeroes.put(float.class, 0F);\r\n            zeroes.put(double.class, 0D);\r\n            zeroes.put(char.class, '\\0');\r\n            zeroes.put(boolean.class, false);\r\n            return zeroes;\r\n        }\r\n\r\n        @Override\r\n        Object[] createAccumulator() {\r\n            return constructorArgsDefaults.clone();\r\n        }\r\n\r\n        @Override\r\n        void readField(Object[] accumulator, JsonReader in, BoundField field) throws IOException {\r\n            // Obtain the component index from the name of the field backing it\r\n            Integer componentIndex = componentIndices.get(field.fieldName);\r\n            if (componentIndex == null) {\r\n                throw new IllegalStateException(\"Could not find the index in the constructor '\" + ReflectionHelper.constructorToString(constructor) + \"' for field with name '\" + field.fieldName + \"', unable to determine which argument in the constructor the field corresponds\" + \" to. This is unexpected behavior, as we expect the RecordComponents to have the\" + \" same names as the fields in the Java class, and that the order of the\" + \" RecordComponents is the same as the order of the canonical constructor\" + \" parameters.\");\r\n            }\r\n            field.readIntoArray(in, componentIndex, accumulator);\r\n        }\r\n\r\n        @Override\r\n        T finalize(Object[] accumulator) {\r\n            try {\r\n                return constructor.newInstance(accumulator);\r\n            } catch (IllegalAccessException e) {\r\n                throw ReflectionHelper.createExceptionForUnexpectedIllegalAccess(e);\r\n            }// Note: InstantiationException should be impossible because record class is not abstract;\r\n            //  IllegalArgumentException should not be possible unless a bad adapter returns objects of\r\n            //  the wrong type\r\n             catch (InstantiationException | IllegalArgumentException e) {\r\n                throw new RuntimeException(\"Failed to invoke constructor '\" + ReflectionHelper.constructorToString(constructor) + \"' with args \" + Arrays.toString(accumulator), e);\r\n            } catch (InvocationTargetException e) {\r\n                // TODO: JsonParseException ?\r\n                throw new RuntimeException(\"Failed to invoke constructor '\" + ReflectionHelper.constructorToString(constructor) + \"' with args \" + Arrays.toString(accumulator), e.getCause());\r\n            }\r\n        }\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "field",
    "name": "constructorConstructor",
    "start_line": 61,
    "end_line": 61,
    "code": "private final ConstructorConstructor constructorConstructor;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "field",
    "name": "fieldNamingPolicy",
    "start_line": 62,
    "end_line": 62,
    "code": "private final FieldNamingStrategy fieldNamingPolicy;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "field",
    "name": "excluder",
    "start_line": 63,
    "end_line": 63,
    "code": "private final Excluder excluder;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "field",
    "name": "jsonAdapterFactory",
    "start_line": 64,
    "end_line": 64,
    "code": "private final JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "field",
    "name": "reflectionFilters",
    "start_line": 65,
    "end_line": 65,
    "code": "private final List<ReflectionAccessFilter> reflectionFilters;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "constructor",
    "name": "ReflectiveTypeAdapterFactory",
    "start_line": 67,
    "end_line": 78,
    "code": "public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor, FieldNamingStrategy fieldNamingPolicy, Excluder excluder, JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory, List<ReflectionAccessFilter> reflectionFilters) {\r\n    this.constructorConstructor = constructorConstructor;\r\n    this.fieldNamingPolicy = fieldNamingPolicy;\r\n    this.excluder = excluder;\r\n    this.jsonAdapterFactory = jsonAdapterFactory;\r\n    this.reflectionFilters = reflectionFilters;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "method",
    "name": "includeField",
    "start_line": 80,
    "end_line": 82,
    "code": "private boolean includeField(Field f, boolean serialize) {\r\n    return !excluder.excludeField(f, serialize);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "method",
    "name": "getFieldNames",
    "start_line": 85,
    "end_line": 107,
    "code": "/**\r\n * first element holds the default name\r\n */\r\n@SuppressWarnings(\"MixedMutabilityReturnType\")\r\nprivate List<String> getFieldNames(Field f) {\r\n    String fieldName;\r\n    List<String> alternates;\r\n    SerializedName annotation = f.getAnnotation(SerializedName.class);\r\n    if (annotation == null) {\r\n        fieldName = fieldNamingPolicy.translateName(f);\r\n        alternates = fieldNamingPolicy.alternateNames(f);\r\n    } else {\r\n        fieldName = annotation.value();\r\n        alternates = Arrays.asList(annotation.alternate());\r\n    }\r\n    if (alternates.isEmpty()) {\r\n        return Collections.singletonList(fieldName);\r\n    }\r\n    List<String> fieldNames = new ArrayList<>(alternates.size() + 1);\r\n    fieldNames.add(fieldName);\r\n    fieldNames.addAll(alternates);\r\n    return fieldNames;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "method",
    "name": "create",
    "start_line": 109,
    "end_line": 166,
    "code": "@Override\r\npublic <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\r\n    Class<? super T> raw = type.getRawType();\r\n    if (!Object.class.isAssignableFrom(raw)) {\r\n        // it's a primitive!\r\n        return null;\r\n    }\r\n    // Don't allow using reflection on anonymous and local classes because synthetic fields for\r\n    // captured enclosing values make this unreliable\r\n    if (ReflectionHelper.isAnonymousOrNonStaticLocal(raw)) {\r\n        // This adapter just serializes and deserializes null, ignoring the actual values\r\n        // This is done for backward compatibility; troubleshooting-wise it might be better to throw\r\n        // exceptions\r\n        return new TypeAdapter<T>() {\r\n\r\n            @Override\r\n            public T read(JsonReader in) throws IOException {\r\n                in.skipValue();\r\n                return null;\r\n            }\r\n\r\n            @Override\r\n            public void write(JsonWriter out, T value) throws IOException {\r\n                out.nullValue();\r\n            }\r\n\r\n            @Override\r\n            public String toString() {\r\n                return \"AnonymousOrNonStaticLocalClassAdapter\";\r\n            }\r\n        };\r\n    }\r\n    FilterResult filterResult = ReflectionAccessFilterHelper.getFilterResult(reflectionFilters, raw);\r\n    if (filterResult == FilterResult.BLOCK_ALL) {\r\n        throw new JsonIOException(\"ReflectionAccessFilter does not permit using reflection for \" + raw + \". Register a TypeAdapter for this type or adjust the access filter.\");\r\n    }\r\n    boolean blockInaccessible = filterResult == FilterResult.BLOCK_INACCESSIBLE;\r\n    // If the type is actually a Java Record, we need to use the RecordAdapter instead. This will\r\n    // always be false on JVMs that do not support records.\r\n    if (ReflectionHelper.isRecord(raw)) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        TypeAdapter<T> adapter = (TypeAdapter<T>) new RecordAdapter<>(raw, getBoundFields(gson, type, raw, blockInaccessible, true), blockInaccessible);\r\n        return adapter;\r\n    }\r\n    ObjectConstructor<T> constructor = constructorConstructor.get(type, true);\r\n    return new FieldReflectionAdapter<>(constructor, getBoundFields(gson, type, raw, blockInaccessible, false));\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "method",
    "name": "checkAccessible",
    "start_line": 168,
    "end_line": 179,
    "code": "private static <M extends AccessibleObject & Member> void checkAccessible(Object object, M member) {\r\n    if (!ReflectionAccessFilterHelper.canAccess(member, Modifier.isStatic(member.getModifiers()) ? null : object)) {\r\n        String memberDescription = ReflectionHelper.getAccessibleObjectDescription(member, true);\r\n        throw new JsonIOException(memberDescription + \" is not accessible and ReflectionAccessFilter does not permit making it\" + \" accessible. Register a TypeAdapter for the declaring type, adjust the access\" + \" filter or increase the visibility of the element and its declaring type.\");\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "method",
    "name": "createBoundField",
    "start_line": 181,
    "end_line": 286,
    "code": "private BoundField createBoundField(Gson context, Field field, Method accessor, String serializedName, TypeToken<?> fieldType, boolean serialize, boolean blockInaccessible) {\r\n    boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\r\n    int modifiers = field.getModifiers();\r\n    boolean isStaticFinalField = Modifier.isStatic(modifiers) && Modifier.isFinal(modifiers);\r\n    JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\r\n    TypeAdapter<?> mapped = null;\r\n    if (annotation != null) {\r\n        // This is not safe; requires that user has specified correct adapter class for @JsonAdapter\r\n        mapped = jsonAdapterFactory.getTypeAdapter(constructorConstructor, context, fieldType, annotation, false);\r\n    }\r\n    boolean jsonAdapterPresent = mapped != null;\r\n    if (mapped == null) {\r\n        mapped = context.getAdapter(fieldType);\r\n    }\r\n    @SuppressWarnings(\"unchecked\")\r\n    TypeAdapter<Object> typeAdapter = (TypeAdapter<Object>) mapped;\r\n    TypeAdapter<Object> writeTypeAdapter;\r\n    if (serialize) {\r\n        writeTypeAdapter = jsonAdapterPresent ? typeAdapter : new TypeAdapterRuntimeTypeWrapper<>(context, typeAdapter, fieldType.getType());\r\n    } else {\r\n        // Will never actually be used, but we set it to avoid confusing nullness-analysis tools\r\n        writeTypeAdapter = typeAdapter;\r\n    }\r\n    return new BoundField(serializedName, field) {\r\n\r\n        @Override\r\n        void write(JsonWriter writer, Object source) throws IOException, IllegalAccessException {\r\n            if (blockInaccessible) {\r\n                if (accessor == null) {\r\n                    checkAccessible(source, field);\r\n                } else {\r\n                    // Note: This check might actually be redundant because access check for canonical\r\n                    // constructor should have failed already\r\n                    checkAccessible(source, accessor);\r\n                }\r\n            }\r\n            Object fieldValue;\r\n            if (accessor != null) {\r\n                try {\r\n                    fieldValue = accessor.invoke(source);\r\n                } catch (InvocationTargetException e) {\r\n                    String accessorDescription = ReflectionHelper.getAccessibleObjectDescription(accessor, false);\r\n                    throw new JsonIOException(\"Accessor \" + accessorDescription + \" threw exception\", e.getCause());\r\n                }\r\n            } else {\r\n                fieldValue = field.get(source);\r\n            }\r\n            if (fieldValue == source) {\r\n                // avoid direct recursion\r\n                return;\r\n            }\r\n            writer.name(serializedName);\r\n            writeTypeAdapter.write(writer, fieldValue);\r\n        }\r\n\r\n        @Override\r\n        void readIntoArray(JsonReader reader, int index, Object[] target) throws IOException, JsonParseException {\r\n            Object fieldValue = typeAdapter.read(reader);\r\n            if (fieldValue == null && isPrimitive) {\r\n                throw new JsonParseException(\"null is not allowed as value for record component '\" + fieldName + \"' of primitive type; at path \" + reader.getPath());\r\n            }\r\n            target[index] = fieldValue;\r\n        }\r\n\r\n        @Override\r\n        void readIntoField(JsonReader reader, Object target) throws IOException, IllegalAccessException {\r\n            Object fieldValue = typeAdapter.read(reader);\r\n            if (fieldValue != null || !isPrimitive) {\r\n                if (blockInaccessible) {\r\n                    checkAccessible(target, field);\r\n                } else if (isStaticFinalField) {\r\n                    // Reflection does not permit setting value of `static final` field, even after calling\r\n                    // `setAccessible`\r\n                    // Handle this here to avoid causing IllegalAccessException when calling `Field.set`\r\n                    String fieldDescription = ReflectionHelper.getAccessibleObjectDescription(field, false);\r\n                    throw new JsonIOException(\"Cannot set value of 'static final' \" + fieldDescription);\r\n                }\r\n                field.set(target, fieldValue);\r\n            }\r\n        }\r\n    };\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "method",
    "name": "createDuplicateFieldException",
    "start_line": 304,
    "end_line": 317,
    "code": "private static IllegalArgumentException createDuplicateFieldException(Class<?> declaringType, String duplicateName, Field field1, Field field2) {\r\n    throw new IllegalArgumentException(\"Class \" + declaringType.getName() + \" declares multiple JSON fields named '\" + duplicateName + \"'; conflict is caused by fields \" + ReflectionHelper.fieldToString(field1) + \" and \" + ReflectionHelper.fieldToString(field2) + \"\\nSee \" + TroubleshootingGuide.createUrl(\"duplicate-fields\"));\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  },
  {
    "type": "method",
    "name": "getBoundFields",
    "start_line": 319,
    "end_line": 428,
    "code": "private FieldsData getBoundFields(Gson context, TypeToken<?> type, Class<?> raw, boolean blockInaccessible, boolean isRecord) {\r\n    if (raw.isInterface()) {\r\n        return FieldsData.EMPTY;\r\n    }\r\n    Map<String, BoundField> deserializedFields = new LinkedHashMap<>();\r\n    // For serialized fields use a Map to track duplicate field names; otherwise this could be a\r\n    // List<BoundField> instead\r\n    Map<String, BoundField> serializedFields = new LinkedHashMap<>();\r\n    Class<?> originalRaw = raw;\r\n    while (raw != Object.class) {\r\n        Field[] fields = raw.getDeclaredFields();\r\n        // For inherited fields, check if access to their declaring class is allowed\r\n        if (raw != originalRaw && fields.length > 0) {\r\n            FilterResult filterResult = ReflectionAccessFilterHelper.getFilterResult(reflectionFilters, raw);\r\n            if (filterResult == FilterResult.BLOCK_ALL) {\r\n                throw new JsonIOException(\"ReflectionAccessFilter does not permit using reflection for \" + raw + \" (supertype of \" + originalRaw + \"). Register a TypeAdapter for this type or adjust the access filter.\");\r\n            }\r\n            blockInaccessible = filterResult == FilterResult.BLOCK_INACCESSIBLE;\r\n        }\r\n        for (Field field : fields) {\r\n            boolean serialize = includeField(field, true);\r\n            boolean deserialize = includeField(field, false);\r\n            if (!serialize && !deserialize) {\r\n                continue;\r\n            }\r\n            // The accessor method is only used for records. If the type is a record, we will read out\r\n            // values via its accessor method instead of via reflection. This way we will bypass the\r\n            // accessible restrictions\r\n            Method accessor = null;\r\n            if (isRecord) {\r\n                // If there is a static field on a record, there will not be an accessor. Instead we will\r\n                // use the default field serialization logic, but for deserialization the field is\r\n                // excluded for simplicity.\r\n                // Note that Gson ignores static fields by default, but\r\n                // GsonBuilder.excludeFieldsWithModifiers can overwrite this.\r\n                if (Modifier.isStatic(field.getModifiers())) {\r\n                    deserialize = false;\r\n                } else {\r\n                    accessor = ReflectionHelper.getAccessor(raw, field);\r\n                    // If blockInaccessible, skip and perform access check later\r\n                    if (!blockInaccessible) {\r\n                        ReflectionHelper.makeAccessible(accessor);\r\n                    }\r\n                    // @SerializedName can be placed on accessor method, but it is not supported there\r\n                    // If field and method have annotation it is not easily possible to determine if\r\n                    // accessor method is implicit and has inherited annotation, or if it is explicitly\r\n                    // declared with custom annotation\r\n                    if (accessor.getAnnotation(SerializedName.class) != null && field.getAnnotation(SerializedName.class) == null) {\r\n                        String methodDescription = ReflectionHelper.getAccessibleObjectDescription(accessor, false);\r\n                        throw new JsonIOException(\"@SerializedName on \" + methodDescription + \" is not supported\");\r\n                    }\r\n                }\r\n            }\r\n            // If blockInaccessible, skip and perform access check later\r\n            // For Records if the accessor method is used the field does not have to be made accessible\r\n            if (!blockInaccessible && accessor == null) {\r\n                ReflectionHelper.makeAccessible(field);\r\n            }\r\n            Type fieldType = GsonTypes.resolve(type.getType(), raw, field.getGenericType());\r\n            List<String> fieldNames = getFieldNames(field);\r\n            String serializedName = fieldNames.get(0);\r\n            BoundField boundField = createBoundField(context, field, accessor, serializedName, TypeToken.get(fieldType), serialize, blockInaccessible);\r\n            if (deserialize) {\r\n                for (String name : fieldNames) {\r\n                    BoundField replaced = deserializedFields.put(name, boundField);\r\n                    if (replaced != null) {\r\n                        throw createDuplicateFieldException(originalRaw, name, replaced.field, field);\r\n                    }\r\n                }\r\n            }\r\n            if (serialize) {\r\n                BoundField replaced = serializedFields.put(serializedName, boundField);\r\n                if (replaced != null) {\r\n                    throw createDuplicateFieldException(originalRaw, serializedName, replaced.field, field);\r\n                }\r\n            }\r\n        }\r\n        type = TypeToken.get(GsonTypes.resolve(type.getType(), raw, raw.getGenericSuperclass()));\r\n        raw = type.getRawType();\r\n    }\r\n    return new FieldsData(deserializedFields, new ArrayList<>(serializedFields.values()));\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\ReflectiveTypeAdapterFactory.java"
  }
]