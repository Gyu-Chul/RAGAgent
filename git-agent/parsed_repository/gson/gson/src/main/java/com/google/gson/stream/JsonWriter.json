[
  {
    "type": "package",
    "name": "com.google.gson.stream",
    "start_line": 17,
    "end_line": 17,
    "code": "package com.google.gson.stream;\r\n\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.stream.JsonScope.DANGLING_NAME",
    "start_line": 19,
    "end_line": 19,
    "code": "import static com.google.gson.stream.JsonScope.DANGLING_NAME;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.stream.JsonScope.EMPTY_ARRAY",
    "start_line": 20,
    "end_line": 20,
    "code": "import static com.google.gson.stream.JsonScope.EMPTY_ARRAY;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.stream.JsonScope.EMPTY_DOCUMENT",
    "start_line": 21,
    "end_line": 21,
    "code": "import static com.google.gson.stream.JsonScope.EMPTY_DOCUMENT;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.stream.JsonScope.EMPTY_OBJECT",
    "start_line": 22,
    "end_line": 22,
    "code": "import static com.google.gson.stream.JsonScope.EMPTY_OBJECT;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.stream.JsonScope.NONEMPTY_ARRAY",
    "start_line": 23,
    "end_line": 23,
    "code": "import static com.google.gson.stream.JsonScope.NONEMPTY_ARRAY;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT",
    "start_line": 24,
    "end_line": 24,
    "code": "import static com.google.gson.stream.JsonScope.NONEMPTY_DOCUMENT;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.stream.JsonScope.NONEMPTY_OBJECT",
    "start_line": 25,
    "end_line": 25,
    "code": "import static com.google.gson.stream.JsonScope.NONEMPTY_OBJECT;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "import",
    "name": "com.google.errorprone.annotations.CanIgnoreReturnValue",
    "start_line": 27,
    "end_line": 27,
    "code": "import com.google.errorprone.annotations.CanIgnoreReturnValue;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.FormattingStyle",
    "start_line": 28,
    "end_line": 28,
    "code": "import com.google.gson.FormattingStyle;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.Gson",
    "start_line": 29,
    "end_line": 29,
    "code": "import com.google.gson.Gson;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.GsonBuilder",
    "start_line": 30,
    "end_line": 30,
    "code": "import com.google.gson.GsonBuilder;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.Strictness",
    "start_line": 31,
    "end_line": 31,
    "code": "import com.google.gson.Strictness;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "import",
    "name": "java.io.Closeable",
    "start_line": 32,
    "end_line": 32,
    "code": "import java.io.Closeable;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "import",
    "name": "java.io.Flushable",
    "start_line": 33,
    "end_line": 33,
    "code": "import java.io.Flushable;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "import",
    "name": "java.io.IOException",
    "start_line": 34,
    "end_line": 34,
    "code": "import java.io.IOException;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "import",
    "name": "java.io.Writer",
    "start_line": 35,
    "end_line": 35,
    "code": "import java.io.Writer;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "import",
    "name": "java.math.BigDecimal",
    "start_line": 36,
    "end_line": 36,
    "code": "import java.math.BigDecimal;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "import",
    "name": "java.math.BigInteger",
    "start_line": 37,
    "end_line": 37,
    "code": "import java.math.BigInteger;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "import",
    "name": "java.util.Arrays",
    "start_line": 38,
    "end_line": 38,
    "code": "import java.util.Arrays;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "import",
    "name": "java.util.Objects",
    "start_line": 39,
    "end_line": 39,
    "code": "import java.util.Objects;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "import",
    "name": "java.util.concurrent.atomic.AtomicInteger",
    "start_line": 40,
    "end_line": 40,
    "code": "import java.util.concurrent.atomic.AtomicInteger;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "import",
    "name": "java.util.concurrent.atomic.AtomicLong",
    "start_line": 41,
    "end_line": 41,
    "code": "import java.util.concurrent.atomic.AtomicLong;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "import",
    "name": "java.util.regex.Pattern",
    "start_line": 42,
    "end_line": 42,
    "code": "import java.util.regex.Pattern;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "class",
    "name": "JsonWriter",
    "start_line": 163,
    "end_line": 837,
    "code": "/**\r\n * Writes a JSON (<a href=\"https://www.ietf.org/rfc/rfc8259.txt\">RFC 8259</a>) encoded value to a\r\n * stream, one token at a time. The stream includes both literal values (strings, numbers, booleans\r\n * and nulls) as well as the begin and end delimiters of objects and arrays.\r\n *\r\n * <h2>Encoding JSON</h2>\r\n *\r\n * To encode your data as JSON, create a new {@code JsonWriter}. Call methods on the writer as you\r\n * walk the structure's contents, nesting arrays and objects as necessary:\r\n *\r\n * <ul>\r\n *   <li>To write <strong>arrays</strong>, first call {@link #beginArray()}. Write each of the\r\n *       array's elements with the appropriate {@link #value} methods or by nesting other arrays and\r\n *       objects. Finally close the array using {@link #endArray()}.\r\n *   <li>To write <strong>objects</strong>, first call {@link #beginObject()}. Write each of the\r\n *       object's properties by alternating calls to {@link #name} with the property's value. Write\r\n *       property values with the appropriate {@link #value} method or by nesting other objects or\r\n *       arrays. Finally close the object using {@link #endObject()}.\r\n * </ul>\r\n *\r\n * <h2>Configuration</h2>\r\n *\r\n * The behavior of this writer can be customized with the following methods:\r\n *\r\n * <ul>\r\n *   <li>{@link #setFormattingStyle(FormattingStyle)}, the default is {@link\r\n *       FormattingStyle#COMPACT}\r\n *   <li>{@link #setHtmlSafe(boolean)}, by default HTML characters are not escaped in the JSON\r\n *       output\r\n *   <li>{@link #setStrictness(Strictness)}, the default is {@link Strictness#LEGACY_STRICT}\r\n *   <li>{@link #setSerializeNulls(boolean)}, by default {@code null} is serialized\r\n * </ul>\r\n *\r\n * The default configuration of {@code JsonWriter} instances used internally by the {@link Gson}\r\n * class differs, and can be adjusted with the various {@link GsonBuilder} methods.\r\n *\r\n * <h2>Example</h2>\r\n *\r\n * Suppose we'd like to encode a stream of messages such as the following:\r\n *\r\n * <pre>{@code\r\n * [\r\n *   {\r\n *     \"id\": 912345678901,\r\n *     \"text\": \"How do I stream JSON in Java?\",\r\n *     \"geo\": null,\r\n *     \"user\": {\r\n *       \"name\": \"json_newb\",\r\n *       \"followers_count\": 41\r\n *      }\r\n *   },\r\n *   {\r\n *     \"id\": 912345678902,\r\n *     \"text\": \"@json_newb just use JsonWriter!\",\r\n *     \"geo\": [50.454722, -104.606667],\r\n *     \"user\": {\r\n *       \"name\": \"jesse\",\r\n *       \"followers_count\": 2\r\n *     }\r\n *   }\r\n * ]\r\n * }</pre>\r\n *\r\n * This code encodes the above structure:\r\n *\r\n * <pre>{@code\r\n * public void writeJsonStream(OutputStream out, List<Message> messages) throws IOException {\r\n *   JsonWriter writer = new JsonWriter(new OutputStreamWriter(out, \"UTF-8\"));\r\n *   writer.setIndent(\"    \");\r\n *   writeMessagesArray(writer, messages);\r\n *   writer.close();\r\n * }\r\n *\r\n * public void writeMessagesArray(JsonWriter writer, List<Message> messages) throws IOException {\r\n *   writer.beginArray();\r\n *   for (Message message : messages) {\r\n *     writeMessage(writer, message);\r\n *   }\r\n *   writer.endArray();\r\n * }\r\n *\r\n * public void writeMessage(JsonWriter writer, Message message) throws IOException {\r\n *   writer.beginObject();\r\n *   writer.name(\"id\").value(message.getId());\r\n *   writer.name(\"text\").value(message.getText());\r\n *   if (message.getGeo() != null) {\r\n *     writer.name(\"geo\");\r\n *     writeDoublesArray(writer, message.getGeo());\r\n *   } else {\r\n *     writer.name(\"geo\").nullValue();\r\n *   }\r\n *   writer.name(\"user\");\r\n *   writeUser(writer, message.getUser());\r\n *   writer.endObject();\r\n * }\r\n *\r\n * public void writeUser(JsonWriter writer, User user) throws IOException {\r\n *   writer.beginObject();\r\n *   writer.name(\"name\").value(user.getName());\r\n *   writer.name(\"followers_count\").value(user.getFollowersCount());\r\n *   writer.endObject();\r\n * }\r\n *\r\n * public void writeDoublesArray(JsonWriter writer, List<Double> doubles) throws IOException {\r\n *   writer.beginArray();\r\n *   for (Double value : doubles) {\r\n *     writer.value(value);\r\n *   }\r\n *   writer.endArray();\r\n * }\r\n * }</pre>\r\n *\r\n * <p>Each {@code JsonWriter} may be used to write a single JSON stream. Instances of this class are\r\n * not thread safe. Calls that would result in a malformed JSON string will fail with an {@link\r\n * IllegalStateException}.\r\n *\r\n * @author Jesse Wilson\r\n * @since 1.6\r\n */\r\npublic class JsonWriter implements Closeable, Flushable {\r\n\r\n    // Syntax as defined by https://datatracker.ietf.org/doc/html/rfc8259#section-6\r\n    private static final Pattern VALID_JSON_NUMBER_PATTERN = Pattern.compile(\"-?(?:0|[1-9][0-9]*)(?:\\\\.[0-9]+)?(?:[eE][-+]?[0-9]+)?\");\r\n\r\n    /*\r\n   * From RFC 8259, \"All Unicode characters may be placed within the\r\n   * quotation marks except for the characters that must be escaped:\r\n   * quotation mark, reverse solidus, and the control characters\r\n   * (U+0000 through U+001F).\"\r\n   *\r\n   * We also escape '\\u2028' and '\\u2029', which JavaScript interprets as\r\n   * newline characters. This prevents eval() from failing with a syntax\r\n   * error. http://code.google.com/p/google-gson/issues/detail?id=341\r\n   */\r\n    private static final String[] REPLACEMENT_CHARS;\r\n\r\n    private static final String[] HTML_SAFE_REPLACEMENT_CHARS;\r\n\r\n    static {\r\n        REPLACEMENT_CHARS = new String[128];\r\n        for (int i = 0; i <= 0x1f; i++) {\r\n            REPLACEMENT_CHARS[i] = String.format(\"\\\\u%04x\", i);\r\n        }\r\n        REPLACEMENT_CHARS['\"'] = \"\\\\\\\"\";\r\n        REPLACEMENT_CHARS['\\\\'] = \"\\\\\\\\\";\r\n        REPLACEMENT_CHARS['\\t'] = \"\\\\t\";\r\n        REPLACEMENT_CHARS['\\b'] = \"\\\\b\";\r\n        REPLACEMENT_CHARS['\\n'] = \"\\\\n\";\r\n        REPLACEMENT_CHARS['\\r'] = \"\\\\r\";\r\n        REPLACEMENT_CHARS['\\f'] = \"\\\\f\";\r\n        HTML_SAFE_REPLACEMENT_CHARS = REPLACEMENT_CHARS.clone();\r\n        HTML_SAFE_REPLACEMENT_CHARS['<'] = \"\\\\u003c\";\r\n        HTML_SAFE_REPLACEMENT_CHARS['>'] = \"\\\\u003e\";\r\n        HTML_SAFE_REPLACEMENT_CHARS['&'] = \"\\\\u0026\";\r\n        HTML_SAFE_REPLACEMENT_CHARS['='] = \"\\\\u003d\";\r\n        HTML_SAFE_REPLACEMENT_CHARS['\\''] = \"\\\\u0027\";\r\n    }\r\n\r\n    /**\r\n     * The JSON output destination\r\n     */\r\n    private final Writer out;\r\n\r\n    private int[] stack = new int[32];\r\n\r\n    private int stackSize = 0;\r\n\r\n    {\r\n        push(EMPTY_DOCUMENT);\r\n    }\r\n\r\n    private FormattingStyle formattingStyle;\r\n\r\n    // These fields cache data derived from the formatting style, to avoid having to\r\n    // re-evaluate it every time something is written\r\n    private String formattedColon;\r\n\r\n    private String formattedComma;\r\n\r\n    private boolean usesEmptyNewlineAndIndent;\r\n\r\n    private Strictness strictness = Strictness.LEGACY_STRICT;\r\n\r\n    private boolean htmlSafe;\r\n\r\n    private String deferredName;\r\n\r\n    private boolean serializeNulls = true;\r\n\r\n    /**\r\n     * Creates a new instance that writes a JSON-encoded stream to {@code out}. For best performance,\r\n     * ensure {@link Writer} is buffered; wrapping in {@link java.io.BufferedWriter BufferedWriter} if\r\n     * necessary.\r\n     */\r\n    public JsonWriter(Writer out) {\r\n        this.out = Objects.requireNonNull(out, \"out == null\");\r\n        setFormattingStyle(FormattingStyle.COMPACT);\r\n    }\r\n\r\n    /**\r\n     * Sets the indentation string to be repeated for each level of indentation in the encoded\r\n     * document. If {@code indent.isEmpty()} the encoded document will be compact. Otherwise the\r\n     * encoded document will be more human-readable.\r\n     *\r\n     * <p>This is a convenience method which overwrites any previously {@linkplain\r\n     * #setFormattingStyle(FormattingStyle) set formatting style} with either {@link\r\n     * FormattingStyle#COMPACT} if the given indent string is empty, or {@link FormattingStyle#PRETTY}\r\n     * with the given indent if not empty.\r\n     *\r\n     * @param indent a string containing only whitespace.\r\n     */\r\n    public final void setIndent(String indent) {\r\n        if (indent.isEmpty()) {\r\n            setFormattingStyle(FormattingStyle.COMPACT);\r\n        } else {\r\n            setFormattingStyle(FormattingStyle.PRETTY.withIndent(indent));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the formatting style to be used in the encoded document.\r\n     *\r\n     * <p>The formatting style specifies for example the indentation string to be repeated for each\r\n     * level of indentation, or the newline style, to accommodate various OS styles.\r\n     *\r\n     * @param formattingStyle the formatting style to use, must not be {@code null}.\r\n     * @see #getFormattingStyle()\r\n     * @since 2.11.0\r\n     */\r\n    public final void setFormattingStyle(FormattingStyle formattingStyle) {\r\n        this.formattingStyle = Objects.requireNonNull(formattingStyle);\r\n        this.formattedComma = \",\";\r\n        if (this.formattingStyle.usesSpaceAfterSeparators()) {\r\n            this.formattedColon = \": \";\r\n            // Only add space if no newline is written\r\n            if (this.formattingStyle.getNewline().isEmpty()) {\r\n                this.formattedComma = \", \";\r\n            }\r\n        } else {\r\n            this.formattedColon = \":\";\r\n        }\r\n        this.usesEmptyNewlineAndIndent = this.formattingStyle.getNewline().isEmpty() && this.formattingStyle.getIndent().isEmpty();\r\n    }\r\n\r\n    /**\r\n     * Returns the pretty printing style used by this writer.\r\n     *\r\n     * @return the {@code FormattingStyle} that will be used.\r\n     * @see #setFormattingStyle(FormattingStyle)\r\n     * @since 2.11.0\r\n     */\r\n    public final FormattingStyle getFormattingStyle() {\r\n        return formattingStyle;\r\n    }\r\n\r\n    /**\r\n     * Sets the strictness of this writer.\r\n     *\r\n     * @deprecated Please use {@link #setStrictness(Strictness)} instead. {@code\r\n     *     JsonWriter.setLenient(true)} should be replaced by {@code\r\n     *     JsonWriter.setStrictness(Strictness.LENIENT)} and {@code JsonWriter.setLenient(false)}\r\n     *     should be replaced by {@code JsonWriter.setStrictness(Strictness.LEGACY_STRICT)}.<br>\r\n     *     However, if you used {@code setLenient(false)} before, you might prefer {@link\r\n     *     Strictness#STRICT} now instead.\r\n     * @param lenient whether this writer should be lenient. If true, the strictness is set to {@link\r\n     *     Strictness#LENIENT}. If false, the strictness is set to {@link Strictness#LEGACY_STRICT}.\r\n     * @see #setStrictness(Strictness)\r\n     */\r\n    @Deprecated\r\n    // Don't specify @InlineMe, so caller with `setLenient(false)` becomes aware of new\r\n    // Strictness.STRICT\r\n    @SuppressWarnings(\"InlineMeSuggester\")\r\n    public final void setLenient(boolean lenient) {\r\n        setStrictness(lenient ? Strictness.LENIENT : Strictness.LEGACY_STRICT);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the {@link Strictness} of this writer is equal to {@link Strictness#LENIENT}.\r\n     *\r\n     * @see #getStrictness()\r\n     */\r\n    public boolean isLenient() {\r\n        return strictness == Strictness.LENIENT;\r\n    }\r\n\r\n    /**\r\n     * Configures how strict this writer is with regard to the syntax rules specified in <a\r\n     * href=\"https://www.ietf.org/rfc/rfc8259.txt\">RFC 8259</a>. By default, {@link\r\n     * Strictness#LEGACY_STRICT} is used.\r\n     *\r\n     * <dl>\r\n     *   <dt>{@link Strictness#STRICT} &amp; {@link Strictness#LEGACY_STRICT}\r\n     *   <dd>The behavior of these is currently identical. In these strictness modes, the writer only\r\n     *       writes JSON in accordance with RFC 8259.\r\n     *   <dt>{@link Strictness#LENIENT}\r\n     *   <dd>This mode relaxes the behavior of the writer to allow the writing of {@link\r\n     *       Double#isNaN() NaNs} and {@link Double#isInfinite() infinities}. It also allows writing\r\n     *       multiple top level values.\r\n     * </dl>\r\n     *\r\n     * @param strictness the new strictness of this writer. May not be {@code null}.\r\n     * @see #getStrictness()\r\n     * @since 2.11.0\r\n     */\r\n    public final void setStrictness(Strictness strictness) {\r\n        this.strictness = Objects.requireNonNull(strictness);\r\n    }\r\n\r\n    /**\r\n     * Returns the {@linkplain Strictness strictness} of this writer.\r\n     *\r\n     * @see #setStrictness(Strictness)\r\n     * @since 2.11.0\r\n     */\r\n    public final Strictness getStrictness() {\r\n        return strictness;\r\n    }\r\n\r\n    /**\r\n     * Configures this writer to emit JSON that's safe for direct inclusion in HTML and XML documents.\r\n     * This escapes the HTML characters {@code <}, {@code >}, {@code &}, {@code =} and {@code '}\r\n     * before writing them to the stream. Without this setting, your XML/HTML encoder should replace\r\n     * these characters with the corresponding escape sequences.\r\n     *\r\n     * @see #isHtmlSafe()\r\n     */\r\n    public final void setHtmlSafe(boolean htmlSafe) {\r\n        this.htmlSafe = htmlSafe;\r\n    }\r\n\r\n    /**\r\n     * Returns true if this writer writes JSON that's safe for inclusion in HTML and XML documents.\r\n     *\r\n     * @see #setHtmlSafe(boolean)\r\n     */\r\n    public final boolean isHtmlSafe() {\r\n        return htmlSafe;\r\n    }\r\n\r\n    /**\r\n     * Sets whether object members are serialized when their value is null. This has no impact on\r\n     * array elements. The default is true.\r\n     *\r\n     * @see #getSerializeNulls()\r\n     */\r\n    public final void setSerializeNulls(boolean serializeNulls) {\r\n        this.serializeNulls = serializeNulls;\r\n    }\r\n\r\n    /**\r\n     * Returns true if object members are serialized when their value is null. This has no impact on\r\n     * array elements. The default is true.\r\n     *\r\n     * @see #setSerializeNulls(boolean)\r\n     */\r\n    public final boolean getSerializeNulls() {\r\n        return serializeNulls;\r\n    }\r\n\r\n    /**\r\n     * Begins encoding a new array. Each call to this method must be paired with a call to {@link\r\n     * #endArray}.\r\n     *\r\n     * @return this writer.\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public JsonWriter beginArray() throws IOException {\r\n        writeDeferredName();\r\n        return openScope(EMPTY_ARRAY, '[');\r\n    }\r\n\r\n    /**\r\n     * Ends encoding the current array.\r\n     *\r\n     * @return this writer.\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public JsonWriter endArray() throws IOException {\r\n        return closeScope(EMPTY_ARRAY, NONEMPTY_ARRAY, ']');\r\n    }\r\n\r\n    /**\r\n     * Begins encoding a new object. Each call to this method must be paired with a call to {@link\r\n     * #endObject}.\r\n     *\r\n     * @return this writer.\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public JsonWriter beginObject() throws IOException {\r\n        writeDeferredName();\r\n        return openScope(EMPTY_OBJECT, '{');\r\n    }\r\n\r\n    /**\r\n     * Ends encoding the current object.\r\n     *\r\n     * @return this writer.\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public JsonWriter endObject() throws IOException {\r\n        return closeScope(EMPTY_OBJECT, NONEMPTY_OBJECT, '}');\r\n    }\r\n\r\n    /**\r\n     * Enters a new scope by appending any necessary whitespace and the given bracket.\r\n     */\r\n    @CanIgnoreReturnValue\r\n    private JsonWriter openScope(int empty, char openBracket) throws IOException {\r\n        beforeValue();\r\n        push(empty);\r\n        out.write(openBracket);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Closes the current scope by appending any necessary whitespace and the given bracket.\r\n     */\r\n    @CanIgnoreReturnValue\r\n    private JsonWriter closeScope(int empty, int nonempty, char closeBracket) throws IOException {\r\n        int context = peek();\r\n        if (context != nonempty && context != empty) {\r\n            throw new IllegalStateException(\"Nesting problem.\");\r\n        }\r\n        if (deferredName != null) {\r\n            throw new IllegalStateException(\"Dangling name: \" + deferredName);\r\n        }\r\n        stackSize--;\r\n        if (context == nonempty) {\r\n            newline();\r\n        }\r\n        out.write(closeBracket);\r\n        return this;\r\n    }\r\n\r\n    private void push(int newTop) {\r\n        if (stackSize == stack.length) {\r\n            stack = Arrays.copyOf(stack, stackSize * 2);\r\n        }\r\n        stack[stackSize++] = newTop;\r\n    }\r\n\r\n    /**\r\n     * Returns the value on the top of the stack.\r\n     */\r\n    private int peek() {\r\n        if (stackSize == 0) {\r\n            throw new IllegalStateException(\"JsonWriter is closed.\");\r\n        }\r\n        return stack[stackSize - 1];\r\n    }\r\n\r\n    /**\r\n     * Replace the value on the top of the stack with the given value.\r\n     */\r\n    private void replaceTop(int topOfStack) {\r\n        stack[stackSize - 1] = topOfStack;\r\n    }\r\n\r\n    /**\r\n     * Encodes the property name.\r\n     *\r\n     * @param name the name of the forthcoming value. May not be {@code null}.\r\n     * @return this writer.\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public JsonWriter name(String name) throws IOException {\r\n        Objects.requireNonNull(name, \"name == null\");\r\n        if (deferredName != null) {\r\n            throw new IllegalStateException(\"Already wrote a name, expecting a value.\");\r\n        }\r\n        int context = peek();\r\n        if (context != EMPTY_OBJECT && context != NONEMPTY_OBJECT) {\r\n            throw new IllegalStateException(\"Please begin an object before writing a name.\");\r\n        }\r\n        deferredName = name;\r\n        return this;\r\n    }\r\n\r\n    private void writeDeferredName() throws IOException {\r\n        if (deferredName != null) {\r\n            beforeName();\r\n            string(deferredName);\r\n            deferredName = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Encodes {@code value}.\r\n     *\r\n     * @param value the literal string value, or null to encode a null literal.\r\n     * @return this writer.\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public JsonWriter value(String value) throws IOException {\r\n        if (value == null) {\r\n            return nullValue();\r\n        }\r\n        writeDeferredName();\r\n        beforeValue();\r\n        string(value);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Encodes {@code value}.\r\n     *\r\n     * @return this writer.\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public JsonWriter value(boolean value) throws IOException {\r\n        writeDeferredName();\r\n        beforeValue();\r\n        out.write(value ? \"true\" : \"false\");\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Encodes {@code value}.\r\n     *\r\n     * @return this writer.\r\n     * @since 2.7\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public JsonWriter value(Boolean value) throws IOException {\r\n        if (value == null) {\r\n            return nullValue();\r\n        }\r\n        writeDeferredName();\r\n        beforeValue();\r\n        out.write(value ? \"true\" : \"false\");\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Encodes {@code value}.\r\n     *\r\n     * @param value a finite value, or if {@link #setStrictness(Strictness) lenient}, also {@link\r\n     *     Float#isNaN() NaN} or {@link Float#isInfinite() infinity}.\r\n     * @return this writer.\r\n     * @throws IllegalArgumentException if the value is NaN or Infinity and this writer is not {@link\r\n     *     #setStrictness(Strictness) lenient}.\r\n     * @since 2.9.1\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public JsonWriter value(float value) throws IOException {\r\n        writeDeferredName();\r\n        if (strictness != Strictness.LENIENT && (Float.isNaN(value) || Float.isInfinite(value))) {\r\n            throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\r\n        }\r\n        beforeValue();\r\n        out.append(Float.toString(value));\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Encodes {@code value}.\r\n     *\r\n     * @param value a finite value, or if {@link #setStrictness(Strictness) lenient}, also {@link\r\n     *     Double#isNaN() NaN} or {@link Double#isInfinite() infinity}.\r\n     * @return this writer.\r\n     * @throws IllegalArgumentException if the value is NaN or Infinity and this writer is not {@link\r\n     *     #setStrictness(Strictness) lenient}.\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public JsonWriter value(double value) throws IOException {\r\n        writeDeferredName();\r\n        if (strictness != Strictness.LENIENT && (Double.isNaN(value) || Double.isInfinite(value))) {\r\n            throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\r\n        }\r\n        beforeValue();\r\n        out.append(Double.toString(value));\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Encodes {@code value}.\r\n     *\r\n     * @return this writer.\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public JsonWriter value(long value) throws IOException {\r\n        writeDeferredName();\r\n        beforeValue();\r\n        out.write(Long.toString(value));\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Encodes {@code value}. The value is written by directly writing the {@link Number#toString()}\r\n     * result to JSON. Implementations must make sure that the result represents a valid JSON number.\r\n     *\r\n     * @param value a finite value, or if {@link #setStrictness(Strictness) lenient}, also {@link\r\n     *     Double#isNaN() NaN} or {@link Double#isInfinite() infinity}.\r\n     * @return this writer.\r\n     * @throws IllegalArgumentException if the value is NaN or Infinity and this writer is not {@link\r\n     *     #setStrictness(Strictness) lenient}; or if the {@code toString()} result is not a valid\r\n     *     JSON number.\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public JsonWriter value(Number value) throws IOException {\r\n        if (value == null) {\r\n            return nullValue();\r\n        }\r\n        writeDeferredName();\r\n        String string = value.toString();\r\n        Class<? extends Number> numberClass = value.getClass();\r\n        if (!alwaysCreatesValidJsonNumber(numberClass)) {\r\n            // Validate that string is valid before writing it directly to JSON output\r\n            if (string.equals(\"-Infinity\") || string.equals(\"Infinity\") || string.equals(\"NaN\")) {\r\n                if (strictness != Strictness.LENIENT) {\r\n                    throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + string);\r\n                }\r\n            } else if (numberClass != Float.class && numberClass != Double.class && !VALID_JSON_NUMBER_PATTERN.matcher(string).matches()) {\r\n                throw new IllegalArgumentException(\"String created by \" + numberClass + \" is not a valid JSON number: \" + string);\r\n            }\r\n        }\r\n        beforeValue();\r\n        out.append(string);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Encodes {@code null}.\r\n     *\r\n     * @return this writer.\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public JsonWriter nullValue() throws IOException {\r\n        if (deferredName != null) {\r\n            if (serializeNulls) {\r\n                writeDeferredName();\r\n            } else {\r\n                deferredName = null;\r\n                // skip the name and the value\r\n                return this;\r\n            }\r\n        }\r\n        beforeValue();\r\n        out.write(\"null\");\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Writes {@code value} directly to the writer without quoting or escaping. This might not be\r\n     * supported by all implementations, if not supported an {@code UnsupportedOperationException} is\r\n     * thrown.\r\n     *\r\n     * @param value the literal string value, or null to encode a null literal.\r\n     * @return this writer.\r\n     * @throws UnsupportedOperationException if this writer does not support writing raw JSON values.\r\n     * @since 2.4\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public JsonWriter jsonValue(String value) throws IOException {\r\n        if (value == null) {\r\n            return nullValue();\r\n        }\r\n        writeDeferredName();\r\n        beforeValue();\r\n        out.append(value);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Ensures all buffered data is written to the underlying {@link Writer} and flushes that writer.\r\n     */\r\n    @Override\r\n    public void flush() throws IOException {\r\n        if (stackSize == 0) {\r\n            throw new IllegalStateException(\"JsonWriter is closed.\");\r\n        }\r\n        out.flush();\r\n    }\r\n\r\n    /**\r\n     * Flushes and closes this writer and the underlying {@link Writer}.\r\n     *\r\n     * @throws IOException if the JSON document is incomplete.\r\n     */\r\n    @Override\r\n    public void close() throws IOException {\r\n        out.close();\r\n        int size = stackSize;\r\n        if (size > 1 || (size == 1 && stack[size - 1] != NONEMPTY_DOCUMENT)) {\r\n            throw new IOException(\"Incomplete document\");\r\n        }\r\n        stackSize = 0;\r\n    }\r\n\r\n    /**\r\n     * Returns whether the {@code toString()} of {@code c} will always return a valid JSON number.\r\n     */\r\n    private static boolean alwaysCreatesValidJsonNumber(Class<? extends Number> c) {\r\n        // Does not include Float or Double because their value can be NaN or Infinity\r\n        // Does not include LazilyParsedNumber because it could contain a malformed string\r\n        return c == Integer.class || c == Long.class || c == Byte.class || c == Short.class || c == BigDecimal.class || c == BigInteger.class || c == AtomicInteger.class || c == AtomicLong.class;\r\n    }\r\n\r\n    private void string(String value) throws IOException {\r\n        String[] replacements = htmlSafe ? HTML_SAFE_REPLACEMENT_CHARS : REPLACEMENT_CHARS;\r\n        out.write('\\\"');\r\n        int last = 0;\r\n        int length = value.length();\r\n        for (int i = 0; i < length; i++) {\r\n            char c = value.charAt(i);\r\n            String replacement;\r\n            if (c < 128) {\r\n                replacement = replacements[c];\r\n                if (replacement == null) {\r\n                    continue;\r\n                }\r\n            } else if (c == '\\u2028') {\r\n                replacement = \"\\\\u2028\";\r\n            } else if (c == '\\u2029') {\r\n                replacement = \"\\\\u2029\";\r\n            } else {\r\n                continue;\r\n            }\r\n            if (last < i) {\r\n                out.write(value, last, i - last);\r\n            }\r\n            out.write(replacement);\r\n            last = i + 1;\r\n        }\r\n        if (last < length) {\r\n            out.write(value, last, length - last);\r\n        }\r\n        out.write('\\\"');\r\n    }\r\n\r\n    private void newline() throws IOException {\r\n        if (usesEmptyNewlineAndIndent) {\r\n            return;\r\n        }\r\n        out.write(formattingStyle.getNewline());\r\n        for (int i = 1, size = stackSize; i < size; i++) {\r\n            out.write(formattingStyle.getIndent());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Inserts any necessary separators and whitespace before a name. Also adjusts the stack to expect\r\n     * the name's value.\r\n     */\r\n    private void beforeName() throws IOException {\r\n        int context = peek();\r\n        if (context == NONEMPTY_OBJECT) {\r\n            // first in object\r\n            out.write(formattedComma);\r\n        } else if (context != EMPTY_OBJECT) {\r\n            // not in an object!\r\n            throw new IllegalStateException(\"Nesting problem.\");\r\n        }\r\n        newline();\r\n        replaceTop(DANGLING_NAME);\r\n    }\r\n\r\n    /**\r\n     * Inserts any necessary separators and whitespace before a literal value, inline array, or inline\r\n     * object. Also adjusts the stack to expect either a closing bracket or another element.\r\n     */\r\n    @SuppressWarnings(\"fallthrough\")\r\n    private void beforeValue() throws IOException {\r\n        switch(peek()) {\r\n            case NONEMPTY_DOCUMENT:\r\n                if (strictness != Strictness.LENIENT) {\r\n                    throw new IllegalStateException(\"JSON must have only one top-level value.\");\r\n                }\r\n            // fall-through\r\n            case // first in document\r\n            EMPTY_DOCUMENT:\r\n                replaceTop(NONEMPTY_DOCUMENT);\r\n                break;\r\n            case // first in array\r\n            EMPTY_ARRAY:\r\n                replaceTop(NONEMPTY_ARRAY);\r\n                newline();\r\n                break;\r\n            case // another in array\r\n            NONEMPTY_ARRAY:\r\n                out.append(formattedComma);\r\n                newline();\r\n                break;\r\n            case // value for name\r\n            DANGLING_NAME:\r\n                out.append(formattedColon);\r\n                replaceTop(NONEMPTY_OBJECT);\r\n                break;\r\n            default:\r\n                throw new IllegalStateException(\"Nesting problem.\");\r\n        }\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "field",
    "name": "VALID_JSON_NUMBER_PATTERN",
    "start_line": 166,
    "end_line": 167,
    "code": "// Syntax as defined by https://datatracker.ietf.org/doc/html/rfc8259#section-6\r\nprivate static final Pattern VALID_JSON_NUMBER_PATTERN = Pattern.compile(\"-?(?:0|[1-9][0-9]*)(?:\\\\.[0-9]+)?(?:[eE][-+]?[0-9]+)?\");",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "field",
    "name": "REPLACEMENT_CHARS",
    "start_line": 179,
    "end_line": 179,
    "code": "/*\r\n   * From RFC 8259, \"All Unicode characters may be placed within the\r\n   * quotation marks except for the characters that must be escaped:\r\n   * quotation mark, reverse solidus, and the control characters\r\n   * (U+0000 through U+001F).\"\r\n   *\r\n   * We also escape '\\u2028' and '\\u2029', which JavaScript interprets as\r\n   * newline characters. This prevents eval() from failing with a syntax\r\n   * error. http://code.google.com/p/google-gson/issues/detail?id=341\r\n   */\r\nprivate static final String[] REPLACEMENT_CHARS;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "field",
    "name": "HTML_SAFE_REPLACEMENT_CHARS",
    "start_line": 180,
    "end_line": 180,
    "code": "private static final String[] HTML_SAFE_REPLACEMENT_CHARS;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "field",
    "name": "out",
    "start_line": 203,
    "end_line": 203,
    "code": "/**\r\n * The JSON output destination\r\n */\r\nprivate final Writer out;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "field",
    "name": "stack",
    "start_line": 205,
    "end_line": 205,
    "code": "private int[] stack = new int[32];",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "field",
    "name": "stackSize",
    "start_line": 206,
    "end_line": 206,
    "code": "private int stackSize = 0;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "field",
    "name": "formattingStyle",
    "start_line": 212,
    "end_line": 212,
    "code": "private FormattingStyle formattingStyle;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "field",
    "name": "formattedColon",
    "start_line": 215,
    "end_line": 215,
    "code": "// These fields cache data derived from the formatting style, to avoid having to\r\n// re-evaluate it every time something is written\r\nprivate String formattedColon;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "field",
    "name": "formattedComma",
    "start_line": 216,
    "end_line": 216,
    "code": "private String formattedComma;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "field",
    "name": "usesEmptyNewlineAndIndent",
    "start_line": 217,
    "end_line": 217,
    "code": "private boolean usesEmptyNewlineAndIndent;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "field",
    "name": "strictness",
    "start_line": 219,
    "end_line": 219,
    "code": "private Strictness strictness = Strictness.LEGACY_STRICT;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "field",
    "name": "htmlSafe",
    "start_line": 221,
    "end_line": 221,
    "code": "private boolean htmlSafe;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "field",
    "name": "deferredName",
    "start_line": 223,
    "end_line": 223,
    "code": "private String deferredName;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "field",
    "name": "serializeNulls",
    "start_line": 225,
    "end_line": 225,
    "code": "private boolean serializeNulls = true;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "constructor",
    "name": "JsonWriter",
    "start_line": 232,
    "end_line": 235,
    "code": "/**\r\n * Creates a new instance that writes a JSON-encoded stream to {@code out}. For best performance,\r\n * ensure {@link Writer} is buffered; wrapping in {@link java.io.BufferedWriter BufferedWriter} if\r\n * necessary.\r\n */\r\npublic JsonWriter(Writer out) {\r\n    this.out = Objects.requireNonNull(out, \"out == null\");\r\n    setFormattingStyle(FormattingStyle.COMPACT);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "method",
    "name": "setIndent",
    "start_line": 249,
    "end_line": 255,
    "code": "/**\r\n * Sets the indentation string to be repeated for each level of indentation in the encoded\r\n * document. If {@code indent.isEmpty()} the encoded document will be compact. Otherwise the\r\n * encoded document will be more human-readable.\r\n *\r\n * <p>This is a convenience method which overwrites any previously {@linkplain\r\n * #setFormattingStyle(FormattingStyle) set formatting style} with either {@link\r\n * FormattingStyle#COMPACT} if the given indent string is empty, or {@link FormattingStyle#PRETTY}\r\n * with the given indent if not empty.\r\n *\r\n * @param indent a string containing only whitespace.\r\n */\r\npublic final void setIndent(String indent) {\r\n    if (indent.isEmpty()) {\r\n        setFormattingStyle(FormattingStyle.COMPACT);\r\n    } else {\r\n        setFormattingStyle(FormattingStyle.PRETTY.withIndent(indent));\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "method",
    "name": "setFormattingStyle",
    "start_line": 267,
    "end_line": 284,
    "code": "/**\r\n * Sets the formatting style to be used in the encoded document.\r\n *\r\n * <p>The formatting style specifies for example the indentation string to be repeated for each\r\n * level of indentation, or the newline style, to accommodate various OS styles.\r\n *\r\n * @param formattingStyle the formatting style to use, must not be {@code null}.\r\n * @see #getFormattingStyle()\r\n * @since 2.11.0\r\n */\r\npublic final void setFormattingStyle(FormattingStyle formattingStyle) {\r\n    this.formattingStyle = Objects.requireNonNull(formattingStyle);\r\n    this.formattedComma = \",\";\r\n    if (this.formattingStyle.usesSpaceAfterSeparators()) {\r\n        this.formattedColon = \": \";\r\n        // Only add space if no newline is written\r\n        if (this.formattingStyle.getNewline().isEmpty()) {\r\n            this.formattedComma = \", \";\r\n        }\r\n    } else {\r\n        this.formattedColon = \":\";\r\n    }\r\n    this.usesEmptyNewlineAndIndent = this.formattingStyle.getNewline().isEmpty() && this.formattingStyle.getIndent().isEmpty();\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "method",
    "name": "getFormattingStyle",
    "start_line": 293,
    "end_line": 295,
    "code": "/**\r\n * Returns the pretty printing style used by this writer.\r\n *\r\n * @return the {@code FormattingStyle} that will be used.\r\n * @see #setFormattingStyle(FormattingStyle)\r\n * @since 2.11.0\r\n */\r\npublic final FormattingStyle getFormattingStyle() {\r\n    return formattingStyle;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "method",
    "name": "setLenient",
    "start_line": 310,
    "end_line": 316,
    "code": "/**\r\n * Sets the strictness of this writer.\r\n *\r\n * @deprecated Please use {@link #setStrictness(Strictness)} instead. {@code\r\n *     JsonWriter.setLenient(true)} should be replaced by {@code\r\n *     JsonWriter.setStrictness(Strictness.LENIENT)} and {@code JsonWriter.setLenient(false)}\r\n *     should be replaced by {@code JsonWriter.setStrictness(Strictness.LEGACY_STRICT)}.<br>\r\n *     However, if you used {@code setLenient(false)} before, you might prefer {@link\r\n *     Strictness#STRICT} now instead.\r\n * @param lenient whether this writer should be lenient. If true, the strictness is set to {@link\r\n *     Strictness#LENIENT}. If false, the strictness is set to {@link Strictness#LEGACY_STRICT}.\r\n * @see #setStrictness(Strictness)\r\n */\r\n@Deprecated\r\n// Don't specify @InlineMe, so caller with `setLenient(false)` becomes aware of new\r\n// Strictness.STRICT\r\n@SuppressWarnings(\"InlineMeSuggester\")\r\npublic final void setLenient(boolean lenient) {\r\n    setStrictness(lenient ? Strictness.LENIENT : Strictness.LEGACY_STRICT);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "method",
    "name": "isLenient",
    "start_line": 323,
    "end_line": 325,
    "code": "/**\r\n * Returns true if the {@link Strictness} of this writer is equal to {@link Strictness#LENIENT}.\r\n *\r\n * @see #getStrictness()\r\n */\r\npublic boolean isLenient() {\r\n    return strictness == Strictness.LENIENT;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "method",
    "name": "setStrictness",
    "start_line": 346,
    "end_line": 348,
    "code": "/**\r\n * Configures how strict this writer is with regard to the syntax rules specified in <a\r\n * href=\"https://www.ietf.org/rfc/rfc8259.txt\">RFC 8259</a>. By default, {@link\r\n * Strictness#LEGACY_STRICT} is used.\r\n *\r\n * <dl>\r\n *   <dt>{@link Strictness#STRICT} &amp; {@link Strictness#LEGACY_STRICT}\r\n *   <dd>The behavior of these is currently identical. In these strictness modes, the writer only\r\n *       writes JSON in accordance with RFC 8259.\r\n *   <dt>{@link Strictness#LENIENT}\r\n *   <dd>This mode relaxes the behavior of the writer to allow the writing of {@link\r\n *       Double#isNaN() NaNs} and {@link Double#isInfinite() infinities}. It also allows writing\r\n *       multiple top level values.\r\n * </dl>\r\n *\r\n * @param strictness the new strictness of this writer. May not be {@code null}.\r\n * @see #getStrictness()\r\n * @since 2.11.0\r\n */\r\npublic final void setStrictness(Strictness strictness) {\r\n    this.strictness = Objects.requireNonNull(strictness);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "method",
    "name": "getStrictness",
    "start_line": 356,
    "end_line": 358,
    "code": "/**\r\n * Returns the {@linkplain Strictness strictness} of this writer.\r\n *\r\n * @see #setStrictness(Strictness)\r\n * @since 2.11.0\r\n */\r\npublic final Strictness getStrictness() {\r\n    return strictness;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "method",
    "name": "setHtmlSafe",
    "start_line": 368,
    "end_line": 370,
    "code": "/**\r\n * Configures this writer to emit JSON that's safe for direct inclusion in HTML and XML documents.\r\n * This escapes the HTML characters {@code <}, {@code >}, {@code &}, {@code =} and {@code '}\r\n * before writing them to the stream. Without this setting, your XML/HTML encoder should replace\r\n * these characters with the corresponding escape sequences.\r\n *\r\n * @see #isHtmlSafe()\r\n */\r\npublic final void setHtmlSafe(boolean htmlSafe) {\r\n    this.htmlSafe = htmlSafe;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "method",
    "name": "isHtmlSafe",
    "start_line": 377,
    "end_line": 379,
    "code": "/**\r\n * Returns true if this writer writes JSON that's safe for inclusion in HTML and XML documents.\r\n *\r\n * @see #setHtmlSafe(boolean)\r\n */\r\npublic final boolean isHtmlSafe() {\r\n    return htmlSafe;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "method",
    "name": "setSerializeNulls",
    "start_line": 387,
    "end_line": 389,
    "code": "/**\r\n * Sets whether object members are serialized when their value is null. This has no impact on\r\n * array elements. The default is true.\r\n *\r\n * @see #getSerializeNulls()\r\n */\r\npublic final void setSerializeNulls(boolean serializeNulls) {\r\n    this.serializeNulls = serializeNulls;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "method",
    "name": "getSerializeNulls",
    "start_line": 397,
    "end_line": 399,
    "code": "/**\r\n * Returns true if object members are serialized when their value is null. This has no impact on\r\n * array elements. The default is true.\r\n *\r\n * @see #setSerializeNulls(boolean)\r\n */\r\npublic final boolean getSerializeNulls() {\r\n    return serializeNulls;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "method",
    "name": "beginArray",
    "start_line": 407,
    "end_line": 411,
    "code": "/**\r\n * Begins encoding a new array. Each call to this method must be paired with a call to {@link\r\n * #endArray}.\r\n *\r\n * @return this writer.\r\n */\r\n@CanIgnoreReturnValue\r\npublic JsonWriter beginArray() throws IOException {\r\n    writeDeferredName();\r\n    return openScope(EMPTY_ARRAY, '[');\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "method",
    "name": "endArray",
    "start_line": 418,
    "end_line": 421,
    "code": "/**\r\n * Ends encoding the current array.\r\n *\r\n * @return this writer.\r\n */\r\n@CanIgnoreReturnValue\r\npublic JsonWriter endArray() throws IOException {\r\n    return closeScope(EMPTY_ARRAY, NONEMPTY_ARRAY, ']');\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "method",
    "name": "beginObject",
    "start_line": 429,
    "end_line": 433,
    "code": "/**\r\n * Begins encoding a new object. Each call to this method must be paired with a call to {@link\r\n * #endObject}.\r\n *\r\n * @return this writer.\r\n */\r\n@CanIgnoreReturnValue\r\npublic JsonWriter beginObject() throws IOException {\r\n    writeDeferredName();\r\n    return openScope(EMPTY_OBJECT, '{');\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "method",
    "name": "endObject",
    "start_line": 440,
    "end_line": 443,
    "code": "/**\r\n * Ends encoding the current object.\r\n *\r\n * @return this writer.\r\n */\r\n@CanIgnoreReturnValue\r\npublic JsonWriter endObject() throws IOException {\r\n    return closeScope(EMPTY_OBJECT, NONEMPTY_OBJECT, '}');\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "method",
    "name": "openScope",
    "start_line": 446,
    "end_line": 452,
    "code": "/**\r\n * Enters a new scope by appending any necessary whitespace and the given bracket.\r\n */\r\n@CanIgnoreReturnValue\r\nprivate JsonWriter openScope(int empty, char openBracket) throws IOException {\r\n    beforeValue();\r\n    push(empty);\r\n    out.write(openBracket);\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "method",
    "name": "closeScope",
    "start_line": 455,
    "end_line": 471,
    "code": "/**\r\n * Closes the current scope by appending any necessary whitespace and the given bracket.\r\n */\r\n@CanIgnoreReturnValue\r\nprivate JsonWriter closeScope(int empty, int nonempty, char closeBracket) throws IOException {\r\n    int context = peek();\r\n    if (context != nonempty && context != empty) {\r\n        throw new IllegalStateException(\"Nesting problem.\");\r\n    }\r\n    if (deferredName != null) {\r\n        throw new IllegalStateException(\"Dangling name: \" + deferredName);\r\n    }\r\n    stackSize--;\r\n    if (context == nonempty) {\r\n        newline();\r\n    }\r\n    out.write(closeBracket);\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "method",
    "name": "push",
    "start_line": 473,
    "end_line": 478,
    "code": "private void push(int newTop) {\r\n    if (stackSize == stack.length) {\r\n        stack = Arrays.copyOf(stack, stackSize * 2);\r\n    }\r\n    stack[stackSize++] = newTop;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "method",
    "name": "peek",
    "start_line": 481,
    "end_line": 486,
    "code": "/**\r\n * Returns the value on the top of the stack.\r\n */\r\nprivate int peek() {\r\n    if (stackSize == 0) {\r\n        throw new IllegalStateException(\"JsonWriter is closed.\");\r\n    }\r\n    return stack[stackSize - 1];\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "method",
    "name": "replaceTop",
    "start_line": 489,
    "end_line": 491,
    "code": "/**\r\n * Replace the value on the top of the stack with the given value.\r\n */\r\nprivate void replaceTop(int topOfStack) {\r\n    stack[stackSize - 1] = topOfStack;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "method",
    "name": "name",
    "start_line": 499,
    "end_line": 511,
    "code": "/**\r\n * Encodes the property name.\r\n *\r\n * @param name the name of the forthcoming value. May not be {@code null}.\r\n * @return this writer.\r\n */\r\n@CanIgnoreReturnValue\r\npublic JsonWriter name(String name) throws IOException {\r\n    Objects.requireNonNull(name, \"name == null\");\r\n    if (deferredName != null) {\r\n        throw new IllegalStateException(\"Already wrote a name, expecting a value.\");\r\n    }\r\n    int context = peek();\r\n    if (context != EMPTY_OBJECT && context != NONEMPTY_OBJECT) {\r\n        throw new IllegalStateException(\"Please begin an object before writing a name.\");\r\n    }\r\n    deferredName = name;\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "method",
    "name": "writeDeferredName",
    "start_line": 513,
    "end_line": 519,
    "code": "private void writeDeferredName() throws IOException {\r\n    if (deferredName != null) {\r\n        beforeName();\r\n        string(deferredName);\r\n        deferredName = null;\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "method",
    "name": "value",
    "start_line": 527,
    "end_line": 536,
    "code": "/**\r\n * Encodes {@code value}.\r\n *\r\n * @param value the literal string value, or null to encode a null literal.\r\n * @return this writer.\r\n */\r\n@CanIgnoreReturnValue\r\npublic JsonWriter value(String value) throws IOException {\r\n    if (value == null) {\r\n        return nullValue();\r\n    }\r\n    writeDeferredName();\r\n    beforeValue();\r\n    string(value);\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "method",
    "name": "value",
    "start_line": 543,
    "end_line": 549,
    "code": "/**\r\n * Encodes {@code value}.\r\n *\r\n * @return this writer.\r\n */\r\n@CanIgnoreReturnValue\r\npublic JsonWriter value(boolean value) throws IOException {\r\n    writeDeferredName();\r\n    beforeValue();\r\n    out.write(value ? \"true\" : \"false\");\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "method",
    "name": "value",
    "start_line": 557,
    "end_line": 566,
    "code": "/**\r\n * Encodes {@code value}.\r\n *\r\n * @return this writer.\r\n * @since 2.7\r\n */\r\n@CanIgnoreReturnValue\r\npublic JsonWriter value(Boolean value) throws IOException {\r\n    if (value == null) {\r\n        return nullValue();\r\n    }\r\n    writeDeferredName();\r\n    beforeValue();\r\n    out.write(value ? \"true\" : \"false\");\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "method",
    "name": "value",
    "start_line": 578,
    "end_line": 587,
    "code": "/**\r\n * Encodes {@code value}.\r\n *\r\n * @param value a finite value, or if {@link #setStrictness(Strictness) lenient}, also {@link\r\n *     Float#isNaN() NaN} or {@link Float#isInfinite() infinity}.\r\n * @return this writer.\r\n * @throws IllegalArgumentException if the value is NaN or Infinity and this writer is not {@link\r\n *     #setStrictness(Strictness) lenient}.\r\n * @since 2.9.1\r\n */\r\n@CanIgnoreReturnValue\r\npublic JsonWriter value(float value) throws IOException {\r\n    writeDeferredName();\r\n    if (strictness != Strictness.LENIENT && (Float.isNaN(value) || Float.isInfinite(value))) {\r\n        throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\r\n    }\r\n    beforeValue();\r\n    out.append(Float.toString(value));\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "method",
    "name": "value",
    "start_line": 598,
    "end_line": 607,
    "code": "/**\r\n * Encodes {@code value}.\r\n *\r\n * @param value a finite value, or if {@link #setStrictness(Strictness) lenient}, also {@link\r\n *     Double#isNaN() NaN} or {@link Double#isInfinite() infinity}.\r\n * @return this writer.\r\n * @throws IllegalArgumentException if the value is NaN or Infinity and this writer is not {@link\r\n *     #setStrictness(Strictness) lenient}.\r\n */\r\n@CanIgnoreReturnValue\r\npublic JsonWriter value(double value) throws IOException {\r\n    writeDeferredName();\r\n    if (strictness != Strictness.LENIENT && (Double.isNaN(value) || Double.isInfinite(value))) {\r\n        throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\r\n    }\r\n    beforeValue();\r\n    out.append(Double.toString(value));\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "method",
    "name": "value",
    "start_line": 614,
    "end_line": 620,
    "code": "/**\r\n * Encodes {@code value}.\r\n *\r\n * @return this writer.\r\n */\r\n@CanIgnoreReturnValue\r\npublic JsonWriter value(long value) throws IOException {\r\n    writeDeferredName();\r\n    beforeValue();\r\n    out.write(Long.toString(value));\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "method",
    "name": "value",
    "start_line": 633,
    "end_line": 660,
    "code": "/**\r\n * Encodes {@code value}. The value is written by directly writing the {@link Number#toString()}\r\n * result to JSON. Implementations must make sure that the result represents a valid JSON number.\r\n *\r\n * @param value a finite value, or if {@link #setStrictness(Strictness) lenient}, also {@link\r\n *     Double#isNaN() NaN} or {@link Double#isInfinite() infinity}.\r\n * @return this writer.\r\n * @throws IllegalArgumentException if the value is NaN or Infinity and this writer is not {@link\r\n *     #setStrictness(Strictness) lenient}; or if the {@code toString()} result is not a valid\r\n *     JSON number.\r\n */\r\n@CanIgnoreReturnValue\r\npublic JsonWriter value(Number value) throws IOException {\r\n    if (value == null) {\r\n        return nullValue();\r\n    }\r\n    writeDeferredName();\r\n    String string = value.toString();\r\n    Class<? extends Number> numberClass = value.getClass();\r\n    if (!alwaysCreatesValidJsonNumber(numberClass)) {\r\n        // Validate that string is valid before writing it directly to JSON output\r\n        if (string.equals(\"-Infinity\") || string.equals(\"Infinity\") || string.equals(\"NaN\")) {\r\n            if (strictness != Strictness.LENIENT) {\r\n                throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + string);\r\n            }\r\n        } else if (numberClass != Float.class && numberClass != Double.class && !VALID_JSON_NUMBER_PATTERN.matcher(string).matches()) {\r\n            throw new IllegalArgumentException(\"String created by \" + numberClass + \" is not a valid JSON number: \" + string);\r\n        }\r\n    }\r\n    beforeValue();\r\n    out.append(string);\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "method",
    "name": "nullValue",
    "start_line": 667,
    "end_line": 680,
    "code": "/**\r\n * Encodes {@code null}.\r\n *\r\n * @return this writer.\r\n */\r\n@CanIgnoreReturnValue\r\npublic JsonWriter nullValue() throws IOException {\r\n    if (deferredName != null) {\r\n        if (serializeNulls) {\r\n            writeDeferredName();\r\n        } else {\r\n            deferredName = null;\r\n            // skip the name and the value\r\n            return this;\r\n        }\r\n    }\r\n    beforeValue();\r\n    out.write(\"null\");\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "method",
    "name": "jsonValue",
    "start_line": 692,
    "end_line": 701,
    "code": "/**\r\n * Writes {@code value} directly to the writer without quoting or escaping. This might not be\r\n * supported by all implementations, if not supported an {@code UnsupportedOperationException} is\r\n * thrown.\r\n *\r\n * @param value the literal string value, or null to encode a null literal.\r\n * @return this writer.\r\n * @throws UnsupportedOperationException if this writer does not support writing raw JSON values.\r\n * @since 2.4\r\n */\r\n@CanIgnoreReturnValue\r\npublic JsonWriter jsonValue(String value) throws IOException {\r\n    if (value == null) {\r\n        return nullValue();\r\n    }\r\n    writeDeferredName();\r\n    beforeValue();\r\n    out.append(value);\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "method",
    "name": "flush",
    "start_line": 706,
    "end_line": 712,
    "code": "/**\r\n * Ensures all buffered data is written to the underlying {@link Writer} and flushes that writer.\r\n */\r\n@Override\r\npublic void flush() throws IOException {\r\n    if (stackSize == 0) {\r\n        throw new IllegalStateException(\"JsonWriter is closed.\");\r\n    }\r\n    out.flush();\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "method",
    "name": "close",
    "start_line": 719,
    "end_line": 728,
    "code": "/**\r\n * Flushes and closes this writer and the underlying {@link Writer}.\r\n *\r\n * @throws IOException if the JSON document is incomplete.\r\n */\r\n@Override\r\npublic void close() throws IOException {\r\n    out.close();\r\n    int size = stackSize;\r\n    if (size > 1 || (size == 1 && stack[size - 1] != NONEMPTY_DOCUMENT)) {\r\n        throw new IOException(\"Incomplete document\");\r\n    }\r\n    stackSize = 0;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "method",
    "name": "alwaysCreatesValidJsonNumber",
    "start_line": 731,
    "end_line": 742,
    "code": "/**\r\n * Returns whether the {@code toString()} of {@code c} will always return a valid JSON number.\r\n */\r\nprivate static boolean alwaysCreatesValidJsonNumber(Class<? extends Number> c) {\r\n    // Does not include Float or Double because their value can be NaN or Infinity\r\n    // Does not include LazilyParsedNumber because it could contain a malformed string\r\n    return c == Integer.class || c == Long.class || c == Byte.class || c == Short.class || c == BigDecimal.class || c == BigInteger.class || c == AtomicInteger.class || c == AtomicLong.class;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "method",
    "name": "string",
    "start_line": 744,
    "end_line": 774,
    "code": "private void string(String value) throws IOException {\r\n    String[] replacements = htmlSafe ? HTML_SAFE_REPLACEMENT_CHARS : REPLACEMENT_CHARS;\r\n    out.write('\\\"');\r\n    int last = 0;\r\n    int length = value.length();\r\n    for (int i = 0; i < length; i++) {\r\n        char c = value.charAt(i);\r\n        String replacement;\r\n        if (c < 128) {\r\n            replacement = replacements[c];\r\n            if (replacement == null) {\r\n                continue;\r\n            }\r\n        } else if (c == '\\u2028') {\r\n            replacement = \"\\\\u2028\";\r\n        } else if (c == '\\u2029') {\r\n            replacement = \"\\\\u2029\";\r\n        } else {\r\n            continue;\r\n        }\r\n        if (last < i) {\r\n            out.write(value, last, i - last);\r\n        }\r\n        out.write(replacement);\r\n        last = i + 1;\r\n    }\r\n    if (last < length) {\r\n        out.write(value, last, length - last);\r\n    }\r\n    out.write('\\\"');\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "method",
    "name": "newline",
    "start_line": 776,
    "end_line": 785,
    "code": "private void newline() throws IOException {\r\n    if (usesEmptyNewlineAndIndent) {\r\n        return;\r\n    }\r\n    out.write(formattingStyle.getNewline());\r\n    for (int i = 1, size = stackSize; i < size; i++) {\r\n        out.write(formattingStyle.getIndent());\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "method",
    "name": "beforeName",
    "start_line": 791,
    "end_line": 800,
    "code": "/**\r\n * Inserts any necessary separators and whitespace before a name. Also adjusts the stack to expect\r\n * the name's value.\r\n */\r\nprivate void beforeName() throws IOException {\r\n    int context = peek();\r\n    if (context == NONEMPTY_OBJECT) {\r\n        // first in object\r\n        out.write(formattedComma);\r\n    } else if (context != EMPTY_OBJECT) {\r\n        // not in an object!\r\n        throw new IllegalStateException(\"Nesting problem.\");\r\n    }\r\n    newline();\r\n    replaceTop(DANGLING_NAME);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  },
  {
    "type": "method",
    "name": "beforeValue",
    "start_line": 806,
    "end_line": 836,
    "code": "/**\r\n * Inserts any necessary separators and whitespace before a literal value, inline array, or inline\r\n * object. Also adjusts the stack to expect either a closing bracket or another element.\r\n */\r\n@SuppressWarnings(\"fallthrough\")\r\nprivate void beforeValue() throws IOException {\r\n    switch(peek()) {\r\n        case NONEMPTY_DOCUMENT:\r\n            if (strictness != Strictness.LENIENT) {\r\n                throw new IllegalStateException(\"JSON must have only one top-level value.\");\r\n            }\r\n        // fall-through\r\n        case // first in document\r\n        EMPTY_DOCUMENT:\r\n            replaceTop(NONEMPTY_DOCUMENT);\r\n            break;\r\n        case // first in array\r\n        EMPTY_ARRAY:\r\n            replaceTop(NONEMPTY_ARRAY);\r\n            newline();\r\n            break;\r\n        case // another in array\r\n        NONEMPTY_ARRAY:\r\n            out.append(formattedComma);\r\n            newline();\r\n            break;\r\n        case // value for name\r\n        DANGLING_NAME:\r\n            out.append(formattedColon);\r\n            replaceTop(NONEMPTY_OBJECT);\r\n            break;\r\n        default:\r\n            throw new IllegalStateException(\"Nesting problem.\");\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonWriter.java"
  }
]