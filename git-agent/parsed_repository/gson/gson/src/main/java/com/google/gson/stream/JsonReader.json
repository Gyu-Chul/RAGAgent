[
  {
    "type": "package",
    "name": "com.google.gson.stream",
    "start_line": 17,
    "end_line": 17,
    "code": "package com.google.gson.stream;\r\n\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.Gson",
    "start_line": 19,
    "end_line": 19,
    "code": "import com.google.gson.Gson;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.GsonBuilder",
    "start_line": 20,
    "end_line": 20,
    "code": "import com.google.gson.GsonBuilder;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.Strictness",
    "start_line": 21,
    "end_line": 21,
    "code": "import com.google.gson.Strictness;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.TypeAdapter",
    "start_line": 22,
    "end_line": 22,
    "code": "import com.google.gson.TypeAdapter;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.internal.JsonReaderInternalAccess",
    "start_line": 23,
    "end_line": 23,
    "code": "import com.google.gson.internal.JsonReaderInternalAccess;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.internal.TroubleshootingGuide",
    "start_line": 24,
    "end_line": 24,
    "code": "import com.google.gson.internal.TroubleshootingGuide;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.internal.bind.JsonTreeReader",
    "start_line": 25,
    "end_line": 25,
    "code": "import com.google.gson.internal.bind.JsonTreeReader;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "import",
    "name": "java.io.Closeable",
    "start_line": 26,
    "end_line": 26,
    "code": "import java.io.Closeable;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "import",
    "name": "java.io.EOFException",
    "start_line": 27,
    "end_line": 27,
    "code": "import java.io.EOFException;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "import",
    "name": "java.io.IOException",
    "start_line": 28,
    "end_line": 28,
    "code": "import java.io.IOException;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "import",
    "name": "java.io.Reader",
    "start_line": 29,
    "end_line": 29,
    "code": "import java.io.Reader;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "import",
    "name": "java.util.Arrays",
    "start_line": 30,
    "end_line": 30,
    "code": "import java.util.Arrays;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "import",
    "name": "java.util.Objects",
    "start_line": 31,
    "end_line": 31,
    "code": "import java.util.Objects;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "class",
    "name": "JsonReader",
    "start_line": 213,
    "end_line": 1883,
    "code": "/**\r\n * Reads a JSON (<a href=\"https://www.ietf.org/rfc/rfc8259.txt\">RFC 8259</a>) encoded value as a\r\n * stream of tokens. This stream includes both literal values (strings, numbers, booleans, and\r\n * nulls) as well as the begin and end delimiters of objects and arrays. The tokens are traversed in\r\n * depth-first order, the same order that they appear in the JSON document. Within JSON objects,\r\n * name/value pairs are represented by a single token.\r\n *\r\n * <h2>Parsing JSON</h2>\r\n *\r\n * To create a recursive descent parser for your own JSON streams, first create an entry point\r\n * method that creates a {@code JsonReader}.\r\n *\r\n * <p>Next, create handler methods for each structure in your JSON text. You'll need a method for\r\n * each object type and for each array type.\r\n *\r\n * <ul>\r\n *   <li>Within <strong>array handling</strong> methods, first call {@link #beginArray} to consume\r\n *       the array's opening bracket. Then create a while loop that accumulates values, terminating\r\n *       when {@link #hasNext} is false. Finally, read the array's closing bracket by calling {@link\r\n *       #endArray}.\r\n *   <li>Within <strong>object handling</strong> methods, first call {@link #beginObject} to consume\r\n *       the object's opening brace. Then create a while loop that assigns values to local variables\r\n *       based on their name. This loop should terminate when {@link #hasNext} is false. Finally,\r\n *       read the object's closing brace by calling {@link #endObject}.\r\n * </ul>\r\n *\r\n * <p>When a nested object or array is encountered, delegate to the corresponding handler method.\r\n *\r\n * <p>When an unknown name is encountered, strict parsers should fail with an exception. Lenient\r\n * parsers should call {@link #skipValue()} to recursively skip the value's nested tokens, which may\r\n * otherwise conflict.\r\n *\r\n * <p>If a value may be null, you should first check using {@link #peek()}. Null literals can be\r\n * consumed using either {@link #nextNull()} or {@link #skipValue()}.\r\n *\r\n * <h2>Configuration</h2>\r\n *\r\n * The behavior of this reader can be customized with the following methods:\r\n *\r\n * <ul>\r\n *   <li>{@link #setStrictness(Strictness)}, the default is {@link Strictness#LEGACY_STRICT}\r\n *   <li>{@link #setNestingLimit(int)}, the default is {@value #DEFAULT_NESTING_LIMIT}\r\n * </ul>\r\n *\r\n * The default configuration of {@code JsonReader} instances used internally by the {@link Gson}\r\n * class differs, and can be adjusted with the various {@link GsonBuilder} methods.\r\n *\r\n * <h2>Example</h2>\r\n *\r\n * Suppose we'd like to parse a stream of messages such as the following:\r\n *\r\n * <pre>{@code\r\n * [\r\n *   {\r\n *     \"id\": 912345678901,\r\n *     \"text\": \"How do I read a JSON stream in Java?\",\r\n *     \"geo\": null,\r\n *     \"user\": {\r\n *       \"name\": \"json_newb\",\r\n *       \"followers_count\": 41\r\n *      }\r\n *   },\r\n *   {\r\n *     \"id\": 912345678902,\r\n *     \"text\": \"@json_newb just use JsonReader!\",\r\n *     \"geo\": [50.454722, -104.606667],\r\n *     \"user\": {\r\n *       \"name\": \"jesse\",\r\n *       \"followers_count\": 2\r\n *     }\r\n *   }\r\n * ]\r\n * }</pre>\r\n *\r\n * This code implements the parser for the above structure:\r\n *\r\n * <pre>{@code\r\n * public List<Message> readJsonStream(InputStream in) throws IOException {\r\n *   JsonReader reader = new JsonReader(new InputStreamReader(in, \"UTF-8\"));\r\n *   try {\r\n *     return readMessagesArray(reader);\r\n *   } finally {\r\n *     reader.close();\r\n *   }\r\n * }\r\n *\r\n * public List<Message> readMessagesArray(JsonReader reader) throws IOException {\r\n *   List<Message> messages = new ArrayList<>();\r\n *\r\n *   reader.beginArray();\r\n *   while (reader.hasNext()) {\r\n *     messages.add(readMessage(reader));\r\n *   }\r\n *   reader.endArray();\r\n *   return messages;\r\n * }\r\n *\r\n * public Message readMessage(JsonReader reader) throws IOException {\r\n *   long id = -1;\r\n *   String text = null;\r\n *   User user = null;\r\n *   List<Double> geo = null;\r\n *\r\n *   reader.beginObject();\r\n *   while (reader.hasNext()) {\r\n *     String name = reader.nextName();\r\n *     if (name.equals(\"id\")) {\r\n *       id = reader.nextLong();\r\n *     } else if (name.equals(\"text\")) {\r\n *       text = reader.nextString();\r\n *     } else if (name.equals(\"geo\") && reader.peek() != JsonToken.NULL) {\r\n *       geo = readDoublesArray(reader);\r\n *     } else if (name.equals(\"user\")) {\r\n *       user = readUser(reader);\r\n *     } else {\r\n *       reader.skipValue();\r\n *     }\r\n *   }\r\n *   reader.endObject();\r\n *   return new Message(id, text, user, geo);\r\n * }\r\n *\r\n * public List<Double> readDoublesArray(JsonReader reader) throws IOException {\r\n *   List<Double> doubles = new ArrayList<>();\r\n *\r\n *   reader.beginArray();\r\n *   while (reader.hasNext()) {\r\n *     doubles.add(reader.nextDouble());\r\n *   }\r\n *   reader.endArray();\r\n *   return doubles;\r\n * }\r\n *\r\n * public User readUser(JsonReader reader) throws IOException {\r\n *   String username = null;\r\n *   int followersCount = -1;\r\n *\r\n *   reader.beginObject();\r\n *   while (reader.hasNext()) {\r\n *     String name = reader.nextName();\r\n *     if (name.equals(\"name\")) {\r\n *       username = reader.nextString();\r\n *     } else if (name.equals(\"followers_count\")) {\r\n *       followersCount = reader.nextInt();\r\n *     } else {\r\n *       reader.skipValue();\r\n *     }\r\n *   }\r\n *   reader.endObject();\r\n *   return new User(username, followersCount);\r\n * }\r\n * }</pre>\r\n *\r\n * <h2>Number Handling</h2>\r\n *\r\n * This reader permits numeric values to be read as strings and string values to be read as numbers.\r\n * For example, both elements of the JSON array {@code [1, \"1\"]} may be read using either {@link\r\n * #nextInt} or {@link #nextString}. This behavior is intended to prevent lossy numeric conversions:\r\n * double is JavaScript's only numeric type and very large values like {@code 9007199254740993}\r\n * cannot be represented exactly on that platform. To minimize precision loss, extremely large\r\n * values should be written and read as strings in JSON.\r\n *\r\n * <h2 id=\"nonexecuteprefix\">Non-Execute Prefix</h2>\r\n *\r\n * Web servers that serve private data using JSON may be vulnerable to <a\r\n * href=\"http://en.wikipedia.org/wiki/JSON#Cross-site_request_forgery\">Cross-site request\r\n * forgery</a> attacks. In such an attack, a malicious site gains access to a private JSON file by\r\n * executing it with an HTML {@code <script>} tag.\r\n *\r\n * <p>Prefixing JSON files with <code>\")]}'\\n\"</code> makes them non-executable by {@code <script>}\r\n * tags, disarming the attack. Since the prefix is malformed JSON, strict parsing fails when it is\r\n * encountered. This class permits the non-execute prefix when {@linkplain\r\n * #setStrictness(Strictness) lenient parsing} is enabled.\r\n *\r\n * <p>Each {@code JsonReader} may be used to read a single JSON stream. Instances of this class are\r\n * not thread safe.\r\n *\r\n * @author Jesse Wilson\r\n * @since 1.6\r\n */\r\npublic class JsonReader implements Closeable {\r\n\r\n    private static final long MIN_INCOMPLETE_INTEGER = Long.MIN_VALUE / 10;\r\n\r\n    private static final int PEEKED_NONE = 0;\r\n\r\n    private static final int PEEKED_BEGIN_OBJECT = 1;\r\n\r\n    private static final int PEEKED_END_OBJECT = 2;\r\n\r\n    private static final int PEEKED_BEGIN_ARRAY = 3;\r\n\r\n    private static final int PEEKED_END_ARRAY = 4;\r\n\r\n    private static final int PEEKED_TRUE = 5;\r\n\r\n    private static final int PEEKED_FALSE = 6;\r\n\r\n    private static final int PEEKED_NULL = 7;\r\n\r\n    private static final int PEEKED_SINGLE_QUOTED = 8;\r\n\r\n    private static final int PEEKED_DOUBLE_QUOTED = 9;\r\n\r\n    private static final int PEEKED_UNQUOTED = 10;\r\n\r\n    /**\r\n     * When this is returned, the string value is stored in peekedString.\r\n     */\r\n    private static final int PEEKED_BUFFERED = 11;\r\n\r\n    private static final int PEEKED_SINGLE_QUOTED_NAME = 12;\r\n\r\n    private static final int PEEKED_DOUBLE_QUOTED_NAME = 13;\r\n\r\n    private static final int PEEKED_UNQUOTED_NAME = 14;\r\n\r\n    /**\r\n     * When this is returned, the integer value is stored in peekedLong.\r\n     */\r\n    private static final int PEEKED_LONG = 15;\r\n\r\n    private static final int PEEKED_NUMBER = 16;\r\n\r\n    private static final int PEEKED_EOF = 17;\r\n\r\n    /* State machine when parsing numbers */\r\n    private static final int NUMBER_CHAR_NONE = 0;\r\n\r\n    private static final int NUMBER_CHAR_SIGN = 1;\r\n\r\n    private static final int NUMBER_CHAR_DIGIT = 2;\r\n\r\n    private static final int NUMBER_CHAR_DECIMAL = 3;\r\n\r\n    private static final int NUMBER_CHAR_FRACTION_DIGIT = 4;\r\n\r\n    private static final int NUMBER_CHAR_EXP_E = 5;\r\n\r\n    private static final int NUMBER_CHAR_EXP_SIGN = 6;\r\n\r\n    private static final int NUMBER_CHAR_EXP_DIGIT = 7;\r\n\r\n    /**\r\n     * The input JSON.\r\n     */\r\n    private final Reader in;\r\n\r\n    private Strictness strictness = Strictness.LEGACY_STRICT;\r\n\r\n    // Default nesting limit is based on\r\n    // https://github.com/square/moshi/blob/parent-1.15.0/moshi/src/main/java/com/squareup/moshi/JsonReader.java#L228-L230\r\n    static final int DEFAULT_NESTING_LIMIT = 255;\r\n\r\n    private int nestingLimit = DEFAULT_NESTING_LIMIT;\r\n\r\n    static final int BUFFER_SIZE = 1024;\r\n\r\n    /**\r\n     * Use a manual buffer to easily read and unread upcoming characters, and also so we can create\r\n     * strings without an intermediate StringBuilder. We decode literals directly out of this buffer,\r\n     * so it must be at least as long as the longest token that can be reported as a number.\r\n     */\r\n    private final char[] buffer = new char[BUFFER_SIZE];\r\n\r\n    private int pos = 0;\r\n\r\n    private int limit = 0;\r\n\r\n    private int lineNumber = 0;\r\n\r\n    private int lineStart = 0;\r\n\r\n    int peeked = PEEKED_NONE;\r\n\r\n    /**\r\n     * A peeked value that was composed entirely of digits with an optional leading dash. Positive\r\n     * values may not have a leading 0.\r\n     */\r\n    private long peekedLong;\r\n\r\n    /**\r\n     * The number of characters in a peeked number literal. Increment 'pos' by this after reading a\r\n     * number.\r\n     */\r\n    private int peekedNumberLength;\r\n\r\n    /**\r\n     * A peeked string that should be parsed on the next double, long or string. This is populated\r\n     * before a numeric value is parsed and used if that parsing fails.\r\n     */\r\n    private String peekedString;\r\n\r\n    /**\r\n     * The nesting stack. Using a manual array rather than an ArrayList saves 20%.\r\n     */\r\n    private int[] stack = new int[32];\r\n\r\n    private int stackSize = 0;\r\n\r\n    {\r\n        stack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\r\n    }\r\n\r\n    /*\r\n   * The path members. It corresponds directly to stack: At indices where the\r\n   * stack contains an object (EMPTY_OBJECT, DANGLING_NAME or NONEMPTY_OBJECT),\r\n   * pathNames contains the name at this scope. Where it contains an array\r\n   * (EMPTY_ARRAY, NONEMPTY_ARRAY) pathIndices contains the current index in\r\n   * that array. Otherwise the value is undefined, and we take advantage of that\r\n   * by incrementing pathIndices when doing so isn't useful.\r\n   */\r\n    private String[] pathNames = new String[32];\r\n\r\n    private int[] pathIndices = new int[32];\r\n\r\n    /**\r\n     * Creates a new instance that reads a JSON-encoded stream from {@code in}.\r\n     */\r\n    public JsonReader(Reader in) {\r\n        this.in = Objects.requireNonNull(in, \"in == null\");\r\n    }\r\n\r\n    /**\r\n     * Sets the strictness of this reader.\r\n     *\r\n     * @deprecated Please use {@link #setStrictness(Strictness)} instead. {@code\r\n     *     JsonReader.setLenient(true)} should be replaced by {@code\r\n     *     JsonReader.setStrictness(Strictness.LENIENT)} and {@code JsonReader.setLenient(false)}\r\n     *     should be replaced by {@code JsonReader.setStrictness(Strictness.LEGACY_STRICT)}.<br>\r\n     *     However, if you used {@code setLenient(false)} before, you might prefer {@link\r\n     *     Strictness#STRICT} now instead.\r\n     * @param lenient whether this reader should be lenient. If true, the strictness is set to {@link\r\n     *     Strictness#LENIENT}. If false, the strictness is set to {@link Strictness#LEGACY_STRICT}.\r\n     * @see #setStrictness(Strictness)\r\n     */\r\n    @Deprecated\r\n    // Don't specify @InlineMe, so caller with `setLenient(false)` becomes aware of new\r\n    // Strictness.STRICT\r\n    @SuppressWarnings(\"InlineMeSuggester\")\r\n    public final void setLenient(boolean lenient) {\r\n        setStrictness(lenient ? Strictness.LENIENT : Strictness.LEGACY_STRICT);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the {@link Strictness} of this reader is equal to {@link Strictness#LENIENT}.\r\n     *\r\n     * @see #getStrictness()\r\n     */\r\n    public final boolean isLenient() {\r\n        return strictness == Strictness.LENIENT;\r\n    }\r\n\r\n    /**\r\n     * Configures how liberal this parser is in what it accepts.\r\n     *\r\n     * <p>In {@linkplain Strictness#STRICT strict} mode, the parser only accepts JSON in accordance\r\n     * with <a href=\"https://www.ietf.org/rfc/rfc8259.txt\">RFC 8259</a>. In {@linkplain\r\n     * Strictness#LEGACY_STRICT legacy strict} mode (the default), only JSON in accordance with the\r\n     * RFC 8259 is accepted, with a few exceptions denoted below for backwards compatibility reasons.\r\n     * In {@linkplain Strictness#LENIENT lenient} mode, all sort of non-spec compliant JSON is\r\n     * accepted (see below).\r\n     *\r\n     * <dl>\r\n     *   <dt>{@link Strictness#STRICT}\r\n     *   <dd>In strict mode, only input compliant with RFC 8259 is accepted.\r\n     *   <dt>{@link Strictness#LEGACY_STRICT}\r\n     *   <dd>In legacy strict mode, the following departures from RFC 8259 are accepted:\r\n     *       <ul>\r\n     *         <li>JsonReader allows the literals {@code true}, {@code false} and {@code null} to have\r\n     *             any capitalization, for example {@code fAlSe} or {@code NULL}\r\n     *         <li>JsonReader supports the escape sequence {@code \\'}, representing a {@code '}\r\n     *             (single-quote)\r\n     *         <li>JsonReader supports the escape sequence <code>\\<i>LF</i></code> (with {@code LF}\r\n     *             being the Unicode character {@code U+000A}), resulting in a {@code LF} within the\r\n     *             read JSON string\r\n     *         <li>JsonReader allows unescaped control characters ({@code U+0000} through {@code\r\n     *             U+001F})\r\n     *       </ul>\r\n     *   <dt>{@link Strictness#LENIENT}\r\n     *   <dd>In lenient mode, all input that is accepted in legacy strict mode is accepted in addition\r\n     *       to the following departures from RFC 8259:\r\n     *       <ul>\r\n     *         <li>Streams that start with the <a href=\"#nonexecuteprefix\">non-execute prefix</a>,\r\n     *             {@code \")]}'\\n\"}\r\n     *         <li>Streams that include multiple top-level values. With legacy strict or strict\r\n     *             parsing, each stream must contain exactly one top-level value.\r\n     *         <li>Numbers may be {@link Double#isNaN() NaNs} or {@link Double#isInfinite()\r\n     *             infinities} represented by {@code NaN} and {@code (-)Infinity} respectively.\r\n     *         <li>End of line comments starting with {@code //} or {@code #} and ending with a\r\n     *             newline character.\r\n     *         <li>C-style comments starting with {@code /*} and ending with {@code *}{@code /}. Such\r\n     *             comments may not be nested.\r\n     *         <li>Names that are unquoted or {@code 'single quoted'}.\r\n     *         <li>Strings that are unquoted or {@code 'single quoted'}.\r\n     *         <li>Array elements separated by {@code ;} instead of {@code ,}.\r\n     *         <li>Unnecessary array separators. These are interpreted as if null was the omitted\r\n     *             value.\r\n     *         <li>Names and values separated by {@code =} or {@code =>} instead of {@code :}.\r\n     *         <li>Name/value pairs separated by {@code ;} instead of {@code ,}.\r\n     *       </ul>\r\n     * </dl>\r\n     *\r\n     * @param strictness the new strictness value of this reader. May not be {@code null}.\r\n     * @see #getStrictness()\r\n     * @since 2.11.0\r\n     */\r\n    public final void setStrictness(Strictness strictness) {\r\n        Objects.requireNonNull(strictness);\r\n        this.strictness = strictness;\r\n    }\r\n\r\n    /**\r\n     * Returns the {@linkplain Strictness strictness} of this reader.\r\n     *\r\n     * @see #setStrictness(Strictness)\r\n     * @since 2.11.0\r\n     */\r\n    public final Strictness getStrictness() {\r\n        return strictness;\r\n    }\r\n\r\n    /**\r\n     * Sets the nesting limit of this reader.\r\n     *\r\n     * <p>The nesting limit defines how many JSON arrays or objects may be open at the same time. For\r\n     * example a nesting limit of 0 means no arrays or objects may be opened at all, a nesting limit\r\n     * of 1 means one array or object may be open at the same time, and so on. So a nesting limit of 3\r\n     * allows reading the JSON data <code>[{\"a\":[true]}]</code>, but for a nesting limit of 2 it would\r\n     * fail at the inner {@code [true]}.\r\n     *\r\n     * <p>The nesting limit can help to protect against a {@link StackOverflowError} when recursive\r\n     * {@link TypeAdapter} implementations process deeply nested JSON data.\r\n     *\r\n     * <p>The default nesting limit is {@value #DEFAULT_NESTING_LIMIT}.\r\n     *\r\n     * @throws IllegalArgumentException if the nesting limit is negative.\r\n     * @since 2.12.0\r\n     * @see #getNestingLimit()\r\n     */\r\n    public final void setNestingLimit(int limit) {\r\n        if (limit < 0) {\r\n            throw new IllegalArgumentException(\"Invalid nesting limit: \" + limit);\r\n        }\r\n        this.nestingLimit = limit;\r\n    }\r\n\r\n    /**\r\n     * Returns the nesting limit of this reader.\r\n     *\r\n     * @since 2.12.0\r\n     * @see #setNestingLimit(int)\r\n     */\r\n    public final int getNestingLimit() {\r\n        return nestingLimit;\r\n    }\r\n\r\n    /**\r\n     * Consumes the next token from the JSON stream and asserts that it is the beginning of a new\r\n     * array.\r\n     *\r\n     * @throws IllegalStateException if the next token is not the beginning of an array.\r\n     */\r\n    public void beginArray() throws IOException {\r\n        int p = peeked;\r\n        if (p == PEEKED_NONE) {\r\n            p = doPeek();\r\n        }\r\n        if (p == PEEKED_BEGIN_ARRAY) {\r\n            push(JsonScope.EMPTY_ARRAY);\r\n            pathIndices[stackSize - 1] = 0;\r\n            peeked = PEEKED_NONE;\r\n        } else {\r\n            throw unexpectedTokenError(\"BEGIN_ARRAY\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Consumes the next token from the JSON stream and asserts that it is the end of the current\r\n     * array.\r\n     *\r\n     * @throws IllegalStateException if the next token is not the end of an array.\r\n     */\r\n    public void endArray() throws IOException {\r\n        int p = peeked;\r\n        if (p == PEEKED_NONE) {\r\n            p = doPeek();\r\n        }\r\n        if (p == PEEKED_END_ARRAY) {\r\n            stackSize--;\r\n            pathIndices[stackSize - 1]++;\r\n            peeked = PEEKED_NONE;\r\n        } else {\r\n            throw unexpectedTokenError(\"END_ARRAY\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Consumes the next token from the JSON stream and asserts that it is the beginning of a new\r\n     * object.\r\n     *\r\n     * @throws IllegalStateException if the next token is not the beginning of an object.\r\n     */\r\n    public void beginObject() throws IOException {\r\n        int p = peeked;\r\n        if (p == PEEKED_NONE) {\r\n            p = doPeek();\r\n        }\r\n        if (p == PEEKED_BEGIN_OBJECT) {\r\n            push(JsonScope.EMPTY_OBJECT);\r\n            peeked = PEEKED_NONE;\r\n        } else {\r\n            throw unexpectedTokenError(\"BEGIN_OBJECT\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Consumes the next token from the JSON stream and asserts that it is the end of the current\r\n     * object.\r\n     *\r\n     * @throws IllegalStateException if the next token is not the end of an object.\r\n     */\r\n    public void endObject() throws IOException {\r\n        int p = peeked;\r\n        if (p == PEEKED_NONE) {\r\n            p = doPeek();\r\n        }\r\n        if (p == PEEKED_END_OBJECT) {\r\n            stackSize--;\r\n            // Free the last path name so that it can be garbage collected!\r\n            pathNames[stackSize] = null;\r\n            pathIndices[stackSize - 1]++;\r\n            peeked = PEEKED_NONE;\r\n        } else {\r\n            throw unexpectedTokenError(\"END_OBJECT\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if the current array or object has another element.\r\n     */\r\n    public boolean hasNext() throws IOException {\r\n        int p = peeked;\r\n        if (p == PEEKED_NONE) {\r\n            p = doPeek();\r\n        }\r\n        return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY && p != PEEKED_EOF;\r\n    }\r\n\r\n    /**\r\n     * Returns the type of the next token without consuming it.\r\n     */\r\n    public JsonToken peek() throws IOException {\r\n        int p = peeked;\r\n        if (p == PEEKED_NONE) {\r\n            p = doPeek();\r\n        }\r\n        switch(p) {\r\n            case PEEKED_BEGIN_OBJECT:\r\n                return JsonToken.BEGIN_OBJECT;\r\n            case PEEKED_END_OBJECT:\r\n                return JsonToken.END_OBJECT;\r\n            case PEEKED_BEGIN_ARRAY:\r\n                return JsonToken.BEGIN_ARRAY;\r\n            case PEEKED_END_ARRAY:\r\n                return JsonToken.END_ARRAY;\r\n            case PEEKED_SINGLE_QUOTED_NAME:\r\n            case PEEKED_DOUBLE_QUOTED_NAME:\r\n            case PEEKED_UNQUOTED_NAME:\r\n                return JsonToken.NAME;\r\n            case PEEKED_TRUE:\r\n            case PEEKED_FALSE:\r\n                return JsonToken.BOOLEAN;\r\n            case PEEKED_NULL:\r\n                return JsonToken.NULL;\r\n            case PEEKED_SINGLE_QUOTED:\r\n            case PEEKED_DOUBLE_QUOTED:\r\n            case PEEKED_UNQUOTED:\r\n            case PEEKED_BUFFERED:\r\n                return JsonToken.STRING;\r\n            case PEEKED_LONG:\r\n            case PEEKED_NUMBER:\r\n                return JsonToken.NUMBER;\r\n            case PEEKED_EOF:\r\n                return JsonToken.END_DOCUMENT;\r\n            default:\r\n                throw new AssertionError();\r\n        }\r\n    }\r\n\r\n    @SuppressWarnings(\"fallthrough\")\r\n    int doPeek() throws IOException {\r\n        int peekStack = stack[stackSize - 1];\r\n        if (peekStack == JsonScope.EMPTY_ARRAY) {\r\n            stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\r\n        } else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\r\n            // Look for a comma before the next element.\r\n            int c = nextNonWhitespace(true);\r\n            switch(c) {\r\n                case ']':\r\n                    peeked = PEEKED_END_ARRAY;\r\n                    return peeked;\r\n                case ';':\r\n                    // fall-through\r\n                    checkLenient();\r\n                case ',':\r\n                    break;\r\n                default:\r\n                    throw syntaxError(\"Unterminated array\");\r\n            }\r\n        } else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {\r\n            stack[stackSize - 1] = JsonScope.DANGLING_NAME;\r\n            // Look for a comma before the next element.\r\n            if (peekStack == JsonScope.NONEMPTY_OBJECT) {\r\n                int c = nextNonWhitespace(true);\r\n                switch(c) {\r\n                    case '}':\r\n                        peeked = PEEKED_END_OBJECT;\r\n                        return peeked;\r\n                    case ';':\r\n                        // fall-through\r\n                        checkLenient();\r\n                    case ',':\r\n                        break;\r\n                    default:\r\n                        throw syntaxError(\"Unterminated object\");\r\n                }\r\n            }\r\n            int c = nextNonWhitespace(true);\r\n            switch(c) {\r\n                case '\"':\r\n                    peeked = PEEKED_DOUBLE_QUOTED_NAME;\r\n                    return peeked;\r\n                case '\\'':\r\n                    checkLenient();\r\n                    peeked = PEEKED_SINGLE_QUOTED_NAME;\r\n                    return peeked;\r\n                case '}':\r\n                    if (peekStack != JsonScope.NONEMPTY_OBJECT) {\r\n                        peeked = PEEKED_END_OBJECT;\r\n                        return peeked;\r\n                    } else {\r\n                        throw syntaxError(\"Expected name\");\r\n                    }\r\n                default:\r\n                    checkLenient();\r\n                    // Don't consume the first character in an unquoted string.\r\n                    pos--;\r\n                    if (isLiteral((char) c)) {\r\n                        peeked = PEEKED_UNQUOTED_NAME;\r\n                        return peeked;\r\n                    } else {\r\n                        throw syntaxError(\"Expected name\");\r\n                    }\r\n            }\r\n        } else if (peekStack == JsonScope.DANGLING_NAME) {\r\n            stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;\r\n            // Look for a colon before the value.\r\n            int c = nextNonWhitespace(true);\r\n            switch(c) {\r\n                case ':':\r\n                    break;\r\n                case '=':\r\n                    checkLenient();\r\n                    if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') {\r\n                        pos++;\r\n                    }\r\n                    break;\r\n                default:\r\n                    throw syntaxError(\"Expected ':'\");\r\n            }\r\n        } else if (peekStack == JsonScope.EMPTY_DOCUMENT) {\r\n            if (strictness == Strictness.LENIENT) {\r\n                consumeNonExecutePrefix();\r\n            }\r\n            stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;\r\n        } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) {\r\n            int c = nextNonWhitespace(false);\r\n            if (c == -1) {\r\n                peeked = PEEKED_EOF;\r\n                return peeked;\r\n            } else {\r\n                checkLenient();\r\n                pos--;\r\n            }\r\n        } else if (peekStack == JsonScope.CLOSED) {\r\n            throw new IllegalStateException(\"JsonReader is closed\");\r\n        }\r\n        int c = nextNonWhitespace(true);\r\n        switch(c) {\r\n            case ']':\r\n                if (peekStack == JsonScope.EMPTY_ARRAY) {\r\n                    peeked = PEEKED_END_ARRAY;\r\n                    return peeked;\r\n                }\r\n            // fall-through to handle \",]\"\r\n            case ';':\r\n            case ',':\r\n                // In lenient mode, a 0-length literal in an array means 'null'.\r\n                if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) {\r\n                    checkLenient();\r\n                    pos--;\r\n                    peeked = PEEKED_NULL;\r\n                    return peeked;\r\n                } else {\r\n                    throw syntaxError(\"Unexpected value\");\r\n                }\r\n            case '\\'':\r\n                checkLenient();\r\n                peeked = PEEKED_SINGLE_QUOTED;\r\n                return peeked;\r\n            case '\"':\r\n                peeked = PEEKED_DOUBLE_QUOTED;\r\n                return peeked;\r\n            case '[':\r\n                peeked = PEEKED_BEGIN_ARRAY;\r\n                return peeked;\r\n            case '{':\r\n                peeked = PEEKED_BEGIN_OBJECT;\r\n                return peeked;\r\n            default:\r\n                // Don't consume the first character in a literal value.\r\n                pos--;\r\n        }\r\n        int result = peekKeyword();\r\n        if (result != PEEKED_NONE) {\r\n            return result;\r\n        }\r\n        result = peekNumber();\r\n        if (result != PEEKED_NONE) {\r\n            return result;\r\n        }\r\n        if (!isLiteral(buffer[pos])) {\r\n            throw syntaxError(\"Expected value\");\r\n        }\r\n        checkLenient();\r\n        peeked = PEEKED_UNQUOTED;\r\n        return peeked;\r\n    }\r\n\r\n    private int peekKeyword() throws IOException {\r\n        // Figure out which keyword we're matching against by its first character.\r\n        char c = buffer[pos];\r\n        String keyword;\r\n        String keywordUpper;\r\n        int peeking;\r\n        // Look at the first letter to determine what keyword we are trying to match.\r\n        if (c == 't' || c == 'T') {\r\n            keyword = \"true\";\r\n            keywordUpper = \"TRUE\";\r\n            peeking = PEEKED_TRUE;\r\n        } else if (c == 'f' || c == 'F') {\r\n            keyword = \"false\";\r\n            keywordUpper = \"FALSE\";\r\n            peeking = PEEKED_FALSE;\r\n        } else if (c == 'n' || c == 'N') {\r\n            keyword = \"null\";\r\n            keywordUpper = \"NULL\";\r\n            peeking = PEEKED_NULL;\r\n        } else {\r\n            return PEEKED_NONE;\r\n        }\r\n        // Uppercased keywords are not allowed in STRICT mode\r\n        boolean allowsUpperCased = strictness != Strictness.STRICT;\r\n        // Confirm that chars [0..length) match the keyword.\r\n        int length = keyword.length();\r\n        for (int i = 0; i < length; i++) {\r\n            if (pos + i >= limit && !fillBuffer(i + 1)) {\r\n                return PEEKED_NONE;\r\n            }\r\n            c = buffer[pos + i];\r\n            boolean matched = c == keyword.charAt(i) || (allowsUpperCased && c == keywordUpper.charAt(i));\r\n            if (!matched) {\r\n                return PEEKED_NONE;\r\n            }\r\n        }\r\n        if ((pos + length < limit || fillBuffer(length + 1)) && isLiteral(buffer[pos + length])) {\r\n            // Don't match trues, falsey or nullsoft!\r\n            return PEEKED_NONE;\r\n        }\r\n        // We've found the keyword followed either by EOF or by a non-literal character.\r\n        pos += length;\r\n        peeked = peeking;\r\n        return peeked;\r\n    }\r\n\r\n    private int peekNumber() throws IOException {\r\n        // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\r\n        char[] buffer = this.buffer;\r\n        int p = pos;\r\n        int l = limit;\r\n        // Negative to accommodate Long.MIN_VALUE more easily.\r\n        long value = 0;\r\n        boolean negative = false;\r\n        boolean fitsInLong = true;\r\n        int last = NUMBER_CHAR_NONE;\r\n        int i = 0;\r\n        charactersOfNumber: for (; true; i++) {\r\n            if (p + i == l) {\r\n                if (i == buffer.length) {\r\n                    // Though this looks like a well-formed number, it's too long to continue reading. Give up\r\n                    // and let the application handle this as an unquoted literal.\r\n                    return PEEKED_NONE;\r\n                }\r\n                if (!fillBuffer(i + 1)) {\r\n                    break;\r\n                }\r\n                p = pos;\r\n                l = limit;\r\n            }\r\n            char c = buffer[p + i];\r\n            switch(c) {\r\n                case '-':\r\n                    if (last == NUMBER_CHAR_NONE) {\r\n                        negative = true;\r\n                        last = NUMBER_CHAR_SIGN;\r\n                        continue;\r\n                    } else if (last == NUMBER_CHAR_EXP_E) {\r\n                        last = NUMBER_CHAR_EXP_SIGN;\r\n                        continue;\r\n                    }\r\n                    return PEEKED_NONE;\r\n                case '+':\r\n                    if (last == NUMBER_CHAR_EXP_E) {\r\n                        last = NUMBER_CHAR_EXP_SIGN;\r\n                        continue;\r\n                    }\r\n                    return PEEKED_NONE;\r\n                case 'e':\r\n                case 'E':\r\n                    if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\r\n                        last = NUMBER_CHAR_EXP_E;\r\n                        continue;\r\n                    }\r\n                    return PEEKED_NONE;\r\n                case '.':\r\n                    if (last == NUMBER_CHAR_DIGIT) {\r\n                        last = NUMBER_CHAR_DECIMAL;\r\n                        continue;\r\n                    }\r\n                    return PEEKED_NONE;\r\n                default:\r\n                    if (c < '0' || c > '9') {\r\n                        if (!isLiteral(c)) {\r\n                            break charactersOfNumber;\r\n                        }\r\n                        return PEEKED_NONE;\r\n                    }\r\n                    if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\r\n                        value = -(c - '0');\r\n                        last = NUMBER_CHAR_DIGIT;\r\n                    } else if (last == NUMBER_CHAR_DIGIT) {\r\n                        if (value == 0) {\r\n                            // Leading '0' prefix is not allowed (since it could be octal).\r\n                            return PEEKED_NONE;\r\n                        }\r\n                        long newValue = value * 10 - (c - '0');\r\n                        fitsInLong &= value > MIN_INCOMPLETE_INTEGER || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\r\n                        value = newValue;\r\n                    } else if (last == NUMBER_CHAR_DECIMAL) {\r\n                        last = NUMBER_CHAR_FRACTION_DIGIT;\r\n                    } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\r\n                        last = NUMBER_CHAR_EXP_DIGIT;\r\n                    }\r\n            }\r\n        }\r\n        // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\r\n        // Don't store -0 as long; user might want to read it as double -0.0\r\n        // Don't try to convert Long.MIN_VALUE to positive long; it would overflow MAX_VALUE\r\n        if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative) && (value != 0 || !negative)) {\r\n            peekedLong = negative ? value : -value;\r\n            pos += i;\r\n            peeked = PEEKED_LONG;\r\n            return peeked;\r\n        } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT || last == NUMBER_CHAR_EXP_DIGIT) {\r\n            peekedNumberLength = i;\r\n            peeked = PEEKED_NUMBER;\r\n            return peeked;\r\n        } else {\r\n            return PEEKED_NONE;\r\n        }\r\n    }\r\n\r\n    @SuppressWarnings(\"fallthrough\")\r\n    private boolean isLiteral(char c) throws IOException {\r\n        switch(c) {\r\n            case '/':\r\n            case '\\\\':\r\n            case ';':\r\n            case '#':\r\n            case '=':\r\n                // fall-through\r\n                checkLenient();\r\n            case '{':\r\n            case '}':\r\n            case '[':\r\n            case ']':\r\n            case ':':\r\n            case ',':\r\n            case ' ':\r\n            case '\\t':\r\n            case '\\f':\r\n            case '\\r':\r\n            case '\\n':\r\n                return false;\r\n            default:\r\n                return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the next token, a {@link JsonToken#NAME property name}, and consumes it.\r\n     *\r\n     * @throws IllegalStateException if the next token is not a property name.\r\n     */\r\n    public String nextName() throws IOException {\r\n        int p = peeked;\r\n        if (p == PEEKED_NONE) {\r\n            p = doPeek();\r\n        }\r\n        String result;\r\n        if (p == PEEKED_UNQUOTED_NAME) {\r\n            result = nextUnquotedValue();\r\n        } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\r\n            result = nextQuotedValue('\\'');\r\n        } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\r\n            result = nextQuotedValue('\"');\r\n        } else {\r\n            throw unexpectedTokenError(\"a name\");\r\n        }\r\n        peeked = PEEKED_NONE;\r\n        pathNames[stackSize - 1] = result;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns the {@link JsonToken#STRING string} value of the next token, consuming it. If the next\r\n     * token is a number, this method will return its string form.\r\n     *\r\n     * @throws IllegalStateException if the next token is not a string.\r\n     */\r\n    public String nextString() throws IOException {\r\n        int p = peeked;\r\n        if (p == PEEKED_NONE) {\r\n            p = doPeek();\r\n        }\r\n        String result;\r\n        if (p == PEEKED_UNQUOTED) {\r\n            result = nextUnquotedValue();\r\n        } else if (p == PEEKED_SINGLE_QUOTED) {\r\n            result = nextQuotedValue('\\'');\r\n        } else if (p == PEEKED_DOUBLE_QUOTED) {\r\n            result = nextQuotedValue('\"');\r\n        } else if (p == PEEKED_BUFFERED) {\r\n            result = peekedString;\r\n            peekedString = null;\r\n        } else if (p == PEEKED_LONG) {\r\n            result = Long.toString(peekedLong);\r\n        } else if (p == PEEKED_NUMBER) {\r\n            result = new String(buffer, pos, peekedNumberLength);\r\n            pos += peekedNumberLength;\r\n        } else {\r\n            throw unexpectedTokenError(\"a string\");\r\n        }\r\n        peeked = PEEKED_NONE;\r\n        pathIndices[stackSize - 1]++;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token, consuming it.\r\n     *\r\n     * @throws IllegalStateException if the next token is not a boolean.\r\n     */\r\n    public boolean nextBoolean() throws IOException {\r\n        int p = peeked;\r\n        if (p == PEEKED_NONE) {\r\n            p = doPeek();\r\n        }\r\n        if (p == PEEKED_TRUE) {\r\n            peeked = PEEKED_NONE;\r\n            pathIndices[stackSize - 1]++;\r\n            return true;\r\n        } else if (p == PEEKED_FALSE) {\r\n            peeked = PEEKED_NONE;\r\n            pathIndices[stackSize - 1]++;\r\n            return false;\r\n        }\r\n        throw unexpectedTokenError(\"a boolean\");\r\n    }\r\n\r\n    /**\r\n     * Consumes the next token from the JSON stream and asserts that it is a literal null.\r\n     *\r\n     * @throws IllegalStateException if the next token is not a JSON null.\r\n     */\r\n    public void nextNull() throws IOException {\r\n        int p = peeked;\r\n        if (p == PEEKED_NONE) {\r\n            p = doPeek();\r\n        }\r\n        if (p == PEEKED_NULL) {\r\n            peeked = PEEKED_NONE;\r\n            pathIndices[stackSize - 1]++;\r\n        } else {\r\n            throw unexpectedTokenError(\"null\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the {@link JsonToken#NUMBER double} value of the next token, consuming it. If the next\r\n     * token is a string, this method will attempt to parse it as a double using {@link\r\n     * Double#parseDouble(String)}.\r\n     *\r\n     * @throws IllegalStateException if the next token is neither a number nor a string.\r\n     * @throws NumberFormatException if the next literal value cannot be parsed as a double.\r\n     * @throws MalformedJsonException if the next literal value is NaN or Infinity and this reader is\r\n     *     not {@link #setStrictness(Strictness) lenient}.\r\n     */\r\n    public double nextDouble() throws IOException {\r\n        int p = peeked;\r\n        if (p == PEEKED_NONE) {\r\n            p = doPeek();\r\n        }\r\n        if (p == PEEKED_LONG) {\r\n            peeked = PEEKED_NONE;\r\n            pathIndices[stackSize - 1]++;\r\n            return (double) peekedLong;\r\n        }\r\n        if (p == PEEKED_NUMBER) {\r\n            peekedString = new String(buffer, pos, peekedNumberLength);\r\n            pos += peekedNumberLength;\r\n        } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\r\n            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\r\n        } else if (p == PEEKED_UNQUOTED) {\r\n            peekedString = nextUnquotedValue();\r\n        } else if (p != PEEKED_BUFFERED) {\r\n            throw unexpectedTokenError(\"a double\");\r\n        }\r\n        peeked = PEEKED_BUFFERED;\r\n        // don't catch this NumberFormatException.\r\n        double result = Double.parseDouble(peekedString);\r\n        if (strictness != Strictness.LENIENT && (Double.isNaN(result) || Double.isInfinite(result))) {\r\n            throw syntaxError(\"JSON forbids NaN and infinities: \" + result);\r\n        }\r\n        peekedString = null;\r\n        peeked = PEEKED_NONE;\r\n        pathIndices[stackSize - 1]++;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns the {@link JsonToken#NUMBER long} value of the next token, consuming it. If the next\r\n     * token is a string, this method will attempt to parse it as a long. If the next token's numeric\r\n     * value cannot be exactly represented by a Java {@code long}, this method throws.\r\n     *\r\n     * @throws IllegalStateException if the next token is neither a number nor a string.\r\n     * @throws NumberFormatException if the next literal value cannot be parsed as a number, or\r\n     *     exactly represented as a long.\r\n     */\r\n    public long nextLong() throws IOException {\r\n        int p = peeked;\r\n        if (p == PEEKED_NONE) {\r\n            p = doPeek();\r\n        }\r\n        if (p == PEEKED_LONG) {\r\n            peeked = PEEKED_NONE;\r\n            pathIndices[stackSize - 1]++;\r\n            return peekedLong;\r\n        }\r\n        if (p == PEEKED_NUMBER) {\r\n            peekedString = new String(buffer, pos, peekedNumberLength);\r\n            pos += peekedNumberLength;\r\n        } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\r\n            if (p == PEEKED_UNQUOTED) {\r\n                peekedString = nextUnquotedValue();\r\n            } else {\r\n                peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\r\n            }\r\n            try {\r\n                long result = Long.parseLong(peekedString);\r\n                peeked = PEEKED_NONE;\r\n                pathIndices[stackSize - 1]++;\r\n                return result;\r\n            } catch (NumberFormatException ignored) {\r\n                // Fall back to parse as a double below.\r\n            }\r\n        } else {\r\n            throw unexpectedTokenError(\"a long\");\r\n        }\r\n        peeked = PEEKED_BUFFERED;\r\n        // don't catch this NumberFormatException.\r\n        double asDouble = Double.parseDouble(peekedString);\r\n        long result = (long) asDouble;\r\n        if (result != asDouble) {\r\n            // Make sure no precision was lost casting to 'long'.\r\n            throw new NumberFormatException(\"Expected a long but was \" + peekedString + locationString());\r\n        }\r\n        peekedString = null;\r\n        peeked = PEEKED_NONE;\r\n        pathIndices[stackSize - 1]++;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns the string up to but not including {@code quote}, unescaping any character escape\r\n     * sequences encountered along the way. The opening quote should have already been read. This\r\n     * consumes the closing quote, but does not include it in the returned string.\r\n     *\r\n     * @param quote either ' or \".\r\n     */\r\n    private String nextQuotedValue(char quote) throws IOException {\r\n        // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\r\n        char[] buffer = this.buffer;\r\n        StringBuilder builder = null;\r\n        while (true) {\r\n            int p = pos;\r\n            int l = limit;\r\n            /* the index of the first character not yet appended to the builder. */\r\n            int start = p;\r\n            while (p < l) {\r\n                int c = buffer[p++];\r\n                // In strict mode, throw an exception when meeting unescaped control characters (U+0000\r\n                // through U+001F)\r\n                if (strictness == Strictness.STRICT && c < 0x20) {\r\n                    throw syntaxError(\"Unescaped control characters (\\\\u0000-\\\\u001F) are not allowed in strict mode\");\r\n                } else if (c == quote) {\r\n                    pos = p;\r\n                    int len = p - start - 1;\r\n                    if (builder == null) {\r\n                        return new String(buffer, start, len);\r\n                    } else {\r\n                        builder.append(buffer, start, len);\r\n                        return builder.toString();\r\n                    }\r\n                } else if (c == '\\\\') {\r\n                    pos = p;\r\n                    int len = p - start - 1;\r\n                    if (builder == null) {\r\n                        int estimatedLength = (len + 1) * 2;\r\n                        builder = new StringBuilder(Math.max(estimatedLength, 16));\r\n                    }\r\n                    builder.append(buffer, start, len);\r\n                    builder.append(readEscapeCharacter());\r\n                    p = pos;\r\n                    l = limit;\r\n                    start = p;\r\n                } else if (c == '\\n') {\r\n                    lineNumber++;\r\n                    lineStart = p;\r\n                }\r\n            }\r\n            if (builder == null) {\r\n                int estimatedLength = (p - start) * 2;\r\n                builder = new StringBuilder(Math.max(estimatedLength, 16));\r\n            }\r\n            builder.append(buffer, start, p - start);\r\n            pos = p;\r\n            if (!fillBuffer(1)) {\r\n                throw syntaxError(\"Unterminated string\");\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an unquoted value as a string.\r\n     */\r\n    @SuppressWarnings(\"fallthrough\")\r\n    private String nextUnquotedValue() throws IOException {\r\n        StringBuilder builder = null;\r\n        int i = 0;\r\n        findNonLiteralCharacter: while (true) {\r\n            for (; pos + i < limit; i++) {\r\n                switch(buffer[pos + i]) {\r\n                    case '/':\r\n                    case '\\\\':\r\n                    case ';':\r\n                    case '#':\r\n                    case '=':\r\n                        // fall-through\r\n                        checkLenient();\r\n                    case '{':\r\n                    case '}':\r\n                    case '[':\r\n                    case ']':\r\n                    case ':':\r\n                    case ',':\r\n                    case ' ':\r\n                    case '\\t':\r\n                    case '\\f':\r\n                    case '\\r':\r\n                    case '\\n':\r\n                        break findNonLiteralCharacter;\r\n                    default:\r\n                }\r\n            }\r\n            // Attempt to load the entire literal into the buffer at once.\r\n            if (i < buffer.length) {\r\n                if (fillBuffer(i + 1)) {\r\n                    continue;\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n            // use a StringBuilder when the value is too long. This is too long to be a number!\r\n            if (builder == null) {\r\n                builder = new StringBuilder(Math.max(i, 16));\r\n            }\r\n            builder.append(buffer, pos, i);\r\n            pos += i;\r\n            i = 0;\r\n            if (!fillBuffer(1)) {\r\n                break;\r\n            }\r\n        }\r\n        String result = (builder == null) ? new String(buffer, pos, i) : builder.append(buffer, pos, i).toString();\r\n        pos += i;\r\n        return result;\r\n    }\r\n\r\n    private void skipQuotedValue(char quote) throws IOException {\r\n        // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\r\n        char[] buffer = this.buffer;\r\n        do {\r\n            int p = pos;\r\n            int l = limit;\r\n            /* the index of the first character not yet appended to the builder. */\r\n            while (p < l) {\r\n                int c = buffer[p++];\r\n                if (c == quote) {\r\n                    pos = p;\r\n                    return;\r\n                } else if (c == '\\\\') {\r\n                    pos = p;\r\n                    char unused = readEscapeCharacter();\r\n                    p = pos;\r\n                    l = limit;\r\n                } else if (c == '\\n') {\r\n                    lineNumber++;\r\n                    lineStart = p;\r\n                }\r\n            }\r\n            pos = p;\r\n        } while (fillBuffer(1));\r\n        throw syntaxError(\"Unterminated string\");\r\n    }\r\n\r\n    @SuppressWarnings(\"fallthrough\")\r\n    private void skipUnquotedValue() throws IOException {\r\n        do {\r\n            int i = 0;\r\n            for (; pos + i < limit; i++) {\r\n                switch(buffer[pos + i]) {\r\n                    case '/':\r\n                    case '\\\\':\r\n                    case ';':\r\n                    case '#':\r\n                    case '=':\r\n                        // fall-through\r\n                        checkLenient();\r\n                    case '{':\r\n                    case '}':\r\n                    case '[':\r\n                    case ']':\r\n                    case ':':\r\n                    case ',':\r\n                    case ' ':\r\n                    case '\\t':\r\n                    case '\\f':\r\n                    case '\\r':\r\n                    case '\\n':\r\n                        pos += i;\r\n                        return;\r\n                    default:\r\n                }\r\n            }\r\n            pos += i;\r\n        } while (fillBuffer(1));\r\n    }\r\n\r\n    /**\r\n     * Returns the {@link JsonToken#NUMBER int} value of the next token, consuming it. If the next\r\n     * token is a string, this method will attempt to parse it as an int. If the next token's numeric\r\n     * value cannot be exactly represented by a Java {@code int}, this method throws.\r\n     *\r\n     * @throws IllegalStateException if the next token is neither a number nor a string.\r\n     * @throws NumberFormatException if the next literal value cannot be parsed as a number, or\r\n     *     exactly represented as an int.\r\n     */\r\n    public int nextInt() throws IOException {\r\n        int p = peeked;\r\n        if (p == PEEKED_NONE) {\r\n            p = doPeek();\r\n        }\r\n        int result;\r\n        if (p == PEEKED_LONG) {\r\n            result = (int) peekedLong;\r\n            if (peekedLong != result) {\r\n                // Make sure no precision was lost casting to 'int'.\r\n                throw new NumberFormatException(\"Expected an int but was \" + peekedLong + locationString());\r\n            }\r\n            peeked = PEEKED_NONE;\r\n            pathIndices[stackSize - 1]++;\r\n            return result;\r\n        }\r\n        if (p == PEEKED_NUMBER) {\r\n            peekedString = new String(buffer, pos, peekedNumberLength);\r\n            pos += peekedNumberLength;\r\n        } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\r\n            if (p == PEEKED_UNQUOTED) {\r\n                peekedString = nextUnquotedValue();\r\n            } else {\r\n                peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\r\n            }\r\n            try {\r\n                result = Integer.parseInt(peekedString);\r\n                peeked = PEEKED_NONE;\r\n                pathIndices[stackSize - 1]++;\r\n                return result;\r\n            } catch (NumberFormatException ignored) {\r\n                // Fall back to parse as a double below.\r\n            }\r\n        } else {\r\n            throw unexpectedTokenError(\"an int\");\r\n        }\r\n        peeked = PEEKED_BUFFERED;\r\n        // don't catch this NumberFormatException.\r\n        double asDouble = Double.parseDouble(peekedString);\r\n        result = (int) asDouble;\r\n        if (result != asDouble) {\r\n            // Make sure no precision was lost casting to 'int'.\r\n            throw new NumberFormatException(\"Expected an int but was \" + peekedString + locationString());\r\n        }\r\n        peekedString = null;\r\n        peeked = PEEKED_NONE;\r\n        pathIndices[stackSize - 1]++;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Closes this JSON reader and the underlying {@link Reader}.\r\n     *\r\n     * <p>Using the JSON reader after it has been closed will throw an {@link IllegalStateException}\r\n     * in most cases.\r\n     */\r\n    @Override\r\n    public void close() throws IOException {\r\n        peeked = PEEKED_NONE;\r\n        stack[0] = JsonScope.CLOSED;\r\n        stackSize = 1;\r\n        in.close();\r\n    }\r\n\r\n    /**\r\n     * Skips the next value recursively. This method is intended for use when the JSON token stream\r\n     * contains unrecognized or unhandled values.\r\n     *\r\n     * <p>The behavior depends on the type of the next JSON token:\r\n     *\r\n     * <ul>\r\n     *   <li>Start of a JSON array or object: It and all of its nested values are skipped.\r\n     *   <li>Primitive value (for example a JSON number): The primitive value is skipped.\r\n     *   <li>Property name: Only the name but not the value of the property is skipped. {@code\r\n     *       skipValue()} has to be called again to skip the property value as well.\r\n     *   <li>End of a JSON array or object: Only this end token is skipped.\r\n     *   <li>End of JSON document: Skipping has no effect, the next token continues to be the end of\r\n     *       the document.\r\n     * </ul>\r\n     */\r\n    public void skipValue() throws IOException {\r\n        int count = 0;\r\n        do {\r\n            int p = peeked;\r\n            if (p == PEEKED_NONE) {\r\n                p = doPeek();\r\n            }\r\n            switch(p) {\r\n                case PEEKED_BEGIN_ARRAY:\r\n                    push(JsonScope.EMPTY_ARRAY);\r\n                    count++;\r\n                    break;\r\n                case PEEKED_BEGIN_OBJECT:\r\n                    push(JsonScope.EMPTY_OBJECT);\r\n                    count++;\r\n                    break;\r\n                case PEEKED_END_ARRAY:\r\n                    stackSize--;\r\n                    count--;\r\n                    break;\r\n                case PEEKED_END_OBJECT:\r\n                    // Only update when object end is explicitly skipped, otherwise stack is not updated\r\n                    // anyways\r\n                    if (count == 0) {\r\n                        // Free the last path name so that it can be garbage collected\r\n                        pathNames[stackSize - 1] = null;\r\n                    }\r\n                    stackSize--;\r\n                    count--;\r\n                    break;\r\n                case PEEKED_UNQUOTED:\r\n                    skipUnquotedValue();\r\n                    break;\r\n                case PEEKED_SINGLE_QUOTED:\r\n                    skipQuotedValue('\\'');\r\n                    break;\r\n                case PEEKED_DOUBLE_QUOTED:\r\n                    skipQuotedValue('\"');\r\n                    break;\r\n                case PEEKED_UNQUOTED_NAME:\r\n                    skipUnquotedValue();\r\n                    // Only update when name is explicitly skipped, otherwise stack is not updated anyways\r\n                    if (count == 0) {\r\n                        pathNames[stackSize - 1] = \"<skipped>\";\r\n                    }\r\n                    break;\r\n                case PEEKED_SINGLE_QUOTED_NAME:\r\n                    skipQuotedValue('\\'');\r\n                    // Only update when name is explicitly skipped, otherwise stack is not updated anyways\r\n                    if (count == 0) {\r\n                        pathNames[stackSize - 1] = \"<skipped>\";\r\n                    }\r\n                    break;\r\n                case PEEKED_DOUBLE_QUOTED_NAME:\r\n                    skipQuotedValue('\"');\r\n                    // Only update when name is explicitly skipped, otherwise stack is not updated anyways\r\n                    if (count == 0) {\r\n                        pathNames[stackSize - 1] = \"<skipped>\";\r\n                    }\r\n                    break;\r\n                case PEEKED_NUMBER:\r\n                    pos += peekedNumberLength;\r\n                    break;\r\n                case PEEKED_EOF:\r\n                    // Do nothing\r\n                    return;\r\n                default:\r\n            }\r\n            peeked = PEEKED_NONE;\r\n        } while (count > 0);\r\n        pathIndices[stackSize - 1]++;\r\n    }\r\n\r\n    private void push(int newTop) throws MalformedJsonException {\r\n        // - 1 because stack contains as first element either EMPTY_DOCUMENT or NONEMPTY_DOCUMENT\r\n        if (stackSize - 1 >= nestingLimit) {\r\n            throw new MalformedJsonException(\"Nesting limit \" + nestingLimit + \" reached\" + locationString());\r\n        }\r\n        if (stackSize == stack.length) {\r\n            int newLength = stackSize * 2;\r\n            stack = Arrays.copyOf(stack, newLength);\r\n            pathIndices = Arrays.copyOf(pathIndices, newLength);\r\n            pathNames = Arrays.copyOf(pathNames, newLength);\r\n        }\r\n        stack[stackSize++] = newTop;\r\n    }\r\n\r\n    /**\r\n     * Returns true once {@code limit - pos >= minimum}. If the data is exhausted before that many\r\n     * characters are available, this returns false.\r\n     */\r\n    private boolean fillBuffer(int minimum) throws IOException {\r\n        char[] buffer = this.buffer;\r\n        lineStart -= pos;\r\n        if (limit != pos) {\r\n            limit -= pos;\r\n            System.arraycopy(buffer, pos, buffer, 0, limit);\r\n        } else {\r\n            limit = 0;\r\n        }\r\n        pos = 0;\r\n        int total;\r\n        while ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\r\n            limit += total;\r\n            // if this is the first read, consume an optional byte order mark (BOM) if it exists\r\n            if (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\r\n                pos++;\r\n                lineStart++;\r\n                minimum++;\r\n            }\r\n            if (limit >= minimum) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns the next character in the stream that is neither whitespace nor a part of a comment.\r\n     * When this returns, the returned character is always at {@code buffer[pos-1]}; this means the\r\n     * caller can always push back the returned character by decrementing {@code pos}.\r\n     */\r\n    private int nextNonWhitespace(boolean throwOnEof) throws IOException {\r\n        /*\r\n     * This code uses ugly local variables 'p' and 'l' representing the 'pos'\r\n     * and 'limit' fields respectively. Using locals rather than fields saves\r\n     * a few field reads for each whitespace character in a pretty-printed\r\n     * document, resulting in a 5% speedup. We need to flush 'p' to its field\r\n     * before any (potentially indirect) call to fillBuffer() and reread both\r\n     * 'p' and 'l' after any (potentially indirect) call to the same method.\r\n     */\r\n        char[] buffer = this.buffer;\r\n        int p = pos;\r\n        int l = limit;\r\n        while (true) {\r\n            if (p == l) {\r\n                pos = p;\r\n                if (!fillBuffer(1)) {\r\n                    break;\r\n                }\r\n                p = pos;\r\n                l = limit;\r\n            }\r\n            int c = buffer[p++];\r\n            if (c == '\\n') {\r\n                lineNumber++;\r\n                lineStart = p;\r\n                continue;\r\n            } else if (c == ' ' || c == '\\r' || c == '\\t') {\r\n                continue;\r\n            }\r\n            if (c == '/') {\r\n                pos = p;\r\n                if (p == l) {\r\n                    // push back '/' so it's still in the buffer when this method returns\r\n                    pos--;\r\n                    boolean charsLoaded = fillBuffer(2);\r\n                    // consume the '/' again\r\n                    pos++;\r\n                    if (!charsLoaded) {\r\n                        return c;\r\n                    }\r\n                }\r\n                checkLenient();\r\n                char peek = buffer[pos];\r\n                switch(peek) {\r\n                    case '*':\r\n                        // skip a /* c-style comment */\r\n                        pos++;\r\n                        if (!skipTo(\"*/\")) {\r\n                            throw syntaxError(\"Unterminated comment\");\r\n                        }\r\n                        p = pos + 2;\r\n                        l = limit;\r\n                        continue;\r\n                    case '/':\r\n                        // skip a // end-of-line comment\r\n                        pos++;\r\n                        skipToEndOfLine();\r\n                        p = pos;\r\n                        l = limit;\r\n                        continue;\r\n                    default:\r\n                        return c;\r\n                }\r\n            } else if (c == '#') {\r\n                pos = p;\r\n                /*\r\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\r\n         * specify this behaviour, but it's required to parse\r\n         * existing documents. See http://b/2571423.\r\n         */\r\n                checkLenient();\r\n                skipToEndOfLine();\r\n                p = pos;\r\n                l = limit;\r\n            } else {\r\n                pos = p;\r\n                return c;\r\n            }\r\n        }\r\n        if (throwOnEof) {\r\n            throw new EOFException(\"End of input\" + locationString());\r\n        } else {\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    private void checkLenient() throws MalformedJsonException {\r\n        if (strictness != Strictness.LENIENT) {\r\n            throw syntaxError(\"Use JsonReader.setStrictness(Strictness.LENIENT) to accept malformed JSON\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Advances the position until after the next newline character. If the line is terminated by\r\n     * \"\\r\\n\", the '\\n' must be consumed as whitespace by the caller.\r\n     */\r\n    private void skipToEndOfLine() throws IOException {\r\n        while (pos < limit || fillBuffer(1)) {\r\n            char c = buffer[pos++];\r\n            if (c == '\\n') {\r\n                lineNumber++;\r\n                lineStart = pos;\r\n                break;\r\n            } else if (c == '\\r') {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param toFind a string to search for. Must not contain a newline.\r\n     */\r\n    private boolean skipTo(String toFind) throws IOException {\r\n        int length = toFind.length();\r\n        outer: for (; pos + length <= limit || fillBuffer(length); pos++) {\r\n            if (buffer[pos] == '\\n') {\r\n                lineNumber++;\r\n                lineStart = pos + 1;\r\n                continue;\r\n            }\r\n            for (int c = 0; c < length; c++) {\r\n                if (buffer[pos + c] != toFind.charAt(c)) {\r\n                    continue outer;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return getClass().getSimpleName() + locationString();\r\n    }\r\n\r\n    String locationString() {\r\n        int line = lineNumber + 1;\r\n        int column = pos - lineStart + 1;\r\n        return \" at line \" + line + \" column \" + column + \" path \" + getPath();\r\n    }\r\n\r\n    private String getPath(boolean usePreviousPath) {\r\n        StringBuilder result = new StringBuilder().append('$');\r\n        for (int i = 0; i < stackSize; i++) {\r\n            int scope = stack[i];\r\n            switch(scope) {\r\n                case JsonScope.EMPTY_ARRAY:\r\n                case JsonScope.NONEMPTY_ARRAY:\r\n                    int pathIndex = pathIndices[i];\r\n                    // If index is last path element it points to next array element; have to decrement\r\n                    if (usePreviousPath && pathIndex > 0 && i == stackSize - 1) {\r\n                        pathIndex--;\r\n                    }\r\n                    result.append('[').append(pathIndex).append(']');\r\n                    break;\r\n                case JsonScope.EMPTY_OBJECT:\r\n                case JsonScope.DANGLING_NAME:\r\n                case JsonScope.NONEMPTY_OBJECT:\r\n                    result.append('.');\r\n                    if (pathNames[i] != null) {\r\n                        result.append(pathNames[i]);\r\n                    }\r\n                    break;\r\n                case JsonScope.NONEMPTY_DOCUMENT:\r\n                case JsonScope.EMPTY_DOCUMENT:\r\n                case JsonScope.CLOSED:\r\n                    break;\r\n                default:\r\n                    throw new AssertionError(\"Unknown scope value: \" + scope);\r\n            }\r\n        }\r\n        return result.toString();\r\n    }\r\n\r\n    /**\r\n     * Returns a <a href=\"https://goessner.net/articles/JsonPath/\">JSONPath</a> in <i>dot-notation</i>\r\n     * to the next (or current) location in the JSON document. That means:\r\n     *\r\n     * <ul>\r\n     *   <li>For JSON arrays the path points to the index of the next element (even if there are no\r\n     *       further elements).\r\n     *   <li>For JSON objects the path points to the last property, or to the current property if its\r\n     *       name has already been consumed.\r\n     * </ul>\r\n     *\r\n     * <p>This method can be useful to add additional context to exception messages <i>before</i> a\r\n     * value is consumed, for example when the {@linkplain #peek() peeked} token is unexpected.\r\n     */\r\n    public String getPath() {\r\n        return getPath(false);\r\n    }\r\n\r\n    /**\r\n     * Returns a <a href=\"https://goessner.net/articles/JsonPath/\">JSONPath</a> in <i>dot-notation</i>\r\n     * to the previous (or current) location in the JSON document. That means:\r\n     *\r\n     * <ul>\r\n     *   <li>For JSON arrays the path points to the index of the previous element.<br>\r\n     *       If no element has been consumed yet it uses the index 0 (even if there are no elements).\r\n     *   <li>For JSON objects the path points to the last property, or to the current property if its\r\n     *       name has already been consumed.\r\n     * </ul>\r\n     *\r\n     * <p>This method can be useful to add additional context to exception messages <i>after</i> a\r\n     * value has been consumed.\r\n     */\r\n    public String getPreviousPath() {\r\n        return getPath(true);\r\n    }\r\n\r\n    /**\r\n     * Unescapes the character identified by the character or characters that immediately follow a\r\n     * backslash. The backslash '\\' should have already been read. This supports both Unicode escapes\r\n     * \"u000A\" and two-character escapes \"\\n\".\r\n     *\r\n     * @throws MalformedJsonException if the escape sequence is malformed\r\n     */\r\n    @SuppressWarnings(\"fallthrough\")\r\n    private char readEscapeCharacter() throws IOException {\r\n        if (pos == limit && !fillBuffer(1)) {\r\n            throw syntaxError(\"Unterminated escape sequence\");\r\n        }\r\n        char escaped = buffer[pos++];\r\n        switch(escaped) {\r\n            case 'u':\r\n                if (pos + 4 > limit && !fillBuffer(4)) {\r\n                    throw syntaxError(\"Unterminated escape sequence\");\r\n                }\r\n                // Equivalent to Integer.parseInt(stringPool.get(buffer, pos, 4), 16);\r\n                int result = 0;\r\n                for (int i = pos, end = i + 4; i < end; i++) {\r\n                    char c = buffer[i];\r\n                    result <<= 4;\r\n                    if (c >= '0' && c <= '9') {\r\n                        result += (c - '0');\r\n                    } else if (c >= 'a' && c <= 'f') {\r\n                        result += (c - 'a' + 10);\r\n                    } else if (c >= 'A' && c <= 'F') {\r\n                        result += (c - 'A' + 10);\r\n                    } else {\r\n                        throw syntaxError(\"Malformed Unicode escape \\\\u\" + new String(buffer, pos, 4));\r\n                    }\r\n                }\r\n                pos += 4;\r\n                return (char) result;\r\n            case 't':\r\n                return '\\t';\r\n            case 'b':\r\n                return '\\b';\r\n            case 'n':\r\n                return '\\n';\r\n            case 'r':\r\n                return '\\r';\r\n            case 'f':\r\n                return '\\f';\r\n            case '\\n':\r\n                if (strictness == Strictness.STRICT) {\r\n                    throw syntaxError(\"Cannot escape a newline character in strict mode\");\r\n                }\r\n                lineNumber++;\r\n                lineStart = pos;\r\n            // fall-through\r\n            case '\\'':\r\n                if (strictness == Strictness.STRICT) {\r\n                    throw syntaxError(\"Invalid escaped character \\\"'\\\" in strict mode\");\r\n                }\r\n            case '\"':\r\n            case '\\\\':\r\n            case '/':\r\n                return escaped;\r\n            default:\r\n                // throw error when none of the above cases are matched\r\n                throw syntaxError(\"Invalid escape sequence\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Throws a new {@link MalformedJsonException} with the given message and information about the\r\n     * current location.\r\n     */\r\n    private MalformedJsonException syntaxError(String message) throws MalformedJsonException {\r\n        throw new MalformedJsonException(message + locationString() + \"\\nSee \" + TroubleshootingGuide.createUrl(\"malformed-json\"));\r\n    }\r\n\r\n    private IllegalStateException unexpectedTokenError(String expected) throws IOException {\r\n        JsonToken peeked = peek();\r\n        String troubleshootingId = peeked == JsonToken.NULL ? \"adapter-not-null-safe\" : \"unexpected-json-structure\";\r\n        return new IllegalStateException(\"Expected \" + expected + \" but was \" + peek() + locationString() + \"\\nSee \" + TroubleshootingGuide.createUrl(troubleshootingId));\r\n    }\r\n\r\n    /**\r\n     * Consumes the non-execute prefix if it exists.\r\n     */\r\n    private void consumeNonExecutePrefix() throws IOException {\r\n        // fast-forward through the leading whitespace\r\n        int unused = nextNonWhitespace(true);\r\n        pos--;\r\n        if (pos + 5 > limit && !fillBuffer(5)) {\r\n            return;\r\n        }\r\n        int p = pos;\r\n        char[] buf = buffer;\r\n        if (buf[p] != ')' || buf[p + 1] != ']' || buf[p + 2] != '}' || buf[p + 3] != '\\'' || buf[p + 4] != '\\n') {\r\n            // not a security token!\r\n            return;\r\n        }\r\n        // we consumed a security token!\r\n        pos += 5;\r\n    }\r\n\r\n    static {\r\n        JsonReaderInternalAccess.INSTANCE = new JsonReaderInternalAccess() {\r\n\r\n            @Override\r\n            public void promoteNameToValue(JsonReader reader) throws IOException {\r\n                if (reader instanceof JsonTreeReader) {\r\n                    ((JsonTreeReader) reader).promoteNameToValue();\r\n                    return;\r\n                }\r\n                int p = reader.peeked;\r\n                if (p == PEEKED_NONE) {\r\n                    p = reader.doPeek();\r\n                }\r\n                if (p == PEEKED_DOUBLE_QUOTED_NAME) {\r\n                    reader.peeked = PEEKED_DOUBLE_QUOTED;\r\n                } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\r\n                    reader.peeked = PEEKED_SINGLE_QUOTED;\r\n                } else if (p == PEEKED_UNQUOTED_NAME) {\r\n                    reader.peeked = PEEKED_UNQUOTED;\r\n                } else {\r\n                    throw reader.unexpectedTokenError(\"a name\");\r\n                }\r\n            }\r\n        };\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "MIN_INCOMPLETE_INTEGER",
    "start_line": 214,
    "end_line": 214,
    "code": "private static final long MIN_INCOMPLETE_INTEGER = Long.MIN_VALUE / 10;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "PEEKED_NONE",
    "start_line": 216,
    "end_line": 216,
    "code": "private static final int PEEKED_NONE = 0;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "PEEKED_BEGIN_OBJECT",
    "start_line": 217,
    "end_line": 217,
    "code": "private static final int PEEKED_BEGIN_OBJECT = 1;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "PEEKED_END_OBJECT",
    "start_line": 218,
    "end_line": 218,
    "code": "private static final int PEEKED_END_OBJECT = 2;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "PEEKED_BEGIN_ARRAY",
    "start_line": 219,
    "end_line": 219,
    "code": "private static final int PEEKED_BEGIN_ARRAY = 3;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "PEEKED_END_ARRAY",
    "start_line": 220,
    "end_line": 220,
    "code": "private static final int PEEKED_END_ARRAY = 4;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "PEEKED_TRUE",
    "start_line": 221,
    "end_line": 221,
    "code": "private static final int PEEKED_TRUE = 5;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "PEEKED_FALSE",
    "start_line": 222,
    "end_line": 222,
    "code": "private static final int PEEKED_FALSE = 6;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "PEEKED_NULL",
    "start_line": 223,
    "end_line": 223,
    "code": "private static final int PEEKED_NULL = 7;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "PEEKED_SINGLE_QUOTED",
    "start_line": 224,
    "end_line": 224,
    "code": "private static final int PEEKED_SINGLE_QUOTED = 8;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "PEEKED_DOUBLE_QUOTED",
    "start_line": 225,
    "end_line": 225,
    "code": "private static final int PEEKED_DOUBLE_QUOTED = 9;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "PEEKED_UNQUOTED",
    "start_line": 226,
    "end_line": 226,
    "code": "private static final int PEEKED_UNQUOTED = 10;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "PEEKED_BUFFERED",
    "start_line": 229,
    "end_line": 229,
    "code": "/**\r\n * When this is returned, the string value is stored in peekedString.\r\n */\r\nprivate static final int PEEKED_BUFFERED = 11;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "PEEKED_SINGLE_QUOTED_NAME",
    "start_line": 231,
    "end_line": 231,
    "code": "private static final int PEEKED_SINGLE_QUOTED_NAME = 12;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "PEEKED_DOUBLE_QUOTED_NAME",
    "start_line": 232,
    "end_line": 232,
    "code": "private static final int PEEKED_DOUBLE_QUOTED_NAME = 13;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "PEEKED_UNQUOTED_NAME",
    "start_line": 233,
    "end_line": 233,
    "code": "private static final int PEEKED_UNQUOTED_NAME = 14;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "PEEKED_LONG",
    "start_line": 236,
    "end_line": 236,
    "code": "/**\r\n * When this is returned, the integer value is stored in peekedLong.\r\n */\r\nprivate static final int PEEKED_LONG = 15;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "PEEKED_NUMBER",
    "start_line": 238,
    "end_line": 238,
    "code": "private static final int PEEKED_NUMBER = 16;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "PEEKED_EOF",
    "start_line": 239,
    "end_line": 239,
    "code": "private static final int PEEKED_EOF = 17;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "NUMBER_CHAR_NONE",
    "start_line": 242,
    "end_line": 242,
    "code": "/* State machine when parsing numbers */\r\nprivate static final int NUMBER_CHAR_NONE = 0;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "NUMBER_CHAR_SIGN",
    "start_line": 243,
    "end_line": 243,
    "code": "private static final int NUMBER_CHAR_SIGN = 1;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "NUMBER_CHAR_DIGIT",
    "start_line": 244,
    "end_line": 244,
    "code": "private static final int NUMBER_CHAR_DIGIT = 2;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "NUMBER_CHAR_DECIMAL",
    "start_line": 245,
    "end_line": 245,
    "code": "private static final int NUMBER_CHAR_DECIMAL = 3;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "NUMBER_CHAR_FRACTION_DIGIT",
    "start_line": 246,
    "end_line": 246,
    "code": "private static final int NUMBER_CHAR_FRACTION_DIGIT = 4;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "NUMBER_CHAR_EXP_E",
    "start_line": 247,
    "end_line": 247,
    "code": "private static final int NUMBER_CHAR_EXP_E = 5;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "NUMBER_CHAR_EXP_SIGN",
    "start_line": 248,
    "end_line": 248,
    "code": "private static final int NUMBER_CHAR_EXP_SIGN = 6;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "NUMBER_CHAR_EXP_DIGIT",
    "start_line": 249,
    "end_line": 249,
    "code": "private static final int NUMBER_CHAR_EXP_DIGIT = 7;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "in",
    "start_line": 252,
    "end_line": 252,
    "code": "/**\r\n * The input JSON.\r\n */\r\nprivate final Reader in;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "strictness",
    "start_line": 254,
    "end_line": 254,
    "code": "private Strictness strictness = Strictness.LEGACY_STRICT;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "DEFAULT_NESTING_LIMIT",
    "start_line": 257,
    "end_line": 257,
    "code": "// Default nesting limit is based on\r\n// https://github.com/square/moshi/blob/parent-1.15.0/moshi/src/main/java/com/squareup/moshi/JsonReader.java#L228-L230\r\nstatic final int DEFAULT_NESTING_LIMIT = 255;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "nestingLimit",
    "start_line": 258,
    "end_line": 258,
    "code": "private int nestingLimit = DEFAULT_NESTING_LIMIT;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "BUFFER_SIZE",
    "start_line": 260,
    "end_line": 260,
    "code": "static final int BUFFER_SIZE = 1024;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "buffer",
    "start_line": 267,
    "end_line": 267,
    "code": "/**\r\n * Use a manual buffer to easily read and unread upcoming characters, and also so we can create\r\n * strings without an intermediate StringBuilder. We decode literals directly out of this buffer,\r\n * so it must be at least as long as the longest token that can be reported as a number.\r\n */\r\nprivate final char[] buffer = new char[BUFFER_SIZE];",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "pos",
    "start_line": 269,
    "end_line": 269,
    "code": "private int pos = 0;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "limit",
    "start_line": 270,
    "end_line": 270,
    "code": "private int limit = 0;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "lineNumber",
    "start_line": 272,
    "end_line": 272,
    "code": "private int lineNumber = 0;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "lineStart",
    "start_line": 273,
    "end_line": 273,
    "code": "private int lineStart = 0;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "peeked",
    "start_line": 275,
    "end_line": 275,
    "code": "int peeked = PEEKED_NONE;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "peekedLong",
    "start_line": 281,
    "end_line": 281,
    "code": "/**\r\n * A peeked value that was composed entirely of digits with an optional leading dash. Positive\r\n * values may not have a leading 0.\r\n */\r\nprivate long peekedLong;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "peekedNumberLength",
    "start_line": 287,
    "end_line": 287,
    "code": "/**\r\n * The number of characters in a peeked number literal. Increment 'pos' by this after reading a\r\n * number.\r\n */\r\nprivate int peekedNumberLength;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "peekedString",
    "start_line": 293,
    "end_line": 293,
    "code": "/**\r\n * A peeked string that should be parsed on the next double, long or string. This is populated\r\n * before a numeric value is parsed and used if that parsing fails.\r\n */\r\nprivate String peekedString;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "stack",
    "start_line": 296,
    "end_line": 296,
    "code": "/**\r\n * The nesting stack. Using a manual array rather than an ArrayList saves 20%.\r\n */\r\nprivate int[] stack = new int[32];",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "stackSize",
    "start_line": 298,
    "end_line": 298,
    "code": "private int stackSize = 0;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "pathNames",
    "start_line": 312,
    "end_line": 312,
    "code": "/*\r\n   * The path members. It corresponds directly to stack: At indices where the\r\n   * stack contains an object (EMPTY_OBJECT, DANGLING_NAME or NONEMPTY_OBJECT),\r\n   * pathNames contains the name at this scope. Where it contains an array\r\n   * (EMPTY_ARRAY, NONEMPTY_ARRAY) pathIndices contains the current index in\r\n   * that array. Otherwise the value is undefined, and we take advantage of that\r\n   * by incrementing pathIndices when doing so isn't useful.\r\n   */\r\nprivate String[] pathNames = new String[32];",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "field",
    "name": "pathIndices",
    "start_line": 313,
    "end_line": 313,
    "code": "private int[] pathIndices = new int[32];",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "constructor",
    "name": "JsonReader",
    "start_line": 316,
    "end_line": 318,
    "code": "/**\r\n * Creates a new instance that reads a JSON-encoded stream from {@code in}.\r\n */\r\npublic JsonReader(Reader in) {\r\n    this.in = Objects.requireNonNull(in, \"in == null\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "setLenient",
    "start_line": 333,
    "end_line": 339,
    "code": "/**\r\n * Sets the strictness of this reader.\r\n *\r\n * @deprecated Please use {@link #setStrictness(Strictness)} instead. {@code\r\n *     JsonReader.setLenient(true)} should be replaced by {@code\r\n *     JsonReader.setStrictness(Strictness.LENIENT)} and {@code JsonReader.setLenient(false)}\r\n *     should be replaced by {@code JsonReader.setStrictness(Strictness.LEGACY_STRICT)}.<br>\r\n *     However, if you used {@code setLenient(false)} before, you might prefer {@link\r\n *     Strictness#STRICT} now instead.\r\n * @param lenient whether this reader should be lenient. If true, the strictness is set to {@link\r\n *     Strictness#LENIENT}. If false, the strictness is set to {@link Strictness#LEGACY_STRICT}.\r\n * @see #setStrictness(Strictness)\r\n */\r\n@Deprecated\r\n// Don't specify @InlineMe, so caller with `setLenient(false)` becomes aware of new\r\n// Strictness.STRICT\r\n@SuppressWarnings(\"InlineMeSuggester\")\r\npublic final void setLenient(boolean lenient) {\r\n    setStrictness(lenient ? Strictness.LENIENT : Strictness.LEGACY_STRICT);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "isLenient",
    "start_line": 346,
    "end_line": 348,
    "code": "/**\r\n * Returns true if the {@link Strictness} of this reader is equal to {@link Strictness#LENIENT}.\r\n *\r\n * @see #getStrictness()\r\n */\r\npublic final boolean isLenient() {\r\n    return strictness == Strictness.LENIENT;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "setStrictness",
    "start_line": 404,
    "end_line": 407,
    "code": "/**\r\n * Configures how liberal this parser is in what it accepts.\r\n *\r\n * <p>In {@linkplain Strictness#STRICT strict} mode, the parser only accepts JSON in accordance\r\n * with <a href=\"https://www.ietf.org/rfc/rfc8259.txt\">RFC 8259</a>. In {@linkplain\r\n * Strictness#LEGACY_STRICT legacy strict} mode (the default), only JSON in accordance with the\r\n * RFC 8259 is accepted, with a few exceptions denoted below for backwards compatibility reasons.\r\n * In {@linkplain Strictness#LENIENT lenient} mode, all sort of non-spec compliant JSON is\r\n * accepted (see below).\r\n *\r\n * <dl>\r\n *   <dt>{@link Strictness#STRICT}\r\n *   <dd>In strict mode, only input compliant with RFC 8259 is accepted.\r\n *   <dt>{@link Strictness#LEGACY_STRICT}\r\n *   <dd>In legacy strict mode, the following departures from RFC 8259 are accepted:\r\n *       <ul>\r\n *         <li>JsonReader allows the literals {@code true}, {@code false} and {@code null} to have\r\n *             any capitalization, for example {@code fAlSe} or {@code NULL}\r\n *         <li>JsonReader supports the escape sequence {@code \\'}, representing a {@code '}\r\n *             (single-quote)\r\n *         <li>JsonReader supports the escape sequence <code>\\<i>LF</i></code> (with {@code LF}\r\n *             being the Unicode character {@code U+000A}), resulting in a {@code LF} within the\r\n *             read JSON string\r\n *         <li>JsonReader allows unescaped control characters ({@code U+0000} through {@code\r\n *             U+001F})\r\n *       </ul>\r\n *   <dt>{@link Strictness#LENIENT}\r\n *   <dd>In lenient mode, all input that is accepted in legacy strict mode is accepted in addition\r\n *       to the following departures from RFC 8259:\r\n *       <ul>\r\n *         <li>Streams that start with the <a href=\"#nonexecuteprefix\">non-execute prefix</a>,\r\n *             {@code \")]}'\\n\"}\r\n *         <li>Streams that include multiple top-level values. With legacy strict or strict\r\n *             parsing, each stream must contain exactly one top-level value.\r\n *         <li>Numbers may be {@link Double#isNaN() NaNs} or {@link Double#isInfinite()\r\n *             infinities} represented by {@code NaN} and {@code (-)Infinity} respectively.\r\n *         <li>End of line comments starting with {@code //} or {@code #} and ending with a\r\n *             newline character.\r\n *         <li>C-style comments starting with {@code /*} and ending with {@code *}{@code /}. Such\r\n *             comments may not be nested.\r\n *         <li>Names that are unquoted or {@code 'single quoted'}.\r\n *         <li>Strings that are unquoted or {@code 'single quoted'}.\r\n *         <li>Array elements separated by {@code ;} instead of {@code ,}.\r\n *         <li>Unnecessary array separators. These are interpreted as if null was the omitted\r\n *             value.\r\n *         <li>Names and values separated by {@code =} or {@code =>} instead of {@code :}.\r\n *         <li>Name/value pairs separated by {@code ;} instead of {@code ,}.\r\n *       </ul>\r\n * </dl>\r\n *\r\n * @param strictness the new strictness value of this reader. May not be {@code null}.\r\n * @see #getStrictness()\r\n * @since 2.11.0\r\n */\r\npublic final void setStrictness(Strictness strictness) {\r\n    Objects.requireNonNull(strictness);\r\n    this.strictness = strictness;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "getStrictness",
    "start_line": 415,
    "end_line": 417,
    "code": "/**\r\n * Returns the {@linkplain Strictness strictness} of this reader.\r\n *\r\n * @see #setStrictness(Strictness)\r\n * @since 2.11.0\r\n */\r\npublic final Strictness getStrictness() {\r\n    return strictness;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "setNestingLimit",
    "start_line": 437,
    "end_line": 442,
    "code": "/**\r\n * Sets the nesting limit of this reader.\r\n *\r\n * <p>The nesting limit defines how many JSON arrays or objects may be open at the same time. For\r\n * example a nesting limit of 0 means no arrays or objects may be opened at all, a nesting limit\r\n * of 1 means one array or object may be open at the same time, and so on. So a nesting limit of 3\r\n * allows reading the JSON data <code>[{\"a\":[true]}]</code>, but for a nesting limit of 2 it would\r\n * fail at the inner {@code [true]}.\r\n *\r\n * <p>The nesting limit can help to protect against a {@link StackOverflowError} when recursive\r\n * {@link TypeAdapter} implementations process deeply nested JSON data.\r\n *\r\n * <p>The default nesting limit is {@value #DEFAULT_NESTING_LIMIT}.\r\n *\r\n * @throws IllegalArgumentException if the nesting limit is negative.\r\n * @since 2.12.0\r\n * @see #getNestingLimit()\r\n */\r\npublic final void setNestingLimit(int limit) {\r\n    if (limit < 0) {\r\n        throw new IllegalArgumentException(\"Invalid nesting limit: \" + limit);\r\n    }\r\n    this.nestingLimit = limit;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "getNestingLimit",
    "start_line": 450,
    "end_line": 452,
    "code": "/**\r\n * Returns the nesting limit of this reader.\r\n *\r\n * @since 2.12.0\r\n * @see #setNestingLimit(int)\r\n */\r\npublic final int getNestingLimit() {\r\n    return nestingLimit;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "beginArray",
    "start_line": 460,
    "end_line": 472,
    "code": "/**\r\n * Consumes the next token from the JSON stream and asserts that it is the beginning of a new\r\n * array.\r\n *\r\n * @throws IllegalStateException if the next token is not the beginning of an array.\r\n */\r\npublic void beginArray() throws IOException {\r\n    int p = peeked;\r\n    if (p == PEEKED_NONE) {\r\n        p = doPeek();\r\n    }\r\n    if (p == PEEKED_BEGIN_ARRAY) {\r\n        push(JsonScope.EMPTY_ARRAY);\r\n        pathIndices[stackSize - 1] = 0;\r\n        peeked = PEEKED_NONE;\r\n    } else {\r\n        throw unexpectedTokenError(\"BEGIN_ARRAY\");\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "endArray",
    "start_line": 480,
    "end_line": 492,
    "code": "/**\r\n * Consumes the next token from the JSON stream and asserts that it is the end of the current\r\n * array.\r\n *\r\n * @throws IllegalStateException if the next token is not the end of an array.\r\n */\r\npublic void endArray() throws IOException {\r\n    int p = peeked;\r\n    if (p == PEEKED_NONE) {\r\n        p = doPeek();\r\n    }\r\n    if (p == PEEKED_END_ARRAY) {\r\n        stackSize--;\r\n        pathIndices[stackSize - 1]++;\r\n        peeked = PEEKED_NONE;\r\n    } else {\r\n        throw unexpectedTokenError(\"END_ARRAY\");\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "beginObject",
    "start_line": 500,
    "end_line": 511,
    "code": "/**\r\n * Consumes the next token from the JSON stream and asserts that it is the beginning of a new\r\n * object.\r\n *\r\n * @throws IllegalStateException if the next token is not the beginning of an object.\r\n */\r\npublic void beginObject() throws IOException {\r\n    int p = peeked;\r\n    if (p == PEEKED_NONE) {\r\n        p = doPeek();\r\n    }\r\n    if (p == PEEKED_BEGIN_OBJECT) {\r\n        push(JsonScope.EMPTY_OBJECT);\r\n        peeked = PEEKED_NONE;\r\n    } else {\r\n        throw unexpectedTokenError(\"BEGIN_OBJECT\");\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "endObject",
    "start_line": 519,
    "end_line": 532,
    "code": "/**\r\n * Consumes the next token from the JSON stream and asserts that it is the end of the current\r\n * object.\r\n *\r\n * @throws IllegalStateException if the next token is not the end of an object.\r\n */\r\npublic void endObject() throws IOException {\r\n    int p = peeked;\r\n    if (p == PEEKED_NONE) {\r\n        p = doPeek();\r\n    }\r\n    if (p == PEEKED_END_OBJECT) {\r\n        stackSize--;\r\n        // Free the last path name so that it can be garbage collected!\r\n        pathNames[stackSize] = null;\r\n        pathIndices[stackSize - 1]++;\r\n        peeked = PEEKED_NONE;\r\n    } else {\r\n        throw unexpectedTokenError(\"END_OBJECT\");\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "hasNext",
    "start_line": 535,
    "end_line": 541,
    "code": "/**\r\n * Returns true if the current array or object has another element.\r\n */\r\npublic boolean hasNext() throws IOException {\r\n    int p = peeked;\r\n    if (p == PEEKED_NONE) {\r\n        p = doPeek();\r\n    }\r\n    return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY && p != PEEKED_EOF;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "peek",
    "start_line": 544,
    "end_line": 581,
    "code": "/**\r\n * Returns the type of the next token without consuming it.\r\n */\r\npublic JsonToken peek() throws IOException {\r\n    int p = peeked;\r\n    if (p == PEEKED_NONE) {\r\n        p = doPeek();\r\n    }\r\n    switch(p) {\r\n        case PEEKED_BEGIN_OBJECT:\r\n            return JsonToken.BEGIN_OBJECT;\r\n        case PEEKED_END_OBJECT:\r\n            return JsonToken.END_OBJECT;\r\n        case PEEKED_BEGIN_ARRAY:\r\n            return JsonToken.BEGIN_ARRAY;\r\n        case PEEKED_END_ARRAY:\r\n            return JsonToken.END_ARRAY;\r\n        case PEEKED_SINGLE_QUOTED_NAME:\r\n        case PEEKED_DOUBLE_QUOTED_NAME:\r\n        case PEEKED_UNQUOTED_NAME:\r\n            return JsonToken.NAME;\r\n        case PEEKED_TRUE:\r\n        case PEEKED_FALSE:\r\n            return JsonToken.BOOLEAN;\r\n        case PEEKED_NULL:\r\n            return JsonToken.NULL;\r\n        case PEEKED_SINGLE_QUOTED:\r\n        case PEEKED_DOUBLE_QUOTED:\r\n        case PEEKED_UNQUOTED:\r\n        case PEEKED_BUFFERED:\r\n            return JsonToken.STRING;\r\n        case PEEKED_LONG:\r\n        case PEEKED_NUMBER:\r\n            return JsonToken.NUMBER;\r\n        case PEEKED_EOF:\r\n            return JsonToken.END_DOCUMENT;\r\n        default:\r\n            throw new AssertionError();\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "doPeek",
    "start_line": 583,
    "end_line": 732,
    "code": "@SuppressWarnings(\"fallthrough\")\r\nint doPeek() throws IOException {\r\n    int peekStack = stack[stackSize - 1];\r\n    if (peekStack == JsonScope.EMPTY_ARRAY) {\r\n        stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\r\n    } else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\r\n        // Look for a comma before the next element.\r\n        int c = nextNonWhitespace(true);\r\n        switch(c) {\r\n            case ']':\r\n                peeked = PEEKED_END_ARRAY;\r\n                return peeked;\r\n            case ';':\r\n                // fall-through\r\n                checkLenient();\r\n            case ',':\r\n                break;\r\n            default:\r\n                throw syntaxError(\"Unterminated array\");\r\n        }\r\n    } else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {\r\n        stack[stackSize - 1] = JsonScope.DANGLING_NAME;\r\n        // Look for a comma before the next element.\r\n        if (peekStack == JsonScope.NONEMPTY_OBJECT) {\r\n            int c = nextNonWhitespace(true);\r\n            switch(c) {\r\n                case '}':\r\n                    peeked = PEEKED_END_OBJECT;\r\n                    return peeked;\r\n                case ';':\r\n                    // fall-through\r\n                    checkLenient();\r\n                case ',':\r\n                    break;\r\n                default:\r\n                    throw syntaxError(\"Unterminated object\");\r\n            }\r\n        }\r\n        int c = nextNonWhitespace(true);\r\n        switch(c) {\r\n            case '\"':\r\n                peeked = PEEKED_DOUBLE_QUOTED_NAME;\r\n                return peeked;\r\n            case '\\'':\r\n                checkLenient();\r\n                peeked = PEEKED_SINGLE_QUOTED_NAME;\r\n                return peeked;\r\n            case '}':\r\n                if (peekStack != JsonScope.NONEMPTY_OBJECT) {\r\n                    peeked = PEEKED_END_OBJECT;\r\n                    return peeked;\r\n                } else {\r\n                    throw syntaxError(\"Expected name\");\r\n                }\r\n            default:\r\n                checkLenient();\r\n                // Don't consume the first character in an unquoted string.\r\n                pos--;\r\n                if (isLiteral((char) c)) {\r\n                    peeked = PEEKED_UNQUOTED_NAME;\r\n                    return peeked;\r\n                } else {\r\n                    throw syntaxError(\"Expected name\");\r\n                }\r\n        }\r\n    } else if (peekStack == JsonScope.DANGLING_NAME) {\r\n        stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;\r\n        // Look for a colon before the value.\r\n        int c = nextNonWhitespace(true);\r\n        switch(c) {\r\n            case ':':\r\n                break;\r\n            case '=':\r\n                checkLenient();\r\n                if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') {\r\n                    pos++;\r\n                }\r\n                break;\r\n            default:\r\n                throw syntaxError(\"Expected ':'\");\r\n        }\r\n    } else if (peekStack == JsonScope.EMPTY_DOCUMENT) {\r\n        if (strictness == Strictness.LENIENT) {\r\n            consumeNonExecutePrefix();\r\n        }\r\n        stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;\r\n    } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) {\r\n        int c = nextNonWhitespace(false);\r\n        if (c == -1) {\r\n            peeked = PEEKED_EOF;\r\n            return peeked;\r\n        } else {\r\n            checkLenient();\r\n            pos--;\r\n        }\r\n    } else if (peekStack == JsonScope.CLOSED) {\r\n        throw new IllegalStateException(\"JsonReader is closed\");\r\n    }\r\n    int c = nextNonWhitespace(true);\r\n    switch(c) {\r\n        case ']':\r\n            if (peekStack == JsonScope.EMPTY_ARRAY) {\r\n                peeked = PEEKED_END_ARRAY;\r\n                return peeked;\r\n            }\r\n        // fall-through to handle \",]\"\r\n        case ';':\r\n        case ',':\r\n            // In lenient mode, a 0-length literal in an array means 'null'.\r\n            if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) {\r\n                checkLenient();\r\n                pos--;\r\n                peeked = PEEKED_NULL;\r\n                return peeked;\r\n            } else {\r\n                throw syntaxError(\"Unexpected value\");\r\n            }\r\n        case '\\'':\r\n            checkLenient();\r\n            peeked = PEEKED_SINGLE_QUOTED;\r\n            return peeked;\r\n        case '\"':\r\n            peeked = PEEKED_DOUBLE_QUOTED;\r\n            return peeked;\r\n        case '[':\r\n            peeked = PEEKED_BEGIN_ARRAY;\r\n            return peeked;\r\n        case '{':\r\n            peeked = PEEKED_BEGIN_OBJECT;\r\n            return peeked;\r\n        default:\r\n            // Don't consume the first character in a literal value.\r\n            pos--;\r\n    }\r\n    int result = peekKeyword();\r\n    if (result != PEEKED_NONE) {\r\n        return result;\r\n    }\r\n    result = peekNumber();\r\n    if (result != PEEKED_NONE) {\r\n        return result;\r\n    }\r\n    if (!isLiteral(buffer[pos])) {\r\n        throw syntaxError(\"Expected value\");\r\n    }\r\n    checkLenient();\r\n    peeked = PEEKED_UNQUOTED;\r\n    return peeked;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "peekKeyword",
    "start_line": 734,
    "end_line": 782,
    "code": "private int peekKeyword() throws IOException {\r\n    // Figure out which keyword we're matching against by its first character.\r\n    char c = buffer[pos];\r\n    String keyword;\r\n    String keywordUpper;\r\n    int peeking;\r\n    // Look at the first letter to determine what keyword we are trying to match.\r\n    if (c == 't' || c == 'T') {\r\n        keyword = \"true\";\r\n        keywordUpper = \"TRUE\";\r\n        peeking = PEEKED_TRUE;\r\n    } else if (c == 'f' || c == 'F') {\r\n        keyword = \"false\";\r\n        keywordUpper = \"FALSE\";\r\n        peeking = PEEKED_FALSE;\r\n    } else if (c == 'n' || c == 'N') {\r\n        keyword = \"null\";\r\n        keywordUpper = \"NULL\";\r\n        peeking = PEEKED_NULL;\r\n    } else {\r\n        return PEEKED_NONE;\r\n    }\r\n    // Uppercased keywords are not allowed in STRICT mode\r\n    boolean allowsUpperCased = strictness != Strictness.STRICT;\r\n    // Confirm that chars [0..length) match the keyword.\r\n    int length = keyword.length();\r\n    for (int i = 0; i < length; i++) {\r\n        if (pos + i >= limit && !fillBuffer(i + 1)) {\r\n            return PEEKED_NONE;\r\n        }\r\n        c = buffer[pos + i];\r\n        boolean matched = c == keyword.charAt(i) || (allowsUpperCased && c == keywordUpper.charAt(i));\r\n        if (!matched) {\r\n            return PEEKED_NONE;\r\n        }\r\n    }\r\n    if ((pos + length < limit || fillBuffer(length + 1)) && isLiteral(buffer[pos + length])) {\r\n        // Don't match trues, falsey or nullsoft!\r\n        return PEEKED_NONE;\r\n    }\r\n    // We've found the keyword followed either by EOF or by a non-literal character.\r\n    pos += length;\r\n    peeked = peeking;\r\n    return peeked;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "peekNumber",
    "start_line": 784,
    "end_line": 894,
    "code": "private int peekNumber() throws IOException {\r\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\r\n    char[] buffer = this.buffer;\r\n    int p = pos;\r\n    int l = limit;\r\n    // Negative to accommodate Long.MIN_VALUE more easily.\r\n    long value = 0;\r\n    boolean negative = false;\r\n    boolean fitsInLong = true;\r\n    int last = NUMBER_CHAR_NONE;\r\n    int i = 0;\r\n    charactersOfNumber: for (; true; i++) {\r\n        if (p + i == l) {\r\n            if (i == buffer.length) {\r\n                // Though this looks like a well-formed number, it's too long to continue reading. Give up\r\n                // and let the application handle this as an unquoted literal.\r\n                return PEEKED_NONE;\r\n            }\r\n            if (!fillBuffer(i + 1)) {\r\n                break;\r\n            }\r\n            p = pos;\r\n            l = limit;\r\n        }\r\n        char c = buffer[p + i];\r\n        switch(c) {\r\n            case '-':\r\n                if (last == NUMBER_CHAR_NONE) {\r\n                    negative = true;\r\n                    last = NUMBER_CHAR_SIGN;\r\n                    continue;\r\n                } else if (last == NUMBER_CHAR_EXP_E) {\r\n                    last = NUMBER_CHAR_EXP_SIGN;\r\n                    continue;\r\n                }\r\n                return PEEKED_NONE;\r\n            case '+':\r\n                if (last == NUMBER_CHAR_EXP_E) {\r\n                    last = NUMBER_CHAR_EXP_SIGN;\r\n                    continue;\r\n                }\r\n                return PEEKED_NONE;\r\n            case 'e':\r\n            case 'E':\r\n                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\r\n                    last = NUMBER_CHAR_EXP_E;\r\n                    continue;\r\n                }\r\n                return PEEKED_NONE;\r\n            case '.':\r\n                if (last == NUMBER_CHAR_DIGIT) {\r\n                    last = NUMBER_CHAR_DECIMAL;\r\n                    continue;\r\n                }\r\n                return PEEKED_NONE;\r\n            default:\r\n                if (c < '0' || c > '9') {\r\n                    if (!isLiteral(c)) {\r\n                        break charactersOfNumber;\r\n                    }\r\n                    return PEEKED_NONE;\r\n                }\r\n                if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\r\n                    value = -(c - '0');\r\n                    last = NUMBER_CHAR_DIGIT;\r\n                } else if (last == NUMBER_CHAR_DIGIT) {\r\n                    if (value == 0) {\r\n                        // Leading '0' prefix is not allowed (since it could be octal).\r\n                        return PEEKED_NONE;\r\n                    }\r\n                    long newValue = value * 10 - (c - '0');\r\n                    fitsInLong &= value > MIN_INCOMPLETE_INTEGER || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\r\n                    value = newValue;\r\n                } else if (last == NUMBER_CHAR_DECIMAL) {\r\n                    last = NUMBER_CHAR_FRACTION_DIGIT;\r\n                } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\r\n                    last = NUMBER_CHAR_EXP_DIGIT;\r\n                }\r\n        }\r\n    }\r\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\r\n    // Don't store -0 as long; user might want to read it as double -0.0\r\n    // Don't try to convert Long.MIN_VALUE to positive long; it would overflow MAX_VALUE\r\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative) && (value != 0 || !negative)) {\r\n        peekedLong = negative ? value : -value;\r\n        pos += i;\r\n        peeked = PEEKED_LONG;\r\n        return peeked;\r\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT || last == NUMBER_CHAR_EXP_DIGIT) {\r\n        peekedNumberLength = i;\r\n        peeked = PEEKED_NUMBER;\r\n        return peeked;\r\n    } else {\r\n        return PEEKED_NONE;\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "isLiteral",
    "start_line": 896,
    "end_line": 920,
    "code": "@SuppressWarnings(\"fallthrough\")\r\nprivate boolean isLiteral(char c) throws IOException {\r\n    switch(c) {\r\n        case '/':\r\n        case '\\\\':\r\n        case ';':\r\n        case '#':\r\n        case '=':\r\n            // fall-through\r\n            checkLenient();\r\n        case '{':\r\n        case '}':\r\n        case '[':\r\n        case ']':\r\n        case ':':\r\n        case ',':\r\n        case ' ':\r\n        case '\\t':\r\n        case '\\f':\r\n        case '\\r':\r\n        case '\\n':\r\n            return false;\r\n        default:\r\n            return true;\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "nextName",
    "start_line": 927,
    "end_line": 945,
    "code": "/**\r\n * Returns the next token, a {@link JsonToken#NAME property name}, and consumes it.\r\n *\r\n * @throws IllegalStateException if the next token is not a property name.\r\n */\r\npublic String nextName() throws IOException {\r\n    int p = peeked;\r\n    if (p == PEEKED_NONE) {\r\n        p = doPeek();\r\n    }\r\n    String result;\r\n    if (p == PEEKED_UNQUOTED_NAME) {\r\n        result = nextUnquotedValue();\r\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\r\n        result = nextQuotedValue('\\'');\r\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\r\n        result = nextQuotedValue('\"');\r\n    } else {\r\n        throw unexpectedTokenError(\"a name\");\r\n    }\r\n    peeked = PEEKED_NONE;\r\n    pathNames[stackSize - 1] = result;\r\n    return result;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "nextString",
    "start_line": 953,
    "end_line": 979,
    "code": "/**\r\n * Returns the {@link JsonToken#STRING string} value of the next token, consuming it. If the next\r\n * token is a number, this method will return its string form.\r\n *\r\n * @throws IllegalStateException if the next token is not a string.\r\n */\r\npublic String nextString() throws IOException {\r\n    int p = peeked;\r\n    if (p == PEEKED_NONE) {\r\n        p = doPeek();\r\n    }\r\n    String result;\r\n    if (p == PEEKED_UNQUOTED) {\r\n        result = nextUnquotedValue();\r\n    } else if (p == PEEKED_SINGLE_QUOTED) {\r\n        result = nextQuotedValue('\\'');\r\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\r\n        result = nextQuotedValue('\"');\r\n    } else if (p == PEEKED_BUFFERED) {\r\n        result = peekedString;\r\n        peekedString = null;\r\n    } else if (p == PEEKED_LONG) {\r\n        result = Long.toString(peekedLong);\r\n    } else if (p == PEEKED_NUMBER) {\r\n        result = new String(buffer, pos, peekedNumberLength);\r\n        pos += peekedNumberLength;\r\n    } else {\r\n        throw unexpectedTokenError(\"a string\");\r\n    }\r\n    peeked = PEEKED_NONE;\r\n    pathIndices[stackSize - 1]++;\r\n    return result;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "nextBoolean",
    "start_line": 986,
    "end_line": 1001,
    "code": "/**\r\n * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token, consuming it.\r\n *\r\n * @throws IllegalStateException if the next token is not a boolean.\r\n */\r\npublic boolean nextBoolean() throws IOException {\r\n    int p = peeked;\r\n    if (p == PEEKED_NONE) {\r\n        p = doPeek();\r\n    }\r\n    if (p == PEEKED_TRUE) {\r\n        peeked = PEEKED_NONE;\r\n        pathIndices[stackSize - 1]++;\r\n        return true;\r\n    } else if (p == PEEKED_FALSE) {\r\n        peeked = PEEKED_NONE;\r\n        pathIndices[stackSize - 1]++;\r\n        return false;\r\n    }\r\n    throw unexpectedTokenError(\"a boolean\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "nextNull",
    "start_line": 1008,
    "end_line": 1019,
    "code": "/**\r\n * Consumes the next token from the JSON stream and asserts that it is a literal null.\r\n *\r\n * @throws IllegalStateException if the next token is not a JSON null.\r\n */\r\npublic void nextNull() throws IOException {\r\n    int p = peeked;\r\n    if (p == PEEKED_NONE) {\r\n        p = doPeek();\r\n    }\r\n    if (p == PEEKED_NULL) {\r\n        peeked = PEEKED_NONE;\r\n        pathIndices[stackSize - 1]++;\r\n    } else {\r\n        throw unexpectedTokenError(\"null\");\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "nextDouble",
    "start_line": 1031,
    "end_line": 1063,
    "code": "/**\r\n * Returns the {@link JsonToken#NUMBER double} value of the next token, consuming it. If the next\r\n * token is a string, this method will attempt to parse it as a double using {@link\r\n * Double#parseDouble(String)}.\r\n *\r\n * @throws IllegalStateException if the next token is neither a number nor a string.\r\n * @throws NumberFormatException if the next literal value cannot be parsed as a double.\r\n * @throws MalformedJsonException if the next literal value is NaN or Infinity and this reader is\r\n *     not {@link #setStrictness(Strictness) lenient}.\r\n */\r\npublic double nextDouble() throws IOException {\r\n    int p = peeked;\r\n    if (p == PEEKED_NONE) {\r\n        p = doPeek();\r\n    }\r\n    if (p == PEEKED_LONG) {\r\n        peeked = PEEKED_NONE;\r\n        pathIndices[stackSize - 1]++;\r\n        return (double) peekedLong;\r\n    }\r\n    if (p == PEEKED_NUMBER) {\r\n        peekedString = new String(buffer, pos, peekedNumberLength);\r\n        pos += peekedNumberLength;\r\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\r\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\r\n    } else if (p == PEEKED_UNQUOTED) {\r\n        peekedString = nextUnquotedValue();\r\n    } else if (p != PEEKED_BUFFERED) {\r\n        throw unexpectedTokenError(\"a double\");\r\n    }\r\n    peeked = PEEKED_BUFFERED;\r\n    // don't catch this NumberFormatException.\r\n    double result = Double.parseDouble(peekedString);\r\n    if (strictness != Strictness.LENIENT && (Double.isNaN(result) || Double.isInfinite(result))) {\r\n        throw syntaxError(\"JSON forbids NaN and infinities: \" + result);\r\n    }\r\n    peekedString = null;\r\n    peeked = PEEKED_NONE;\r\n    pathIndices[stackSize - 1]++;\r\n    return result;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "nextLong",
    "start_line": 1074,
    "end_line": 1117,
    "code": "/**\r\n * Returns the {@link JsonToken#NUMBER long} value of the next token, consuming it. If the next\r\n * token is a string, this method will attempt to parse it as a long. If the next token's numeric\r\n * value cannot be exactly represented by a Java {@code long}, this method throws.\r\n *\r\n * @throws IllegalStateException if the next token is neither a number nor a string.\r\n * @throws NumberFormatException if the next literal value cannot be parsed as a number, or\r\n *     exactly represented as a long.\r\n */\r\npublic long nextLong() throws IOException {\r\n    int p = peeked;\r\n    if (p == PEEKED_NONE) {\r\n        p = doPeek();\r\n    }\r\n    if (p == PEEKED_LONG) {\r\n        peeked = PEEKED_NONE;\r\n        pathIndices[stackSize - 1]++;\r\n        return peekedLong;\r\n    }\r\n    if (p == PEEKED_NUMBER) {\r\n        peekedString = new String(buffer, pos, peekedNumberLength);\r\n        pos += peekedNumberLength;\r\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\r\n        if (p == PEEKED_UNQUOTED) {\r\n            peekedString = nextUnquotedValue();\r\n        } else {\r\n            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\r\n        }\r\n        try {\r\n            long result = Long.parseLong(peekedString);\r\n            peeked = PEEKED_NONE;\r\n            pathIndices[stackSize - 1]++;\r\n            return result;\r\n        } catch (NumberFormatException ignored) {\r\n            // Fall back to parse as a double below.\r\n        }\r\n    } else {\r\n        throw unexpectedTokenError(\"a long\");\r\n    }\r\n    peeked = PEEKED_BUFFERED;\r\n    // don't catch this NumberFormatException.\r\n    double asDouble = Double.parseDouble(peekedString);\r\n    long result = (long) asDouble;\r\n    if (result != asDouble) {\r\n        // Make sure no precision was lost casting to 'long'.\r\n        throw new NumberFormatException(\"Expected a long but was \" + peekedString + locationString());\r\n    }\r\n    peekedString = null;\r\n    peeked = PEEKED_NONE;\r\n    pathIndices[stackSize - 1]++;\r\n    return result;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "nextQuotedValue",
    "start_line": 1126,
    "end_line": 1180,
    "code": "/**\r\n * Returns the string up to but not including {@code quote}, unescaping any character escape\r\n * sequences encountered along the way. The opening quote should have already been read. This\r\n * consumes the closing quote, but does not include it in the returned string.\r\n *\r\n * @param quote either ' or \".\r\n */\r\nprivate String nextQuotedValue(char quote) throws IOException {\r\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\r\n    char[] buffer = this.buffer;\r\n    StringBuilder builder = null;\r\n    while (true) {\r\n        int p = pos;\r\n        int l = limit;\r\n        /* the index of the first character not yet appended to the builder. */\r\n        int start = p;\r\n        while (p < l) {\r\n            int c = buffer[p++];\r\n            // In strict mode, throw an exception when meeting unescaped control characters (U+0000\r\n            // through U+001F)\r\n            if (strictness == Strictness.STRICT && c < 0x20) {\r\n                throw syntaxError(\"Unescaped control characters (\\\\u0000-\\\\u001F) are not allowed in strict mode\");\r\n            } else if (c == quote) {\r\n                pos = p;\r\n                int len = p - start - 1;\r\n                if (builder == null) {\r\n                    return new String(buffer, start, len);\r\n                } else {\r\n                    builder.append(buffer, start, len);\r\n                    return builder.toString();\r\n                }\r\n            } else if (c == '\\\\') {\r\n                pos = p;\r\n                int len = p - start - 1;\r\n                if (builder == null) {\r\n                    int estimatedLength = (len + 1) * 2;\r\n                    builder = new StringBuilder(Math.max(estimatedLength, 16));\r\n                }\r\n                builder.append(buffer, start, len);\r\n                builder.append(readEscapeCharacter());\r\n                p = pos;\r\n                l = limit;\r\n                start = p;\r\n            } else if (c == '\\n') {\r\n                lineNumber++;\r\n                lineStart = p;\r\n            }\r\n        }\r\n        if (builder == null) {\r\n            int estimatedLength = (p - start) * 2;\r\n            builder = new StringBuilder(Math.max(estimatedLength, 16));\r\n        }\r\n        builder.append(buffer, start, p - start);\r\n        pos = p;\r\n        if (!fillBuffer(1)) {\r\n            throw syntaxError(\"Unterminated string\");\r\n        }\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "nextUnquotedValue",
    "start_line": 1183,
    "end_line": 1240,
    "code": "/**\r\n * Returns an unquoted value as a string.\r\n */\r\n@SuppressWarnings(\"fallthrough\")\r\nprivate String nextUnquotedValue() throws IOException {\r\n    StringBuilder builder = null;\r\n    int i = 0;\r\n    findNonLiteralCharacter: while (true) {\r\n        for (; pos + i < limit; i++) {\r\n            switch(buffer[pos + i]) {\r\n                case '/':\r\n                case '\\\\':\r\n                case ';':\r\n                case '#':\r\n                case '=':\r\n                    // fall-through\r\n                    checkLenient();\r\n                case '{':\r\n                case '}':\r\n                case '[':\r\n                case ']':\r\n                case ':':\r\n                case ',':\r\n                case ' ':\r\n                case '\\t':\r\n                case '\\f':\r\n                case '\\r':\r\n                case '\\n':\r\n                    break findNonLiteralCharacter;\r\n                default:\r\n            }\r\n        }\r\n        // Attempt to load the entire literal into the buffer at once.\r\n        if (i < buffer.length) {\r\n            if (fillBuffer(i + 1)) {\r\n                continue;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        // use a StringBuilder when the value is too long. This is too long to be a number!\r\n        if (builder == null) {\r\n            builder = new StringBuilder(Math.max(i, 16));\r\n        }\r\n        builder.append(buffer, pos, i);\r\n        pos += i;\r\n        i = 0;\r\n        if (!fillBuffer(1)) {\r\n            break;\r\n        }\r\n    }\r\n    String result = (builder == null) ? new String(buffer, pos, i) : builder.append(buffer, pos, i).toString();\r\n    pos += i;\r\n    return result;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "skipQuotedValue",
    "start_line": 1242,
    "end_line": 1267,
    "code": "private void skipQuotedValue(char quote) throws IOException {\r\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\r\n    char[] buffer = this.buffer;\r\n    do {\r\n        int p = pos;\r\n        int l = limit;\r\n        /* the index of the first character not yet appended to the builder. */\r\n        while (p < l) {\r\n            int c = buffer[p++];\r\n            if (c == quote) {\r\n                pos = p;\r\n                return;\r\n            } else if (c == '\\\\') {\r\n                pos = p;\r\n                char unused = readEscapeCharacter();\r\n                p = pos;\r\n                l = limit;\r\n            } else if (c == '\\n') {\r\n                lineNumber++;\r\n                lineStart = p;\r\n            }\r\n        }\r\n        pos = p;\r\n    } while (fillBuffer(1));\r\n    throw syntaxError(\"Unterminated string\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "skipUnquotedValue",
    "start_line": 1269,
    "end_line": 1300,
    "code": "@SuppressWarnings(\"fallthrough\")\r\nprivate void skipUnquotedValue() throws IOException {\r\n    do {\r\n        int i = 0;\r\n        for (; pos + i < limit; i++) {\r\n            switch(buffer[pos + i]) {\r\n                case '/':\r\n                case '\\\\':\r\n                case ';':\r\n                case '#':\r\n                case '=':\r\n                    // fall-through\r\n                    checkLenient();\r\n                case '{':\r\n                case '}':\r\n                case '[':\r\n                case ']':\r\n                case ':':\r\n                case ',':\r\n                case ' ':\r\n                case '\\t':\r\n                case '\\f':\r\n                case '\\r':\r\n                case '\\n':\r\n                    pos += i;\r\n                    return;\r\n                default:\r\n            }\r\n        }\r\n        pos += i;\r\n    } while (fillBuffer(1));\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "nextInt",
    "start_line": 1311,
    "end_line": 1359,
    "code": "/**\r\n * Returns the {@link JsonToken#NUMBER int} value of the next token, consuming it. If the next\r\n * token is a string, this method will attempt to parse it as an int. If the next token's numeric\r\n * value cannot be exactly represented by a Java {@code int}, this method throws.\r\n *\r\n * @throws IllegalStateException if the next token is neither a number nor a string.\r\n * @throws NumberFormatException if the next literal value cannot be parsed as a number, or\r\n *     exactly represented as an int.\r\n */\r\npublic int nextInt() throws IOException {\r\n    int p = peeked;\r\n    if (p == PEEKED_NONE) {\r\n        p = doPeek();\r\n    }\r\n    int result;\r\n    if (p == PEEKED_LONG) {\r\n        result = (int) peekedLong;\r\n        if (peekedLong != result) {\r\n            // Make sure no precision was lost casting to 'int'.\r\n            throw new NumberFormatException(\"Expected an int but was \" + peekedLong + locationString());\r\n        }\r\n        peeked = PEEKED_NONE;\r\n        pathIndices[stackSize - 1]++;\r\n        return result;\r\n    }\r\n    if (p == PEEKED_NUMBER) {\r\n        peekedString = new String(buffer, pos, peekedNumberLength);\r\n        pos += peekedNumberLength;\r\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\r\n        if (p == PEEKED_UNQUOTED) {\r\n            peekedString = nextUnquotedValue();\r\n        } else {\r\n            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\r\n        }\r\n        try {\r\n            result = Integer.parseInt(peekedString);\r\n            peeked = PEEKED_NONE;\r\n            pathIndices[stackSize - 1]++;\r\n            return result;\r\n        } catch (NumberFormatException ignored) {\r\n            // Fall back to parse as a double below.\r\n        }\r\n    } else {\r\n        throw unexpectedTokenError(\"an int\");\r\n    }\r\n    peeked = PEEKED_BUFFERED;\r\n    // don't catch this NumberFormatException.\r\n    double asDouble = Double.parseDouble(peekedString);\r\n    result = (int) asDouble;\r\n    if (result != asDouble) {\r\n        // Make sure no precision was lost casting to 'int'.\r\n        throw new NumberFormatException(\"Expected an int but was \" + peekedString + locationString());\r\n    }\r\n    peekedString = null;\r\n    peeked = PEEKED_NONE;\r\n    pathIndices[stackSize - 1]++;\r\n    return result;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "close",
    "start_line": 1367,
    "end_line": 1373,
    "code": "/**\r\n * Closes this JSON reader and the underlying {@link Reader}.\r\n *\r\n * <p>Using the JSON reader after it has been closed will throw an {@link IllegalStateException}\r\n * in most cases.\r\n */\r\n@Override\r\npublic void close() throws IOException {\r\n    peeked = PEEKED_NONE;\r\n    stack[0] = JsonScope.CLOSED;\r\n    stackSize = 1;\r\n    in.close();\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "skipValue",
    "start_line": 1391,
    "end_line": 1466,
    "code": "/**\r\n * Skips the next value recursively. This method is intended for use when the JSON token stream\r\n * contains unrecognized or unhandled values.\r\n *\r\n * <p>The behavior depends on the type of the next JSON token:\r\n *\r\n * <ul>\r\n *   <li>Start of a JSON array or object: It and all of its nested values are skipped.\r\n *   <li>Primitive value (for example a JSON number): The primitive value is skipped.\r\n *   <li>Property name: Only the name but not the value of the property is skipped. {@code\r\n *       skipValue()} has to be called again to skip the property value as well.\r\n *   <li>End of a JSON array or object: Only this end token is skipped.\r\n *   <li>End of JSON document: Skipping has no effect, the next token continues to be the end of\r\n *       the document.\r\n * </ul>\r\n */\r\npublic void skipValue() throws IOException {\r\n    int count = 0;\r\n    do {\r\n        int p = peeked;\r\n        if (p == PEEKED_NONE) {\r\n            p = doPeek();\r\n        }\r\n        switch(p) {\r\n            case PEEKED_BEGIN_ARRAY:\r\n                push(JsonScope.EMPTY_ARRAY);\r\n                count++;\r\n                break;\r\n            case PEEKED_BEGIN_OBJECT:\r\n                push(JsonScope.EMPTY_OBJECT);\r\n                count++;\r\n                break;\r\n            case PEEKED_END_ARRAY:\r\n                stackSize--;\r\n                count--;\r\n                break;\r\n            case PEEKED_END_OBJECT:\r\n                // Only update when object end is explicitly skipped, otherwise stack is not updated\r\n                // anyways\r\n                if (count == 0) {\r\n                    // Free the last path name so that it can be garbage collected\r\n                    pathNames[stackSize - 1] = null;\r\n                }\r\n                stackSize--;\r\n                count--;\r\n                break;\r\n            case PEEKED_UNQUOTED:\r\n                skipUnquotedValue();\r\n                break;\r\n            case PEEKED_SINGLE_QUOTED:\r\n                skipQuotedValue('\\'');\r\n                break;\r\n            case PEEKED_DOUBLE_QUOTED:\r\n                skipQuotedValue('\"');\r\n                break;\r\n            case PEEKED_UNQUOTED_NAME:\r\n                skipUnquotedValue();\r\n                // Only update when name is explicitly skipped, otherwise stack is not updated anyways\r\n                if (count == 0) {\r\n                    pathNames[stackSize - 1] = \"<skipped>\";\r\n                }\r\n                break;\r\n            case PEEKED_SINGLE_QUOTED_NAME:\r\n                skipQuotedValue('\\'');\r\n                // Only update when name is explicitly skipped, otherwise stack is not updated anyways\r\n                if (count == 0) {\r\n                    pathNames[stackSize - 1] = \"<skipped>\";\r\n                }\r\n                break;\r\n            case PEEKED_DOUBLE_QUOTED_NAME:\r\n                skipQuotedValue('\"');\r\n                // Only update when name is explicitly skipped, otherwise stack is not updated anyways\r\n                if (count == 0) {\r\n                    pathNames[stackSize - 1] = \"<skipped>\";\r\n                }\r\n                break;\r\n            case PEEKED_NUMBER:\r\n                pos += peekedNumberLength;\r\n                break;\r\n            case PEEKED_EOF:\r\n                // Do nothing\r\n                return;\r\n            default:\r\n        }\r\n        peeked = PEEKED_NONE;\r\n    } while (count > 0);\r\n    pathIndices[stackSize - 1]++;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "push",
    "start_line": 1468,
    "end_line": 1482,
    "code": "private void push(int newTop) throws MalformedJsonException {\r\n    // - 1 because stack contains as first element either EMPTY_DOCUMENT or NONEMPTY_DOCUMENT\r\n    if (stackSize - 1 >= nestingLimit) {\r\n        throw new MalformedJsonException(\"Nesting limit \" + nestingLimit + \" reached\" + locationString());\r\n    }\r\n    if (stackSize == stack.length) {\r\n        int newLength = stackSize * 2;\r\n        stack = Arrays.copyOf(stack, newLength);\r\n        pathIndices = Arrays.copyOf(pathIndices, newLength);\r\n        pathNames = Arrays.copyOf(pathNames, newLength);\r\n    }\r\n    stack[stackSize++] = newTop;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "fillBuffer",
    "start_line": 1488,
    "end_line": 1515,
    "code": "/**\r\n * Returns true once {@code limit - pos >= minimum}. If the data is exhausted before that many\r\n * characters are available, this returns false.\r\n */\r\nprivate boolean fillBuffer(int minimum) throws IOException {\r\n    char[] buffer = this.buffer;\r\n    lineStart -= pos;\r\n    if (limit != pos) {\r\n        limit -= pos;\r\n        System.arraycopy(buffer, pos, buffer, 0, limit);\r\n    } else {\r\n        limit = 0;\r\n    }\r\n    pos = 0;\r\n    int total;\r\n    while ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\r\n        limit += total;\r\n        // if this is the first read, consume an optional byte order mark (BOM) if it exists\r\n        if (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\r\n            pos++;\r\n            lineStart++;\r\n            minimum++;\r\n        }\r\n        if (limit >= minimum) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "nextNonWhitespace",
    "start_line": 1522,
    "end_line": 1609,
    "code": "/**\r\n * Returns the next character in the stream that is neither whitespace nor a part of a comment.\r\n * When this returns, the returned character is always at {@code buffer[pos-1]}; this means the\r\n * caller can always push back the returned character by decrementing {@code pos}.\r\n */\r\nprivate int nextNonWhitespace(boolean throwOnEof) throws IOException {\r\n    /*\r\n     * This code uses ugly local variables 'p' and 'l' representing the 'pos'\r\n     * and 'limit' fields respectively. Using locals rather than fields saves\r\n     * a few field reads for each whitespace character in a pretty-printed\r\n     * document, resulting in a 5% speedup. We need to flush 'p' to its field\r\n     * before any (potentially indirect) call to fillBuffer() and reread both\r\n     * 'p' and 'l' after any (potentially indirect) call to the same method.\r\n     */\r\n    char[] buffer = this.buffer;\r\n    int p = pos;\r\n    int l = limit;\r\n    while (true) {\r\n        if (p == l) {\r\n            pos = p;\r\n            if (!fillBuffer(1)) {\r\n                break;\r\n            }\r\n            p = pos;\r\n            l = limit;\r\n        }\r\n        int c = buffer[p++];\r\n        if (c == '\\n') {\r\n            lineNumber++;\r\n            lineStart = p;\r\n            continue;\r\n        } else if (c == ' ' || c == '\\r' || c == '\\t') {\r\n            continue;\r\n        }\r\n        if (c == '/') {\r\n            pos = p;\r\n            if (p == l) {\r\n                // push back '/' so it's still in the buffer when this method returns\r\n                pos--;\r\n                boolean charsLoaded = fillBuffer(2);\r\n                // consume the '/' again\r\n                pos++;\r\n                if (!charsLoaded) {\r\n                    return c;\r\n                }\r\n            }\r\n            checkLenient();\r\n            char peek = buffer[pos];\r\n            switch(peek) {\r\n                case '*':\r\n                    // skip a /* c-style comment */\r\n                    pos++;\r\n                    if (!skipTo(\"*/\")) {\r\n                        throw syntaxError(\"Unterminated comment\");\r\n                    }\r\n                    p = pos + 2;\r\n                    l = limit;\r\n                    continue;\r\n                case '/':\r\n                    // skip a // end-of-line comment\r\n                    pos++;\r\n                    skipToEndOfLine();\r\n                    p = pos;\r\n                    l = limit;\r\n                    continue;\r\n                default:\r\n                    return c;\r\n            }\r\n        } else if (c == '#') {\r\n            pos = p;\r\n            /*\r\n         * Skip a # hash end-of-line comment. The JSON RFC doesn't\r\n         * specify this behaviour, but it's required to parse\r\n         * existing documents. See http://b/2571423.\r\n         */\r\n            checkLenient();\r\n            skipToEndOfLine();\r\n            p = pos;\r\n            l = limit;\r\n        } else {\r\n            pos = p;\r\n            return c;\r\n        }\r\n    }\r\n    if (throwOnEof) {\r\n        throw new EOFException(\"End of input\" + locationString());\r\n    } else {\r\n        return -1;\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "checkLenient",
    "start_line": 1611,
    "end_line": 1616,
    "code": "private void checkLenient() throws MalformedJsonException {\r\n    if (strictness != Strictness.LENIENT) {\r\n        throw syntaxError(\"Use JsonReader.setStrictness(Strictness.LENIENT) to accept malformed JSON\");\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "skipToEndOfLine",
    "start_line": 1622,
    "end_line": 1633,
    "code": "/**\r\n * Advances the position until after the next newline character. If the line is terminated by\r\n * \"\\r\\n\", the '\\n' must be consumed as whitespace by the caller.\r\n */\r\nprivate void skipToEndOfLine() throws IOException {\r\n    while (pos < limit || fillBuffer(1)) {\r\n        char c = buffer[pos++];\r\n        if (c == '\\n') {\r\n            lineNumber++;\r\n            lineStart = pos;\r\n            break;\r\n        } else if (c == '\\r') {\r\n            break;\r\n        }\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "skipTo",
    "start_line": 1638,
    "end_line": 1655,
    "code": "/**\r\n * @param toFind a string to search for. Must not contain a newline.\r\n */\r\nprivate boolean skipTo(String toFind) throws IOException {\r\n    int length = toFind.length();\r\n    outer: for (; pos + length <= limit || fillBuffer(length); pos++) {\r\n        if (buffer[pos] == '\\n') {\r\n            lineNumber++;\r\n            lineStart = pos + 1;\r\n            continue;\r\n        }\r\n        for (int c = 0; c < length; c++) {\r\n            if (buffer[pos + c] != toFind.charAt(c)) {\r\n                continue outer;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "toString",
    "start_line": 1657,
    "end_line": 1660,
    "code": "@Override\r\npublic String toString() {\r\n    return getClass().getSimpleName() + locationString();\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "locationString",
    "start_line": 1662,
    "end_line": 1666,
    "code": "String locationString() {\r\n    int line = lineNumber + 1;\r\n    int column = pos - lineStart + 1;\r\n    return \" at line \" + line + \" column \" + column + \" path \" + getPath();\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "getPath",
    "start_line": 1668,
    "end_line": 1699,
    "code": "private String getPath(boolean usePreviousPath) {\r\n    StringBuilder result = new StringBuilder().append('$');\r\n    for (int i = 0; i < stackSize; i++) {\r\n        int scope = stack[i];\r\n        switch(scope) {\r\n            case JsonScope.EMPTY_ARRAY:\r\n            case JsonScope.NONEMPTY_ARRAY:\r\n                int pathIndex = pathIndices[i];\r\n                // If index is last path element it points to next array element; have to decrement\r\n                if (usePreviousPath && pathIndex > 0 && i == stackSize - 1) {\r\n                    pathIndex--;\r\n                }\r\n                result.append('[').append(pathIndex).append(']');\r\n                break;\r\n            case JsonScope.EMPTY_OBJECT:\r\n            case JsonScope.DANGLING_NAME:\r\n            case JsonScope.NONEMPTY_OBJECT:\r\n                result.append('.');\r\n                if (pathNames[i] != null) {\r\n                    result.append(pathNames[i]);\r\n                }\r\n                break;\r\n            case JsonScope.NONEMPTY_DOCUMENT:\r\n            case JsonScope.EMPTY_DOCUMENT:\r\n            case JsonScope.CLOSED:\r\n                break;\r\n            default:\r\n                throw new AssertionError(\"Unknown scope value: \" + scope);\r\n        }\r\n    }\r\n    return result.toString();\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "getPath",
    "start_line": 1715,
    "end_line": 1717,
    "code": "/**\r\n * Returns a <a href=\"https://goessner.net/articles/JsonPath/\">JSONPath</a> in <i>dot-notation</i>\r\n * to the next (or current) location in the JSON document. That means:\r\n *\r\n * <ul>\r\n *   <li>For JSON arrays the path points to the index of the next element (even if there are no\r\n *       further elements).\r\n *   <li>For JSON objects the path points to the last property, or to the current property if its\r\n *       name has already been consumed.\r\n * </ul>\r\n *\r\n * <p>This method can be useful to add additional context to exception messages <i>before</i> a\r\n * value is consumed, for example when the {@linkplain #peek() peeked} token is unexpected.\r\n */\r\npublic String getPath() {\r\n    return getPath(false);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "getPreviousPath",
    "start_line": 1733,
    "end_line": 1735,
    "code": "/**\r\n * Returns a <a href=\"https://goessner.net/articles/JsonPath/\">JSONPath</a> in <i>dot-notation</i>\r\n * to the previous (or current) location in the JSON document. That means:\r\n *\r\n * <ul>\r\n *   <li>For JSON arrays the path points to the index of the previous element.<br>\r\n *       If no element has been consumed yet it uses the index 0 (even if there are no elements).\r\n *   <li>For JSON objects the path points to the last property, or to the current property if its\r\n *       name has already been consumed.\r\n * </ul>\r\n *\r\n * <p>This method can be useful to add additional context to exception messages <i>after</i> a\r\n * value has been consumed.\r\n */\r\npublic String getPreviousPath() {\r\n    return getPath(true);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "readEscapeCharacter",
    "start_line": 1744,
    "end_line": 1809,
    "code": "/**\r\n * Unescapes the character identified by the character or characters that immediately follow a\r\n * backslash. The backslash '\\' should have already been read. This supports both Unicode escapes\r\n * \"u000A\" and two-character escapes \"\\n\".\r\n *\r\n * @throws MalformedJsonException if the escape sequence is malformed\r\n */\r\n@SuppressWarnings(\"fallthrough\")\r\nprivate char readEscapeCharacter() throws IOException {\r\n    if (pos == limit && !fillBuffer(1)) {\r\n        throw syntaxError(\"Unterminated escape sequence\");\r\n    }\r\n    char escaped = buffer[pos++];\r\n    switch(escaped) {\r\n        case 'u':\r\n            if (pos + 4 > limit && !fillBuffer(4)) {\r\n                throw syntaxError(\"Unterminated escape sequence\");\r\n            }\r\n            // Equivalent to Integer.parseInt(stringPool.get(buffer, pos, 4), 16);\r\n            int result = 0;\r\n            for (int i = pos, end = i + 4; i < end; i++) {\r\n                char c = buffer[i];\r\n                result <<= 4;\r\n                if (c >= '0' && c <= '9') {\r\n                    result += (c - '0');\r\n                } else if (c >= 'a' && c <= 'f') {\r\n                    result += (c - 'a' + 10);\r\n                } else if (c >= 'A' && c <= 'F') {\r\n                    result += (c - 'A' + 10);\r\n                } else {\r\n                    throw syntaxError(\"Malformed Unicode escape \\\\u\" + new String(buffer, pos, 4));\r\n                }\r\n            }\r\n            pos += 4;\r\n            return (char) result;\r\n        case 't':\r\n            return '\\t';\r\n        case 'b':\r\n            return '\\b';\r\n        case 'n':\r\n            return '\\n';\r\n        case 'r':\r\n            return '\\r';\r\n        case 'f':\r\n            return '\\f';\r\n        case '\\n':\r\n            if (strictness == Strictness.STRICT) {\r\n                throw syntaxError(\"Cannot escape a newline character in strict mode\");\r\n            }\r\n            lineNumber++;\r\n            lineStart = pos;\r\n        // fall-through\r\n        case '\\'':\r\n            if (strictness == Strictness.STRICT) {\r\n                throw syntaxError(\"Invalid escaped character \\\"'\\\" in strict mode\");\r\n            }\r\n        case '\"':\r\n        case '\\\\':\r\n        case '/':\r\n            return escaped;\r\n        default:\r\n            // throw error when none of the above cases are matched\r\n            throw syntaxError(\"Invalid escape sequence\");\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "syntaxError",
    "start_line": 1815,
    "end_line": 1818,
    "code": "/**\r\n * Throws a new {@link MalformedJsonException} with the given message and information about the\r\n * current location.\r\n */\r\nprivate MalformedJsonException syntaxError(String message) throws MalformedJsonException {\r\n    throw new MalformedJsonException(message + locationString() + \"\\nSee \" + TroubleshootingGuide.createUrl(\"malformed-json\"));\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "unexpectedTokenError",
    "start_line": 1820,
    "end_line": 1832,
    "code": "private IllegalStateException unexpectedTokenError(String expected) throws IOException {\r\n    JsonToken peeked = peek();\r\n    String troubleshootingId = peeked == JsonToken.NULL ? \"adapter-not-null-safe\" : \"unexpected-json-structure\";\r\n    return new IllegalStateException(\"Expected \" + expected + \" but was \" + peek() + locationString() + \"\\nSee \" + TroubleshootingGuide.createUrl(troubleshootingId));\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  },
  {
    "type": "method",
    "name": "consumeNonExecutePrefix",
    "start_line": 1835,
    "end_line": 1856,
    "code": "/**\r\n * Consumes the non-execute prefix if it exists.\r\n */\r\nprivate void consumeNonExecutePrefix() throws IOException {\r\n    // fast-forward through the leading whitespace\r\n    int unused = nextNonWhitespace(true);\r\n    pos--;\r\n    if (pos + 5 > limit && !fillBuffer(5)) {\r\n        return;\r\n    }\r\n    int p = pos;\r\n    char[] buf = buffer;\r\n    if (buf[p] != ')' || buf[p + 1] != ']' || buf[p + 2] != '}' || buf[p + 3] != '\\'' || buf[p + 4] != '\\n') {\r\n        // not a security token!\r\n        return;\r\n    }\r\n    // we consumed a security token!\r\n    pos += 5;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\stream\\JsonReader.java"
  }
]