[
  {
    "type": "package",
    "name": "com.google.gson",
    "start_line": 17,
    "end_line": 17,
    "code": "package com.google.gson;\r\n\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.Gson.DEFAULT_COMPLEX_MAP_KEYS",
    "start_line": 19,
    "end_line": 19,
    "code": "import static com.google.gson.Gson.DEFAULT_COMPLEX_MAP_KEYS;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.Gson.DEFAULT_DATE_PATTERN",
    "start_line": 20,
    "end_line": 20,
    "code": "import static com.google.gson.Gson.DEFAULT_DATE_PATTERN;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.Gson.DEFAULT_ESCAPE_HTML",
    "start_line": 21,
    "end_line": 21,
    "code": "import static com.google.gson.Gson.DEFAULT_ESCAPE_HTML;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.Gson.DEFAULT_FORMATTING_STYLE",
    "start_line": 22,
    "end_line": 22,
    "code": "import static com.google.gson.Gson.DEFAULT_FORMATTING_STYLE;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.Gson.DEFAULT_JSON_NON_EXECUTABLE",
    "start_line": 23,
    "end_line": 23,
    "code": "import static com.google.gson.Gson.DEFAULT_JSON_NON_EXECUTABLE;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.Gson.DEFAULT_NUMBER_TO_NUMBER_STRATEGY",
    "start_line": 24,
    "end_line": 24,
    "code": "import static com.google.gson.Gson.DEFAULT_NUMBER_TO_NUMBER_STRATEGY;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.Gson.DEFAULT_OBJECT_TO_NUMBER_STRATEGY",
    "start_line": 25,
    "end_line": 25,
    "code": "import static com.google.gson.Gson.DEFAULT_OBJECT_TO_NUMBER_STRATEGY;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.Gson.DEFAULT_SERIALIZE_NULLS",
    "start_line": 26,
    "end_line": 26,
    "code": "import static com.google.gson.Gson.DEFAULT_SERIALIZE_NULLS;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.Gson.DEFAULT_SPECIALIZE_FLOAT_VALUES",
    "start_line": 27,
    "end_line": 27,
    "code": "import static com.google.gson.Gson.DEFAULT_SPECIALIZE_FLOAT_VALUES;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.Gson.DEFAULT_STRICTNESS",
    "start_line": 28,
    "end_line": 28,
    "code": "import static com.google.gson.Gson.DEFAULT_STRICTNESS;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.Gson.DEFAULT_USE_JDK_UNSAFE",
    "start_line": 29,
    "end_line": 29,
    "code": "import static com.google.gson.Gson.DEFAULT_USE_JDK_UNSAFE;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "import",
    "name": "com.google.errorprone.annotations.CanIgnoreReturnValue",
    "start_line": 31,
    "end_line": 31,
    "code": "import com.google.errorprone.annotations.CanIgnoreReturnValue;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "import",
    "name": "com.google.errorprone.annotations.InlineMe",
    "start_line": 32,
    "end_line": 32,
    "code": "import com.google.errorprone.annotations.InlineMe;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.annotations.Since",
    "start_line": 33,
    "end_line": 33,
    "code": "import com.google.gson.annotations.Since;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.annotations.Until",
    "start_line": 34,
    "end_line": 34,
    "code": "import com.google.gson.annotations.Until;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.internal.Excluder",
    "start_line": 35,
    "end_line": 35,
    "code": "import com.google.gson.internal.Excluder;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.internal.bind.DefaultDateTypeAdapter",
    "start_line": 36,
    "end_line": 36,
    "code": "import com.google.gson.internal.bind.DefaultDateTypeAdapter;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.internal.bind.TreeTypeAdapter",
    "start_line": 37,
    "end_line": 37,
    "code": "import com.google.gson.internal.bind.TreeTypeAdapter;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.internal.bind.TypeAdapters",
    "start_line": 38,
    "end_line": 38,
    "code": "import com.google.gson.internal.bind.TypeAdapters;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.internal.sql.SqlTypesSupport",
    "start_line": 39,
    "end_line": 39,
    "code": "import com.google.gson.internal.sql.SqlTypesSupport;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.reflect.TypeToken",
    "start_line": 40,
    "end_line": 40,
    "code": "import com.google.gson.reflect.TypeToken;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.stream.JsonReader",
    "start_line": 41,
    "end_line": 41,
    "code": "import com.google.gson.stream.JsonReader;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.stream.JsonWriter",
    "start_line": 42,
    "end_line": 42,
    "code": "import com.google.gson.stream.JsonWriter;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "import",
    "name": "java.lang.reflect.Type",
    "start_line": 43,
    "end_line": 43,
    "code": "import java.lang.reflect.Type;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "import",
    "name": "java.text.DateFormat",
    "start_line": 44,
    "end_line": 44,
    "code": "import java.text.DateFormat;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "import",
    "name": "java.text.SimpleDateFormat",
    "start_line": 45,
    "end_line": 45,
    "code": "import java.text.SimpleDateFormat;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "import",
    "name": "java.util.ArrayDeque",
    "start_line": 46,
    "end_line": 46,
    "code": "import java.util.ArrayDeque;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "import",
    "name": "java.util.ArrayList",
    "start_line": 47,
    "end_line": 47,
    "code": "import java.util.ArrayList;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "import",
    "name": "java.util.Collections",
    "start_line": 48,
    "end_line": 48,
    "code": "import java.util.Collections;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "import",
    "name": "java.util.Date",
    "start_line": 49,
    "end_line": 49,
    "code": "import java.util.Date;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "import",
    "name": "java.util.HashMap",
    "start_line": 50,
    "end_line": 50,
    "code": "import java.util.HashMap;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "import",
    "name": "java.util.List",
    "start_line": 51,
    "end_line": 51,
    "code": "import java.util.List;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "import",
    "name": "java.util.Map",
    "start_line": 52,
    "end_line": 52,
    "code": "import java.util.Map;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "import",
    "name": "java.util.Objects",
    "start_line": 53,
    "end_line": 53,
    "code": "import java.util.Objects;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "class",
    "name": "GsonBuilder",
    "start_line": 92,
    "end_line": 957,
    "code": "/**\r\n * Use this builder to construct a {@link Gson} instance when you need to set configuration options\r\n * other than the default. For {@link Gson} with default configuration, it is simpler to use {@code\r\n * new Gson()}. {@code GsonBuilder} is best used by creating it, and then invoking its various\r\n * configuration methods, and finally calling create.\r\n *\r\n * <p>The following example shows how to use the {@code GsonBuilder} to construct a Gson instance:\r\n *\r\n * <pre>\r\n * Gson gson = new GsonBuilder()\r\n *     .registerTypeAdapter(Id.class, new IdTypeAdapter())\r\n *     .enableComplexMapKeySerialization()\r\n *     .serializeNulls()\r\n *     .setDateFormat(DateFormat.LONG, DateFormat.LONG)\r\n *     .setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)\r\n *     .setPrettyPrinting()\r\n *     .setVersion(1.0)\r\n *     .create();\r\n * </pre>\r\n *\r\n * <p>Notes:\r\n *\r\n * <ul>\r\n *   <li>The order of invocation of configuration methods does not matter.\r\n *   <li>The default serialization of {@link Date} and its subclasses in Gson does not contain\r\n *       time-zone information. So, if you are using date/time instances, use {@code GsonBuilder}\r\n *       and its {@code setDateFormat} methods.\r\n *   <li>By default no explicit {@link Strictness} is set; some of the {@link Gson} methods behave\r\n *       as if {@link Strictness#LEGACY_STRICT} was used whereas others behave as if {@link\r\n *       Strictness#LENIENT} was used. Prefer explicitly setting a strictness with {@link\r\n *       #setStrictness(Strictness)} to avoid this legacy behavior.\r\n * </ul>\r\n *\r\n * @author Inderjeet Singh\r\n * @author Joel Leitch\r\n * @author Jesse Wilson\r\n */\r\npublic final class GsonBuilder {\r\n\r\n    private Excluder excluder = Excluder.DEFAULT;\r\n\r\n    private LongSerializationPolicy longSerializationPolicy = LongSerializationPolicy.DEFAULT;\r\n\r\n    private FieldNamingStrategy fieldNamingPolicy = FieldNamingPolicy.IDENTITY;\r\n\r\n    private final Map<Type, InstanceCreator<?>> instanceCreators = new HashMap<>();\r\n\r\n    private final List<TypeAdapterFactory> factories = new ArrayList<>();\r\n\r\n    /**\r\n     * tree-style hierarchy factories. These come after factories for backwards compatibility.\r\n     */\r\n    private final List<TypeAdapterFactory> hierarchyFactories = new ArrayList<>();\r\n\r\n    private boolean serializeNulls = DEFAULT_SERIALIZE_NULLS;\r\n\r\n    private String datePattern = DEFAULT_DATE_PATTERN;\r\n\r\n    private int dateStyle = DateFormat.DEFAULT;\r\n\r\n    private int timeStyle = DateFormat.DEFAULT;\r\n\r\n    private boolean complexMapKeySerialization = DEFAULT_COMPLEX_MAP_KEYS;\r\n\r\n    private boolean serializeSpecialFloatingPointValues = DEFAULT_SPECIALIZE_FLOAT_VALUES;\r\n\r\n    private boolean escapeHtmlChars = DEFAULT_ESCAPE_HTML;\r\n\r\n    private FormattingStyle formattingStyle = DEFAULT_FORMATTING_STYLE;\r\n\r\n    private boolean generateNonExecutableJson = DEFAULT_JSON_NON_EXECUTABLE;\r\n\r\n    private Strictness strictness = DEFAULT_STRICTNESS;\r\n\r\n    private boolean useJdkUnsafe = DEFAULT_USE_JDK_UNSAFE;\r\n\r\n    private ToNumberStrategy objectToNumberStrategy = DEFAULT_OBJECT_TO_NUMBER_STRATEGY;\r\n\r\n    private ToNumberStrategy numberToNumberStrategy = DEFAULT_NUMBER_TO_NUMBER_STRATEGY;\r\n\r\n    private final ArrayDeque<ReflectionAccessFilter> reflectionFilters = new ArrayDeque<>();\r\n\r\n    /**\r\n     * Creates a GsonBuilder instance that can be used to build Gson with various configuration\r\n     * settings. GsonBuilder follows the builder pattern, and it is typically used by first invoking\r\n     * various configuration methods to set desired options, and finally calling {@link #create()}.\r\n     */\r\n    public GsonBuilder() {\r\n    }\r\n\r\n    /**\r\n     * Constructs a GsonBuilder instance from a Gson instance. The newly constructed GsonBuilder has\r\n     * the same configuration as the previously built Gson instance.\r\n     *\r\n     * @param gson the gson instance whose configuration should be applied to a new GsonBuilder.\r\n     */\r\n    GsonBuilder(Gson gson) {\r\n        this.excluder = gson.excluder;\r\n        this.fieldNamingPolicy = gson.fieldNamingStrategy;\r\n        this.instanceCreators.putAll(gson.instanceCreators);\r\n        this.serializeNulls = gson.serializeNulls;\r\n        this.complexMapKeySerialization = gson.complexMapKeySerialization;\r\n        this.generateNonExecutableJson = gson.generateNonExecutableJson;\r\n        this.escapeHtmlChars = gson.htmlSafe;\r\n        this.formattingStyle = gson.formattingStyle;\r\n        this.strictness = gson.strictness;\r\n        this.serializeSpecialFloatingPointValues = gson.serializeSpecialFloatingPointValues;\r\n        this.longSerializationPolicy = gson.longSerializationPolicy;\r\n        this.datePattern = gson.datePattern;\r\n        this.dateStyle = gson.dateStyle;\r\n        this.timeStyle = gson.timeStyle;\r\n        this.factories.addAll(gson.builderFactories);\r\n        this.hierarchyFactories.addAll(gson.builderHierarchyFactories);\r\n        this.useJdkUnsafe = gson.useJdkUnsafe;\r\n        this.objectToNumberStrategy = gson.objectToNumberStrategy;\r\n        this.numberToNumberStrategy = gson.numberToNumberStrategy;\r\n        this.reflectionFilters.addAll(gson.reflectionFilters);\r\n    }\r\n\r\n    /**\r\n     * Configures Gson to enable versioning support. Versioning support works based on the annotation\r\n     * types {@link Since} and {@link Until}. It allows including or excluding fields and classes\r\n     * based on the specified version. See the documentation of these annotation types for more\r\n     * information.\r\n     *\r\n     * <p>By default versioning support is disabled and usage of {@code @Since} and {@code @Until} has\r\n     * no effect.\r\n     *\r\n     * @param version the version number to use.\r\n     * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n     * @throws IllegalArgumentException if the version number is NaN or negative\r\n     * @see Since\r\n     * @see Until\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public GsonBuilder setVersion(double version) {\r\n        if (Double.isNaN(version) || version < 0.0) {\r\n            throw new IllegalArgumentException(\"Invalid version: \" + version);\r\n        }\r\n        excluder = excluder.withVersion(version);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Configures Gson to excludes all class fields that have the specified modifiers. By default,\r\n     * Gson will exclude all fields marked {@code transient} or {@code static}. This method will\r\n     * override that behavior.\r\n     *\r\n     * <p>This is a convenience method which behaves as if an {@link ExclusionStrategy} which excludes\r\n     * these fields was {@linkplain #setExclusionStrategies(ExclusionStrategy...) registered with this\r\n     * builder}.\r\n     *\r\n     * @param modifiers the field modifiers. You must use the modifiers specified in the {@link\r\n     *     java.lang.reflect.Modifier} class. For example, {@link\r\n     *     java.lang.reflect.Modifier#TRANSIENT}, {@link java.lang.reflect.Modifier#STATIC}.\r\n     * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public GsonBuilder excludeFieldsWithModifiers(int... modifiers) {\r\n        Objects.requireNonNull(modifiers);\r\n        excluder = excluder.withModifiers(modifiers);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Makes the output JSON non-executable in Javascript by prefixing the generated JSON with some\r\n     * special text. This prevents attacks from third-party sites through script sourcing. See <a\r\n     * href=\"http://code.google.com/p/google-gson/issues/detail?id=42\">Gson Issue 42</a> for details.\r\n     *\r\n     * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n     * @since 1.3\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public GsonBuilder generateNonExecutableJson() {\r\n        this.generateNonExecutableJson = true;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Configures Gson to exclude all fields from consideration for serialization and deserialization\r\n     * that do not have the {@link com.google.gson.annotations.Expose} annotation.\r\n     *\r\n     * <p>This is a convenience method which behaves as if an {@link ExclusionStrategy} which excludes\r\n     * these fields was {@linkplain #setExclusionStrategies(ExclusionStrategy...) registered with this\r\n     * builder}.\r\n     *\r\n     * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public GsonBuilder excludeFieldsWithoutExposeAnnotation() {\r\n        excluder = excluder.excludeFieldsWithoutExposeAnnotation();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Configures Gson to serialize null fields. By default, Gson omits all fields that are null\r\n     * during serialization.\r\n     *\r\n     * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n     * @since 1.2\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public GsonBuilder serializeNulls() {\r\n        this.serializeNulls = true;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Configures Gson to serialize {@code Map} objects with complex keys as JSON arrays. Enabling\r\n     * this feature will only change the serialized form if the map key is a complex type (i.e.\r\n     * non-primitive) in its <strong>serialized</strong> JSON form. The default implementation of map\r\n     * serialization uses {@code toString()} on the key; however, when this is called then one of the\r\n     * following cases apply:\r\n     *\r\n     * <p><b>Maps as JSON objects</b>\r\n     *\r\n     * <p>For this case, assume that a type adapter is registered to serialize and deserialize some\r\n     * {@code Point} class, which contains an x and y coordinate, to/from the JSON Primitive string\r\n     * value {@code \"(x,y)\"}. The Java map would then be serialized as a {@link JsonObject}.\r\n     *\r\n     * <p>Below is an example:\r\n     *\r\n     * <pre>{@code\r\n     * Gson gson = new GsonBuilder()\r\n     *     .register(Point.class, new MyPointTypeAdapter())\r\n     *     .enableComplexMapKeySerialization()\r\n     *     .create();\r\n     *\r\n     * Map<Point, String> original = new LinkedHashMap<>();\r\n     * original.put(new Point(5, 6), \"a\");\r\n     * original.put(new Point(8, 8), \"b\");\r\n     * System.out.println(gson.toJson(original, type));\r\n     * }</pre>\r\n     *\r\n     * The above code prints this JSON object:\r\n     *\r\n     * <pre>{@code\r\n     * {\r\n     *   \"(5,6)\": \"a\",\r\n     *   \"(8,8)\": \"b\"\r\n     * }\r\n     * }</pre>\r\n     *\r\n     * <p><b>Maps as JSON arrays</b>\r\n     *\r\n     * <p>For this case, assume that a type adapter was NOT registered for some {@code Point} class,\r\n     * but rather the default Gson serialization is applied. In this case, some {@code new Point(2,3)}\r\n     * would serialize as {@code {\"x\":2,\"y\":3}}.\r\n     *\r\n     * <p>Given the assumption above, a {@code Map<Point, String>} will be serialized as an array of\r\n     * arrays (can be viewed as an entry set of pairs).\r\n     *\r\n     * <p>Below is an example of serializing complex types as JSON arrays:\r\n     *\r\n     * <pre>{@code\r\n     * Gson gson = new GsonBuilder()\r\n     *     .enableComplexMapKeySerialization()\r\n     *     .create();\r\n     *\r\n     * Map<Point, String> original = new LinkedHashMap<>();\r\n     * original.put(new Point(5, 6), \"a\");\r\n     * original.put(new Point(8, 8), \"b\");\r\n     * System.out.println(gson.toJson(original, type));\r\n     * }</pre>\r\n     *\r\n     * The JSON output would look as follows:\r\n     *\r\n     * <pre>{@code\r\n     * [\r\n     *   [\r\n     *     {\r\n     *       \"x\": 5,\r\n     *       \"y\": 6\r\n     *     },\r\n     *     \"a\"\r\n     *   ],\r\n     *   [\r\n     *     {\r\n     *       \"x\": 8,\r\n     *       \"y\": 8\r\n     *     },\r\n     *     \"b\"\r\n     *   ]\r\n     * ]\r\n     * }</pre>\r\n     *\r\n     * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n     * @since 1.7\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public GsonBuilder enableComplexMapKeySerialization() {\r\n        complexMapKeySerialization = true;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Configures Gson to exclude inner classes (= non-{@code static} nested classes) during\r\n     * serialization and deserialization. This is a convenience method which behaves as if an {@link\r\n     * ExclusionStrategy} which excludes inner classes was {@linkplain\r\n     * #setExclusionStrategies(ExclusionStrategy...) registered with this builder}. This means inner\r\n     * classes will be serialized as JSON {@code null}, and will be deserialized as Java {@code null}\r\n     * with their JSON data being ignored. And fields with an inner class as type will be ignored\r\n     * during serialization and deserialization.\r\n     *\r\n     * <p>By default Gson serializes and deserializes inner classes, but ignores references to the\r\n     * enclosing instance. Deserialization might not be possible at all when {@link\r\n     * #disableJdkUnsafe()} is used (and no custom {@link InstanceCreator} is registered), or it can\r\n     * lead to unexpected {@code NullPointerException}s when the deserialized instance is used\r\n     * afterwards.\r\n     *\r\n     * <p>In general using inner classes with Gson should be avoided; they should be converted to\r\n     * {@code static} nested classes if possible.\r\n     *\r\n     * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n     * @since 1.3\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public GsonBuilder disableInnerClassSerialization() {\r\n        excluder = excluder.disableInnerClassSerialization();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Configures Gson to apply a specific serialization policy for {@code Long} and {@code long}\r\n     * objects.\r\n     *\r\n     * @param serializationPolicy the particular policy to use for serializing longs.\r\n     * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n     * @since 1.3\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public GsonBuilder setLongSerializationPolicy(LongSerializationPolicy serializationPolicy) {\r\n        this.longSerializationPolicy = Objects.requireNonNull(serializationPolicy);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Configures Gson to apply a specific naming policy to an object's fields during serialization\r\n     * and deserialization.\r\n     *\r\n     * <p>This method just delegates to {@link #setFieldNamingStrategy(FieldNamingStrategy)}.\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention) {\r\n        return setFieldNamingStrategy(namingConvention);\r\n    }\r\n\r\n    /**\r\n     * Configures Gson to apply a specific naming strategy to an object's fields during serialization\r\n     * and deserialization.\r\n     *\r\n     * <p>The created Gson instance might only use the field naming strategy once for a field and\r\n     * cache the result. It is not guaranteed that the strategy will be used again every time the\r\n     * value of a field is serialized or deserialized.\r\n     *\r\n     * @param fieldNamingStrategy the naming strategy to apply to the fields\r\n     * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n     * @since 1.3\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrategy) {\r\n        this.fieldNamingPolicy = Objects.requireNonNull(fieldNamingStrategy);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Configures Gson to apply a specific number strategy during deserialization of {@link Object}.\r\n     *\r\n     * @param objectToNumberStrategy the actual object-to-number strategy\r\n     * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n     * @see ToNumberPolicy#DOUBLE The default object-to-number strategy\r\n     * @since 2.8.9\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public GsonBuilder setObjectToNumberStrategy(ToNumberStrategy objectToNumberStrategy) {\r\n        this.objectToNumberStrategy = Objects.requireNonNull(objectToNumberStrategy);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Configures Gson to apply a specific number strategy during deserialization of {@link Number}.\r\n     *\r\n     * @param numberToNumberStrategy the actual number-to-number strategy\r\n     * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n     * @see ToNumberPolicy#LAZILY_PARSED_NUMBER The default number-to-number strategy\r\n     * @since 2.8.9\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public GsonBuilder setNumberToNumberStrategy(ToNumberStrategy numberToNumberStrategy) {\r\n        this.numberToNumberStrategy = Objects.requireNonNull(numberToNumberStrategy);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Configures Gson to apply a set of exclusion strategies during both serialization and\r\n     * deserialization. Each of the {@code strategies} will be applied as a disjunction rule. This\r\n     * means that if one of the {@code strategies} suggests that a field (or class) should be skipped\r\n     * then that field (or object) is skipped during serialization/deserialization. The strategies are\r\n     * added to the existing strategies (if any); the existing strategies are not replaced.\r\n     *\r\n     * <p>Fields are excluded for serialization and deserialization when {@link\r\n     * ExclusionStrategy#shouldSkipField(FieldAttributes) shouldSkipField} returns {@code true}, or\r\n     * when {@link ExclusionStrategy#shouldSkipClass(Class) shouldSkipClass} returns {@code true} for\r\n     * the field type. Gson behaves as if the field did not exist; its value is not serialized and on\r\n     * deserialization if a JSON member with this name exists it is skipped by default.<br>\r\n     * When objects of an excluded type (as determined by {@link\r\n     * ExclusionStrategy#shouldSkipClass(Class) shouldSkipClass}) are serialized a JSON null is\r\n     * written to output, and when deserialized the JSON value is skipped and {@code null} is\r\n     * returned.\r\n     *\r\n     * <p>The created Gson instance might only use an exclusion strategy once for a field or class and\r\n     * cache the result. It is not guaranteed that the strategy will be used again every time the\r\n     * value of a field or a class is serialized or deserialized.\r\n     *\r\n     * @param strategies the set of strategy object to apply during object (de)serialization.\r\n     * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n     * @since 1.4\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public GsonBuilder setExclusionStrategies(ExclusionStrategy... strategies) {\r\n        Objects.requireNonNull(strategies);\r\n        for (ExclusionStrategy strategy : strategies) {\r\n            excluder = excluder.withExclusionStrategy(strategy, true, true);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Configures Gson to apply the passed in exclusion strategy during serialization. If this method\r\n     * is invoked numerous times with different exclusion strategy objects then the exclusion\r\n     * strategies that were added will be applied as a disjunction rule. This means that if one of the\r\n     * added exclusion strategies suggests that a field (or class) should be skipped then that field\r\n     * (or object) is skipped during its serialization.\r\n     *\r\n     * <p>See the documentation of {@link #setExclusionStrategies(ExclusionStrategy...)} for a\r\n     * detailed description of the effect of exclusion strategies.\r\n     *\r\n     * @param strategy an exclusion strategy to apply during serialization.\r\n     * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n     * @since 1.7\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public GsonBuilder addSerializationExclusionStrategy(ExclusionStrategy strategy) {\r\n        Objects.requireNonNull(strategy);\r\n        excluder = excluder.withExclusionStrategy(strategy, true, false);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Configures Gson to apply the passed in exclusion strategy during deserialization. If this\r\n     * method is invoked numerous times with different exclusion strategy objects then the exclusion\r\n     * strategies that were added will be applied as a disjunction rule. This means that if one of the\r\n     * added exclusion strategies suggests that a field (or class) should be skipped then that field\r\n     * (or object) is skipped during its deserialization.\r\n     *\r\n     * <p>See the documentation of {@link #setExclusionStrategies(ExclusionStrategy...)} for a\r\n     * detailed description of the effect of exclusion strategies.\r\n     *\r\n     * @param strategy an exclusion strategy to apply during deserialization.\r\n     * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n     * @since 1.7\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public GsonBuilder addDeserializationExclusionStrategy(ExclusionStrategy strategy) {\r\n        Objects.requireNonNull(strategy);\r\n        excluder = excluder.withExclusionStrategy(strategy, false, true);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Configures Gson to output JSON that fits in a page for pretty printing. This option only\r\n     * affects JSON serialization.\r\n     *\r\n     * <p>This is a convenience method which simply calls {@link #setFormattingStyle(FormattingStyle)}\r\n     * with {@link FormattingStyle#PRETTY}.\r\n     *\r\n     * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public GsonBuilder setPrettyPrinting() {\r\n        return setFormattingStyle(FormattingStyle.PRETTY);\r\n    }\r\n\r\n    /**\r\n     * Configures Gson to output JSON that uses a certain kind of formatting style (for example\r\n     * newline and indent). This option only affects JSON serialization. By default Gson produces\r\n     * compact JSON output without any formatting.\r\n     *\r\n     * @param formattingStyle the formatting style to use.\r\n     * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n     * @since 2.11.0\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public GsonBuilder setFormattingStyle(FormattingStyle formattingStyle) {\r\n        this.formattingStyle = Objects.requireNonNull(formattingStyle);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the strictness of this builder to {@link Strictness#LENIENT}.\r\n     *\r\n     * @deprecated This method is equivalent to calling {@link #setStrictness(Strictness)} with {@link\r\n     *     Strictness#LENIENT}: {@code setStrictness(Strictness.LENIENT)}\r\n     * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern.\r\n     * @see JsonReader#setStrictness(Strictness)\r\n     * @see JsonWriter#setStrictness(Strictness)\r\n     * @see #setStrictness(Strictness)\r\n     */\r\n    @Deprecated\r\n    @InlineMe(replacement = \"this.setStrictness(Strictness.LENIENT)\", imports = \"com.google.gson.Strictness\")\r\n    @CanIgnoreReturnValue\r\n    public GsonBuilder setLenient() {\r\n        return setStrictness(Strictness.LENIENT);\r\n    }\r\n\r\n    /**\r\n     * Sets the strictness of this builder to the provided parameter.\r\n     *\r\n     * <p>This changes how strict the <a href=\"https://www.ietf.org/rfc/rfc8259.txt\">RFC 8259 JSON\r\n     * specification</a> is enforced when parsing or writing JSON. For details on this, refer to\r\n     * {@link JsonReader#setStrictness(Strictness)} and {@link JsonWriter#setStrictness(Strictness)}.\r\n     *\r\n     * @param strictness the new strictness mode. May not be {@code null}.\r\n     * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern.\r\n     * @see JsonReader#setStrictness(Strictness)\r\n     * @see JsonWriter#setStrictness(Strictness)\r\n     * @since 2.11.0\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public GsonBuilder setStrictness(Strictness strictness) {\r\n        this.strictness = Objects.requireNonNull(strictness);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * By default, Gson escapes HTML characters such as &lt; &gt; etc. Use this option to configure\r\n     * Gson to pass-through HTML characters as is.\r\n     *\r\n     * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n     * @since 1.3\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public GsonBuilder disableHtmlEscaping() {\r\n        this.escapeHtmlChars = false;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Configures Gson to serialize {@code Date} objects according to the pattern provided. You can\r\n     * call this method or {@link #setDateFormat(int, int)} multiple times, but only the last\r\n     * invocation will be used to decide the serialization format.\r\n     *\r\n     * <p>The date format will be used to serialize and deserialize {@link java.util.Date} and in case\r\n     * the {@code java.sql} module is present, also {@link java.sql.Timestamp} and {@link\r\n     * java.sql.Date}.\r\n     *\r\n     * <p>Note that this pattern must abide by the convention provided by {@code SimpleDateFormat}\r\n     * class. See the documentation in {@link SimpleDateFormat} for more information on valid date and\r\n     * time patterns.\r\n     *\r\n     * @param pattern the pattern that dates will be serialized/deserialized to/from; can be {@code\r\n     *     null} to reset the pattern\r\n     * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n     * @throws IllegalArgumentException if the pattern is invalid\r\n     * @since 1.2\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public GsonBuilder setDateFormat(String pattern) {\r\n        if (pattern != null) {\r\n            try {\r\n                new SimpleDateFormat(pattern);\r\n            } catch (IllegalArgumentException e) {\r\n                // Throw exception if it is an invalid date format\r\n                throw new IllegalArgumentException(\"The date pattern '\" + pattern + \"' is not valid\", e);\r\n            }\r\n        }\r\n        this.datePattern = pattern;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Configures Gson to serialize {@code Date} objects according to the date style value provided.\r\n     * You can call this method or {@link #setDateFormat(String)} multiple times, but only the last\r\n     * invocation will be used to decide the serialization format. This methods leaves the current\r\n     * 'time style' unchanged.\r\n     *\r\n     * <p>Note that this style value should be one of the predefined constants in the {@link\r\n     * DateFormat} class, such as {@link DateFormat#MEDIUM}. See the documentation of the {@link\r\n     * DateFormat} class for more information on the valid style constants.\r\n     *\r\n     * @deprecated Counterintuitively, despite this method taking only a 'date style' Gson will use a\r\n     *     format which includes both date and time, with the 'time style' being the last value set by\r\n     *     {@link #setDateFormat(int, int)}. Therefore prefer using {@link #setDateFormat(int, int)}\r\n     *     and explicitly provide the desired 'time style'.\r\n     * @param dateStyle the predefined date style that date objects will be serialized/deserialized\r\n     *     to/from\r\n     * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n     * @throws IllegalArgumentException if the style is invalid\r\n     * @since 1.2\r\n     */\r\n    @Deprecated\r\n    @CanIgnoreReturnValue\r\n    public GsonBuilder setDateFormat(int dateStyle) {\r\n        this.dateStyle = checkDateFormatStyle(dateStyle);\r\n        this.datePattern = null;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Configures Gson to serialize {@code Date} objects according to the style value provided. You\r\n     * can call this method or {@link #setDateFormat(String)} multiple times, but only the last\r\n     * invocation will be used to decide the serialization format.\r\n     *\r\n     * <p>Note that this style value should be one of the predefined constants in the {@link\r\n     * DateFormat} class, such as {@link DateFormat#MEDIUM}. See the documentation of the {@link\r\n     * DateFormat} class for more information on the valid style constants.\r\n     *\r\n     * @param dateStyle the predefined date style that date objects will be serialized/deserialized\r\n     *     to/from\r\n     * @param timeStyle the predefined style for the time portion of the date objects\r\n     * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n     * @throws IllegalArgumentException if the style values are invalid\r\n     * @since 1.2\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public GsonBuilder setDateFormat(int dateStyle, int timeStyle) {\r\n        this.dateStyle = checkDateFormatStyle(dateStyle);\r\n        this.timeStyle = checkDateFormatStyle(timeStyle);\r\n        this.datePattern = null;\r\n        return this;\r\n    }\r\n\r\n    private static int checkDateFormatStyle(int style) {\r\n        // Valid DateFormat styles are: 0, 1, 2, 3 (FULL, LONG, MEDIUM, SHORT)\r\n        if (style < 0 || style > 3) {\r\n            throw new IllegalArgumentException(\"Invalid style: \" + style);\r\n        }\r\n        return style;\r\n    }\r\n\r\n    /**\r\n     * Configures Gson for custom serialization or deserialization. This method combines the\r\n     * registration of an {@link TypeAdapter}, {@link InstanceCreator}, {@link JsonSerializer}, and a\r\n     * {@link JsonDeserializer}. It is best used when a single object {@code typeAdapter} implements\r\n     * all the required interfaces for custom serialization with Gson. If a type adapter was\r\n     * previously registered for the specified {@code type}, it is overwritten.\r\n     *\r\n     * <p>This registers the type specified and no other types: you must manually register related\r\n     * types! For example, applications registering {@code boolean.class} should also register {@code\r\n     * Boolean.class}. And when registering an adapter for a class which has subclasses, you might\r\n     * also want to register the adapter for subclasses, or use {@link\r\n     * #registerTypeHierarchyAdapter(Class, Object)} instead.\r\n     *\r\n     * <p>{@link JsonSerializer} and {@link JsonDeserializer} are made \"{@code null}-safe\". This means\r\n     * when trying to serialize {@code null}, Gson will write a JSON {@code null} and the serializer\r\n     * is not called. Similarly when deserializing a JSON {@code null}, Gson will emit {@code null}\r\n     * without calling the deserializer. If it is desired to handle {@code null} values, a {@link\r\n     * TypeAdapter} should be used instead.\r\n     *\r\n     * @param type the type definition for the type adapter being registered\r\n     * @param typeAdapter This object must implement at least one of the {@link TypeAdapter}, {@link\r\n     *     InstanceCreator}, {@link JsonSerializer}, and a {@link JsonDeserializer} interfaces.\r\n     * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n     * @throws IllegalArgumentException if the type adapter being registered is for {@code Object}\r\n     *     class or {@link JsonElement} or any of its subclasses\r\n     * @see #registerTypeHierarchyAdapter(Class, Object)\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter) {\r\n        Objects.requireNonNull(type);\r\n        Objects.requireNonNull(typeAdapter);\r\n        if (!(typeAdapter instanceof JsonSerializer<?> || typeAdapter instanceof JsonDeserializer<?> || typeAdapter instanceof InstanceCreator<?> || typeAdapter instanceof TypeAdapter<?>)) {\r\n            throw new IllegalArgumentException(\"Class \" + typeAdapter.getClass().getName() + \" does not implement any supported type adapter class or interface\");\r\n        }\r\n        if (hasNonOverridableAdapter(type)) {\r\n            throw new IllegalArgumentException(\"Cannot override built-in adapter for \" + type);\r\n        }\r\n        if (typeAdapter instanceof InstanceCreator<?>) {\r\n            instanceCreators.put(type, (InstanceCreator<?>) typeAdapter);\r\n        }\r\n        if (typeAdapter instanceof JsonSerializer<?> || typeAdapter instanceof JsonDeserializer<?>) {\r\n            TypeToken<?> typeToken = TypeToken.get(type);\r\n            factories.add(TreeTypeAdapter.newFactoryWithMatchRawType(typeToken, typeAdapter));\r\n        }\r\n        if (typeAdapter instanceof TypeAdapter<?>) {\r\n            @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n            TypeAdapterFactory factory = TypeAdapters.newFactory(TypeToken.get(type), (TypeAdapter) typeAdapter);\r\n            factories.add(factory);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Whether the type has a built-in adapter which cannot be overridden.\r\n     */\r\n    private static boolean hasNonOverridableAdapter(Type type) {\r\n        return type == Object.class;\r\n        // This should also cover `JsonElement.class.isAssignableFrom(type)`, however for backward\r\n        // compatibility this is not covered here because really old Gson versions had no built-in\r\n        // adapter for JsonElement so users registered custom adapters. These adapters don't have any\r\n        // effect in recent Gson versions. See\r\n        // https://github.com/google/gson/issues/2787#issuecomment-2581568157\r\n    }\r\n\r\n    /**\r\n     * Registers a factory for type adapters. Registering a factory is useful when the type adapter\r\n     * needs to be configured based on the type of the field being processed. Gson is designed to\r\n     * handle a large number of factories, so you should consider registering them to be at par with\r\n     * registering an individual type adapter.\r\n     *\r\n     * <p>The created Gson instance might only use the factory once to create an adapter for a\r\n     * specific type and cache the result. It is not guaranteed that the factory will be used again\r\n     * every time the type is serialized or deserialized.\r\n     *\r\n     * @since 2.1\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public GsonBuilder registerTypeAdapterFactory(TypeAdapterFactory factory) {\r\n        Objects.requireNonNull(factory);\r\n        factories.add(factory);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Configures Gson for custom serialization or deserialization for an inheritance type hierarchy.\r\n     * This method combines the registration of a {@link TypeAdapter}, {@link JsonSerializer} and a\r\n     * {@link JsonDeserializer}. If a type adapter was previously registered for the specified type\r\n     * hierarchy, it is overridden. If a type adapter is registered for a specific type in the type\r\n     * hierarchy, it will be invoked instead of the one registered for the type hierarchy.\r\n     *\r\n     * @param baseType the class definition for the type adapter being registered for the base class\r\n     *     or interface\r\n     * @param typeAdapter This object must implement at least one of {@link TypeAdapter}, {@link\r\n     *     JsonSerializer} or {@link JsonDeserializer} interfaces.\r\n     * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n     * @throws IllegalArgumentException if the type adapter being registered is for {@link\r\n     *     JsonElement} or any of its subclasses\r\n     * @since 1.7\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter) {\r\n        Objects.requireNonNull(baseType);\r\n        Objects.requireNonNull(typeAdapter);\r\n        if (!(typeAdapter instanceof JsonSerializer<?> || typeAdapter instanceof JsonDeserializer<?> || typeAdapter instanceof TypeAdapter<?>)) {\r\n            throw new IllegalArgumentException(\"Class \" + typeAdapter.getClass().getName() + \" does not implement any supported type adapter class or interface\");\r\n        }\r\n        if (typeAdapter instanceof JsonDeserializer || typeAdapter instanceof JsonSerializer) {\r\n            hierarchyFactories.add(TreeTypeAdapter.newTypeHierarchyFactory(baseType, typeAdapter));\r\n        }\r\n        if (typeAdapter instanceof TypeAdapter<?>) {\r\n            @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n            TypeAdapterFactory factory = TypeAdapters.newTypeHierarchyFactory(baseType, (TypeAdapter) typeAdapter);\r\n            factories.add(factory);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Section 6 of <a href=\"https://www.ietf.org/rfc/rfc8259.txt\">JSON specification</a> disallows\r\n     * special double values (NaN, Infinity, -Infinity). However, <a\r\n     * href=\"http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\">Javascript\r\n     * specification</a> (see section 4.3.20, 4.3.22, 4.3.23) allows these values as valid Javascript\r\n     * values. Moreover, most JavaScript engines will accept these special values in JSON without\r\n     * problem. So, at a practical level, it makes sense to accept these values as valid JSON even\r\n     * though JSON specification disallows them.\r\n     *\r\n     * <p>Gson always accepts these special values during deserialization. However, it outputs\r\n     * strictly compliant JSON. Hence, if it encounters a float value {@link Float#NaN}, {@link\r\n     * Float#POSITIVE_INFINITY}, {@link Float#NEGATIVE_INFINITY}, or a double value {@link\r\n     * Double#NaN}, {@link Double#POSITIVE_INFINITY}, {@link Double#NEGATIVE_INFINITY}, it will throw\r\n     * an {@link IllegalArgumentException}. This method provides a way to override the default\r\n     * behavior when you know that the JSON receiver will be able to handle these special values.\r\n     *\r\n     * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n     * @since 1.3\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public GsonBuilder serializeSpecialFloatingPointValues() {\r\n        this.serializeSpecialFloatingPointValues = true;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disables usage of JDK's {@code sun.misc.Unsafe}.\r\n     *\r\n     * <p>By default Gson uses {@code Unsafe} to create instances of classes which don't have a\r\n     * no-args constructor. However, {@code Unsafe} might not be available for all Java runtimes. For\r\n     * example Android does not provide {@code Unsafe}, or only with limited functionality.\r\n     * Additionally {@code Unsafe} creates instances without executing any constructor or initializer\r\n     * block, or performing initialization of field values. This can lead to surprising and difficult\r\n     * to debug errors. Therefore, to get reliable behavior regardless of which runtime is used, and\r\n     * to detect classes which cannot be deserialized in an early stage of development, this method\r\n     * allows disabling usage of {@code Unsafe}.\r\n     *\r\n     * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n     * @since 2.9.0\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public GsonBuilder disableJdkUnsafe() {\r\n        this.useJdkUnsafe = false;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a reflection access filter. A reflection access filter prevents Gson from using reflection\r\n     * for the serialization and deserialization of certain classes. The logic in the filter specifies\r\n     * which classes those are.\r\n     *\r\n     * <p>Filters will be invoked in reverse registration order, that is, the most recently added\r\n     * filter will be invoked first.\r\n     *\r\n     * <p>By default Gson has no filters configured and will try to use reflection for all classes for\r\n     * which no {@link TypeAdapter} has been registered, and for which no built-in Gson {@code\r\n     * TypeAdapter} exists.\r\n     *\r\n     * <p>The created Gson instance might only use an access filter once for a class or its members\r\n     * and cache the result. It is not guaranteed that the filter will be used again every time a\r\n     * class or its members are accessed during serialization or deserialization.\r\n     *\r\n     * @param filter filter to add\r\n     * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n     * @since 2.9.1\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public GsonBuilder addReflectionAccessFilter(ReflectionAccessFilter filter) {\r\n        Objects.requireNonNull(filter);\r\n        reflectionFilters.addFirst(filter);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates a {@link Gson} instance based on the current configuration. This method is free of\r\n     * side-effects to this {@code GsonBuilder} instance and hence can be called multiple times.\r\n     *\r\n     * @return an instance of Gson configured with the options currently set in this builder\r\n     */\r\n    public Gson create() {\r\n        List<TypeAdapterFactory> factories = new ArrayList<>(this.factories.size() + this.hierarchyFactories.size() + 3);\r\n        factories.addAll(this.factories);\r\n        Collections.reverse(factories);\r\n        List<TypeAdapterFactory> hierarchyFactories = new ArrayList<>(this.hierarchyFactories);\r\n        Collections.reverse(hierarchyFactories);\r\n        factories.addAll(hierarchyFactories);\r\n        addTypeAdaptersForDate(datePattern, dateStyle, timeStyle, factories);\r\n        return new Gson(excluder, fieldNamingPolicy, new HashMap<>(instanceCreators), serializeNulls, complexMapKeySerialization, generateNonExecutableJson, escapeHtmlChars, formattingStyle, strictness, serializeSpecialFloatingPointValues, useJdkUnsafe, longSerializationPolicy, datePattern, dateStyle, timeStyle, new ArrayList<>(this.factories), new ArrayList<>(this.hierarchyFactories), factories, objectToNumberStrategy, numberToNumberStrategy, new ArrayList<>(reflectionFilters));\r\n    }\r\n\r\n    private static void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle, List<TypeAdapterFactory> factories) {\r\n        TypeAdapterFactory dateAdapterFactory;\r\n        boolean sqlTypesSupported = SqlTypesSupport.SUPPORTS_SQL_TYPES;\r\n        TypeAdapterFactory sqlTimestampAdapterFactory = null;\r\n        TypeAdapterFactory sqlDateAdapterFactory = null;\r\n        if (datePattern != null && !datePattern.trim().isEmpty()) {\r\n            dateAdapterFactory = DefaultDateTypeAdapter.DateType.DATE.createAdapterFactory(datePattern);\r\n            if (sqlTypesSupported) {\r\n                sqlTimestampAdapterFactory = SqlTypesSupport.TIMESTAMP_DATE_TYPE.createAdapterFactory(datePattern);\r\n                sqlDateAdapterFactory = SqlTypesSupport.DATE_DATE_TYPE.createAdapterFactory(datePattern);\r\n            }\r\n        } else if (dateStyle != DateFormat.DEFAULT || timeStyle != DateFormat.DEFAULT) {\r\n            dateAdapterFactory = DefaultDateTypeAdapter.DateType.DATE.createAdapterFactory(dateStyle, timeStyle);\r\n            if (sqlTypesSupported) {\r\n                sqlTimestampAdapterFactory = SqlTypesSupport.TIMESTAMP_DATE_TYPE.createAdapterFactory(dateStyle, timeStyle);\r\n                sqlDateAdapterFactory = SqlTypesSupport.DATE_DATE_TYPE.createAdapterFactory(dateStyle, timeStyle);\r\n            }\r\n        } else {\r\n            return;\r\n        }\r\n        factories.add(dateAdapterFactory);\r\n        if (sqlTypesSupported) {\r\n            factories.add(sqlTimestampAdapterFactory);\r\n            factories.add(sqlDateAdapterFactory);\r\n        }\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "field",
    "name": "excluder",
    "start_line": 93,
    "end_line": 93,
    "code": "private Excluder excluder = Excluder.DEFAULT;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "field",
    "name": "longSerializationPolicy",
    "start_line": 94,
    "end_line": 94,
    "code": "private LongSerializationPolicy longSerializationPolicy = LongSerializationPolicy.DEFAULT;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "field",
    "name": "fieldNamingPolicy",
    "start_line": 95,
    "end_line": 95,
    "code": "private FieldNamingStrategy fieldNamingPolicy = FieldNamingPolicy.IDENTITY;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "field",
    "name": "instanceCreators",
    "start_line": 96,
    "end_line": 96,
    "code": "private final Map<Type, InstanceCreator<?>> instanceCreators = new HashMap<>();",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "field",
    "name": "factories",
    "start_line": 97,
    "end_line": 97,
    "code": "private final List<TypeAdapterFactory> factories = new ArrayList<>();",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "field",
    "name": "hierarchyFactories",
    "start_line": 100,
    "end_line": 100,
    "code": "/**\r\n * tree-style hierarchy factories. These come after factories for backwards compatibility.\r\n */\r\nprivate final List<TypeAdapterFactory> hierarchyFactories = new ArrayList<>();",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "field",
    "name": "serializeNulls",
    "start_line": 102,
    "end_line": 102,
    "code": "private boolean serializeNulls = DEFAULT_SERIALIZE_NULLS;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "field",
    "name": "datePattern",
    "start_line": 103,
    "end_line": 103,
    "code": "private String datePattern = DEFAULT_DATE_PATTERN;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "field",
    "name": "dateStyle",
    "start_line": 104,
    "end_line": 104,
    "code": "private int dateStyle = DateFormat.DEFAULT;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "field",
    "name": "timeStyle",
    "start_line": 105,
    "end_line": 105,
    "code": "private int timeStyle = DateFormat.DEFAULT;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "field",
    "name": "complexMapKeySerialization",
    "start_line": 106,
    "end_line": 106,
    "code": "private boolean complexMapKeySerialization = DEFAULT_COMPLEX_MAP_KEYS;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "field",
    "name": "serializeSpecialFloatingPointValues",
    "start_line": 107,
    "end_line": 107,
    "code": "private boolean serializeSpecialFloatingPointValues = DEFAULT_SPECIALIZE_FLOAT_VALUES;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "field",
    "name": "escapeHtmlChars",
    "start_line": 108,
    "end_line": 108,
    "code": "private boolean escapeHtmlChars = DEFAULT_ESCAPE_HTML;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "field",
    "name": "formattingStyle",
    "start_line": 109,
    "end_line": 109,
    "code": "private FormattingStyle formattingStyle = DEFAULT_FORMATTING_STYLE;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "field",
    "name": "generateNonExecutableJson",
    "start_line": 110,
    "end_line": 110,
    "code": "private boolean generateNonExecutableJson = DEFAULT_JSON_NON_EXECUTABLE;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "field",
    "name": "strictness",
    "start_line": 111,
    "end_line": 111,
    "code": "private Strictness strictness = DEFAULT_STRICTNESS;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "field",
    "name": "useJdkUnsafe",
    "start_line": 112,
    "end_line": 112,
    "code": "private boolean useJdkUnsafe = DEFAULT_USE_JDK_UNSAFE;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "field",
    "name": "objectToNumberStrategy",
    "start_line": 113,
    "end_line": 113,
    "code": "private ToNumberStrategy objectToNumberStrategy = DEFAULT_OBJECT_TO_NUMBER_STRATEGY;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "field",
    "name": "numberToNumberStrategy",
    "start_line": 114,
    "end_line": 114,
    "code": "private ToNumberStrategy numberToNumberStrategy = DEFAULT_NUMBER_TO_NUMBER_STRATEGY;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "field",
    "name": "reflectionFilters",
    "start_line": 115,
    "end_line": 115,
    "code": "private final ArrayDeque<ReflectionAccessFilter> reflectionFilters = new ArrayDeque<>();",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "constructor",
    "name": "GsonBuilder",
    "start_line": 122,
    "end_line": 122,
    "code": "/**\r\n * Creates a GsonBuilder instance that can be used to build Gson with various configuration\r\n * settings. GsonBuilder follows the builder pattern, and it is typically used by first invoking\r\n * various configuration methods to set desired options, and finally calling {@link #create()}.\r\n */\r\npublic GsonBuilder() {\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "constructor",
    "name": "GsonBuilder",
    "start_line": 130,
    "end_line": 151,
    "code": "/**\r\n * Constructs a GsonBuilder instance from a Gson instance. The newly constructed GsonBuilder has\r\n * the same configuration as the previously built Gson instance.\r\n *\r\n * @param gson the gson instance whose configuration should be applied to a new GsonBuilder.\r\n */\r\nGsonBuilder(Gson gson) {\r\n    this.excluder = gson.excluder;\r\n    this.fieldNamingPolicy = gson.fieldNamingStrategy;\r\n    this.instanceCreators.putAll(gson.instanceCreators);\r\n    this.serializeNulls = gson.serializeNulls;\r\n    this.complexMapKeySerialization = gson.complexMapKeySerialization;\r\n    this.generateNonExecutableJson = gson.generateNonExecutableJson;\r\n    this.escapeHtmlChars = gson.htmlSafe;\r\n    this.formattingStyle = gson.formattingStyle;\r\n    this.strictness = gson.strictness;\r\n    this.serializeSpecialFloatingPointValues = gson.serializeSpecialFloatingPointValues;\r\n    this.longSerializationPolicy = gson.longSerializationPolicy;\r\n    this.datePattern = gson.datePattern;\r\n    this.dateStyle = gson.dateStyle;\r\n    this.timeStyle = gson.timeStyle;\r\n    this.factories.addAll(gson.builderFactories);\r\n    this.hierarchyFactories.addAll(gson.builderHierarchyFactories);\r\n    this.useJdkUnsafe = gson.useJdkUnsafe;\r\n    this.objectToNumberStrategy = gson.objectToNumberStrategy;\r\n    this.numberToNumberStrategy = gson.numberToNumberStrategy;\r\n    this.reflectionFilters.addAll(gson.reflectionFilters);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "method",
    "name": "setVersion",
    "start_line": 168,
    "end_line": 175,
    "code": "/**\r\n * Configures Gson to enable versioning support. Versioning support works based on the annotation\r\n * types {@link Since} and {@link Until}. It allows including or excluding fields and classes\r\n * based on the specified version. See the documentation of these annotation types for more\r\n * information.\r\n *\r\n * <p>By default versioning support is disabled and usage of {@code @Since} and {@code @Until} has\r\n * no effect.\r\n *\r\n * @param version the version number to use.\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @throws IllegalArgumentException if the version number is NaN or negative\r\n * @see Since\r\n * @see Until\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder setVersion(double version) {\r\n    if (Double.isNaN(version) || version < 0.0) {\r\n        throw new IllegalArgumentException(\"Invalid version: \" + version);\r\n    }\r\n    excluder = excluder.withVersion(version);\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "method",
    "name": "excludeFieldsWithModifiers",
    "start_line": 191,
    "end_line": 196,
    "code": "/**\r\n * Configures Gson to excludes all class fields that have the specified modifiers. By default,\r\n * Gson will exclude all fields marked {@code transient} or {@code static}. This method will\r\n * override that behavior.\r\n *\r\n * <p>This is a convenience method which behaves as if an {@link ExclusionStrategy} which excludes\r\n * these fields was {@linkplain #setExclusionStrategies(ExclusionStrategy...) registered with this\r\n * builder}.\r\n *\r\n * @param modifiers the field modifiers. You must use the modifiers specified in the {@link\r\n *     java.lang.reflect.Modifier} class. For example, {@link\r\n *     java.lang.reflect.Modifier#TRANSIENT}, {@link java.lang.reflect.Modifier#STATIC}.\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder excludeFieldsWithModifiers(int... modifiers) {\r\n    Objects.requireNonNull(modifiers);\r\n    excluder = excluder.withModifiers(modifiers);\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "method",
    "name": "generateNonExecutableJson",
    "start_line": 206,
    "end_line": 210,
    "code": "/**\r\n * Makes the output JSON non-executable in Javascript by prefixing the generated JSON with some\r\n * special text. This prevents attacks from third-party sites through script sourcing. See <a\r\n * href=\"http://code.google.com/p/google-gson/issues/detail?id=42\">Gson Issue 42</a> for details.\r\n *\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @since 1.3\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder generateNonExecutableJson() {\r\n    this.generateNonExecutableJson = true;\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "method",
    "name": "excludeFieldsWithoutExposeAnnotation",
    "start_line": 222,
    "end_line": 226,
    "code": "/**\r\n * Configures Gson to exclude all fields from consideration for serialization and deserialization\r\n * that do not have the {@link com.google.gson.annotations.Expose} annotation.\r\n *\r\n * <p>This is a convenience method which behaves as if an {@link ExclusionStrategy} which excludes\r\n * these fields was {@linkplain #setExclusionStrategies(ExclusionStrategy...) registered with this\r\n * builder}.\r\n *\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder excludeFieldsWithoutExposeAnnotation() {\r\n    excluder = excluder.excludeFieldsWithoutExposeAnnotation();\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "method",
    "name": "serializeNulls",
    "start_line": 235,
    "end_line": 239,
    "code": "/**\r\n * Configures Gson to serialize null fields. By default, Gson omits all fields that are null\r\n * during serialization.\r\n *\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @since 1.2\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder serializeNulls() {\r\n    this.serializeNulls = true;\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "method",
    "name": "enableComplexMapKeySerialization",
    "start_line": 323,
    "end_line": 327,
    "code": "/**\r\n * Configures Gson to serialize {@code Map} objects with complex keys as JSON arrays. Enabling\r\n * this feature will only change the serialized form if the map key is a complex type (i.e.\r\n * non-primitive) in its <strong>serialized</strong> JSON form. The default implementation of map\r\n * serialization uses {@code toString()} on the key; however, when this is called then one of the\r\n * following cases apply:\r\n *\r\n * <p><b>Maps as JSON objects</b>\r\n *\r\n * <p>For this case, assume that a type adapter is registered to serialize and deserialize some\r\n * {@code Point} class, which contains an x and y coordinate, to/from the JSON Primitive string\r\n * value {@code \"(x,y)\"}. The Java map would then be serialized as a {@link JsonObject}.\r\n *\r\n * <p>Below is an example:\r\n *\r\n * <pre>{@code\r\n * Gson gson = new GsonBuilder()\r\n *     .register(Point.class, new MyPointTypeAdapter())\r\n *     .enableComplexMapKeySerialization()\r\n *     .create();\r\n *\r\n * Map<Point, String> original = new LinkedHashMap<>();\r\n * original.put(new Point(5, 6), \"a\");\r\n * original.put(new Point(8, 8), \"b\");\r\n * System.out.println(gson.toJson(original, type));\r\n * }</pre>\r\n *\r\n * The above code prints this JSON object:\r\n *\r\n * <pre>{@code\r\n * {\r\n *   \"(5,6)\": \"a\",\r\n *   \"(8,8)\": \"b\"\r\n * }\r\n * }</pre>\r\n *\r\n * <p><b>Maps as JSON arrays</b>\r\n *\r\n * <p>For this case, assume that a type adapter was NOT registered for some {@code Point} class,\r\n * but rather the default Gson serialization is applied. In this case, some {@code new Point(2,3)}\r\n * would serialize as {@code {\"x\":2,\"y\":3}}.\r\n *\r\n * <p>Given the assumption above, a {@code Map<Point, String>} will be serialized as an array of\r\n * arrays (can be viewed as an entry set of pairs).\r\n *\r\n * <p>Below is an example of serializing complex types as JSON arrays:\r\n *\r\n * <pre>{@code\r\n * Gson gson = new GsonBuilder()\r\n *     .enableComplexMapKeySerialization()\r\n *     .create();\r\n *\r\n * Map<Point, String> original = new LinkedHashMap<>();\r\n * original.put(new Point(5, 6), \"a\");\r\n * original.put(new Point(8, 8), \"b\");\r\n * System.out.println(gson.toJson(original, type));\r\n * }</pre>\r\n *\r\n * The JSON output would look as follows:\r\n *\r\n * <pre>{@code\r\n * [\r\n *   [\r\n *     {\r\n *       \"x\": 5,\r\n *       \"y\": 6\r\n *     },\r\n *     \"a\"\r\n *   ],\r\n *   [\r\n *     {\r\n *       \"x\": 8,\r\n *       \"y\": 8\r\n *     },\r\n *     \"b\"\r\n *   ]\r\n * ]\r\n * }</pre>\r\n *\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @since 1.7\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder enableComplexMapKeySerialization() {\r\n    complexMapKeySerialization = true;\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "method",
    "name": "disableInnerClassSerialization",
    "start_line": 350,
    "end_line": 354,
    "code": "/**\r\n * Configures Gson to exclude inner classes (= non-{@code static} nested classes) during\r\n * serialization and deserialization. This is a convenience method which behaves as if an {@link\r\n * ExclusionStrategy} which excludes inner classes was {@linkplain\r\n * #setExclusionStrategies(ExclusionStrategy...) registered with this builder}. This means inner\r\n * classes will be serialized as JSON {@code null}, and will be deserialized as Java {@code null}\r\n * with their JSON data being ignored. And fields with an inner class as type will be ignored\r\n * during serialization and deserialization.\r\n *\r\n * <p>By default Gson serializes and deserializes inner classes, but ignores references to the\r\n * enclosing instance. Deserialization might not be possible at all when {@link\r\n * #disableJdkUnsafe()} is used (and no custom {@link InstanceCreator} is registered), or it can\r\n * lead to unexpected {@code NullPointerException}s when the deserialized instance is used\r\n * afterwards.\r\n *\r\n * <p>In general using inner classes with Gson should be avoided; they should be converted to\r\n * {@code static} nested classes if possible.\r\n *\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @since 1.3\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder disableInnerClassSerialization() {\r\n    excluder = excluder.disableInnerClassSerialization();\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "method",
    "name": "setLongSerializationPolicy",
    "start_line": 364,
    "end_line": 368,
    "code": "/**\r\n * Configures Gson to apply a specific serialization policy for {@code Long} and {@code long}\r\n * objects.\r\n *\r\n * @param serializationPolicy the particular policy to use for serializing longs.\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @since 1.3\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder setLongSerializationPolicy(LongSerializationPolicy serializationPolicy) {\r\n    this.longSerializationPolicy = Objects.requireNonNull(serializationPolicy);\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "method",
    "name": "setFieldNamingPolicy",
    "start_line": 376,
    "end_line": 379,
    "code": "/**\r\n * Configures Gson to apply a specific naming policy to an object's fields during serialization\r\n * and deserialization.\r\n *\r\n * <p>This method just delegates to {@link #setFieldNamingStrategy(FieldNamingStrategy)}.\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention) {\r\n    return setFieldNamingStrategy(namingConvention);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "method",
    "name": "setFieldNamingStrategy",
    "start_line": 393,
    "end_line": 397,
    "code": "/**\r\n * Configures Gson to apply a specific naming strategy to an object's fields during serialization\r\n * and deserialization.\r\n *\r\n * <p>The created Gson instance might only use the field naming strategy once for a field and\r\n * cache the result. It is not guaranteed that the strategy will be used again every time the\r\n * value of a field is serialized or deserialized.\r\n *\r\n * @param fieldNamingStrategy the naming strategy to apply to the fields\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @since 1.3\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrategy) {\r\n    this.fieldNamingPolicy = Objects.requireNonNull(fieldNamingStrategy);\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "method",
    "name": "setObjectToNumberStrategy",
    "start_line": 407,
    "end_line": 411,
    "code": "/**\r\n * Configures Gson to apply a specific number strategy during deserialization of {@link Object}.\r\n *\r\n * @param objectToNumberStrategy the actual object-to-number strategy\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @see ToNumberPolicy#DOUBLE The default object-to-number strategy\r\n * @since 2.8.9\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder setObjectToNumberStrategy(ToNumberStrategy objectToNumberStrategy) {\r\n    this.objectToNumberStrategy = Objects.requireNonNull(objectToNumberStrategy);\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "method",
    "name": "setNumberToNumberStrategy",
    "start_line": 421,
    "end_line": 425,
    "code": "/**\r\n * Configures Gson to apply a specific number strategy during deserialization of {@link Number}.\r\n *\r\n * @param numberToNumberStrategy the actual number-to-number strategy\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @see ToNumberPolicy#LAZILY_PARSED_NUMBER The default number-to-number strategy\r\n * @since 2.8.9\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder setNumberToNumberStrategy(ToNumberStrategy numberToNumberStrategy) {\r\n    this.numberToNumberStrategy = Objects.requireNonNull(numberToNumberStrategy);\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "method",
    "name": "setExclusionStrategies",
    "start_line": 452,
    "end_line": 459,
    "code": "/**\r\n * Configures Gson to apply a set of exclusion strategies during both serialization and\r\n * deserialization. Each of the {@code strategies} will be applied as a disjunction rule. This\r\n * means that if one of the {@code strategies} suggests that a field (or class) should be skipped\r\n * then that field (or object) is skipped during serialization/deserialization. The strategies are\r\n * added to the existing strategies (if any); the existing strategies are not replaced.\r\n *\r\n * <p>Fields are excluded for serialization and deserialization when {@link\r\n * ExclusionStrategy#shouldSkipField(FieldAttributes) shouldSkipField} returns {@code true}, or\r\n * when {@link ExclusionStrategy#shouldSkipClass(Class) shouldSkipClass} returns {@code true} for\r\n * the field type. Gson behaves as if the field did not exist; its value is not serialized and on\r\n * deserialization if a JSON member with this name exists it is skipped by default.<br>\r\n * When objects of an excluded type (as determined by {@link\r\n * ExclusionStrategy#shouldSkipClass(Class) shouldSkipClass}) are serialized a JSON null is\r\n * written to output, and when deserialized the JSON value is skipped and {@code null} is\r\n * returned.\r\n *\r\n * <p>The created Gson instance might only use an exclusion strategy once for a field or class and\r\n * cache the result. It is not guaranteed that the strategy will be used again every time the\r\n * value of a field or a class is serialized or deserialized.\r\n *\r\n * @param strategies the set of strategy object to apply during object (de)serialization.\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @since 1.4\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder setExclusionStrategies(ExclusionStrategy... strategies) {\r\n    Objects.requireNonNull(strategies);\r\n    for (ExclusionStrategy strategy : strategies) {\r\n        excluder = excluder.withExclusionStrategy(strategy, true, true);\r\n    }\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "method",
    "name": "addSerializationExclusionStrategy",
    "start_line": 475,
    "end_line": 480,
    "code": "/**\r\n * Configures Gson to apply the passed in exclusion strategy during serialization. If this method\r\n * is invoked numerous times with different exclusion strategy objects then the exclusion\r\n * strategies that were added will be applied as a disjunction rule. This means that if one of the\r\n * added exclusion strategies suggests that a field (or class) should be skipped then that field\r\n * (or object) is skipped during its serialization.\r\n *\r\n * <p>See the documentation of {@link #setExclusionStrategies(ExclusionStrategy...)} for a\r\n * detailed description of the effect of exclusion strategies.\r\n *\r\n * @param strategy an exclusion strategy to apply during serialization.\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @since 1.7\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder addSerializationExclusionStrategy(ExclusionStrategy strategy) {\r\n    Objects.requireNonNull(strategy);\r\n    excluder = excluder.withExclusionStrategy(strategy, true, false);\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "method",
    "name": "addDeserializationExclusionStrategy",
    "start_line": 496,
    "end_line": 501,
    "code": "/**\r\n * Configures Gson to apply the passed in exclusion strategy during deserialization. If this\r\n * method is invoked numerous times with different exclusion strategy objects then the exclusion\r\n * strategies that were added will be applied as a disjunction rule. This means that if one of the\r\n * added exclusion strategies suggests that a field (or class) should be skipped then that field\r\n * (or object) is skipped during its deserialization.\r\n *\r\n * <p>See the documentation of {@link #setExclusionStrategies(ExclusionStrategy...)} for a\r\n * detailed description of the effect of exclusion strategies.\r\n *\r\n * @param strategy an exclusion strategy to apply during deserialization.\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @since 1.7\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder addDeserializationExclusionStrategy(ExclusionStrategy strategy) {\r\n    Objects.requireNonNull(strategy);\r\n    excluder = excluder.withExclusionStrategy(strategy, false, true);\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "method",
    "name": "setPrettyPrinting",
    "start_line": 512,
    "end_line": 515,
    "code": "/**\r\n * Configures Gson to output JSON that fits in a page for pretty printing. This option only\r\n * affects JSON serialization.\r\n *\r\n * <p>This is a convenience method which simply calls {@link #setFormattingStyle(FormattingStyle)}\r\n * with {@link FormattingStyle#PRETTY}.\r\n *\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder setPrettyPrinting() {\r\n    return setFormattingStyle(FormattingStyle.PRETTY);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "method",
    "name": "setFormattingStyle",
    "start_line": 526,
    "end_line": 530,
    "code": "/**\r\n * Configures Gson to output JSON that uses a certain kind of formatting style (for example\r\n * newline and indent). This option only affects JSON serialization. By default Gson produces\r\n * compact JSON output without any formatting.\r\n *\r\n * @param formattingStyle the formatting style to use.\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @since 2.11.0\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder setFormattingStyle(FormattingStyle formattingStyle) {\r\n    this.formattingStyle = Objects.requireNonNull(formattingStyle);\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "method",
    "name": "setLenient",
    "start_line": 542,
    "end_line": 549,
    "code": "/**\r\n * Sets the strictness of this builder to {@link Strictness#LENIENT}.\r\n *\r\n * @deprecated This method is equivalent to calling {@link #setStrictness(Strictness)} with {@link\r\n *     Strictness#LENIENT}: {@code setStrictness(Strictness.LENIENT)}\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern.\r\n * @see JsonReader#setStrictness(Strictness)\r\n * @see JsonWriter#setStrictness(Strictness)\r\n * @see #setStrictness(Strictness)\r\n */\r\n@Deprecated\r\n@InlineMe(replacement = \"this.setStrictness(Strictness.LENIENT)\", imports = \"com.google.gson.Strictness\")\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder setLenient() {\r\n    return setStrictness(Strictness.LENIENT);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "method",
    "name": "setStrictness",
    "start_line": 564,
    "end_line": 568,
    "code": "/**\r\n * Sets the strictness of this builder to the provided parameter.\r\n *\r\n * <p>This changes how strict the <a href=\"https://www.ietf.org/rfc/rfc8259.txt\">RFC 8259 JSON\r\n * specification</a> is enforced when parsing or writing JSON. For details on this, refer to\r\n * {@link JsonReader#setStrictness(Strictness)} and {@link JsonWriter#setStrictness(Strictness)}.\r\n *\r\n * @param strictness the new strictness mode. May not be {@code null}.\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern.\r\n * @see JsonReader#setStrictness(Strictness)\r\n * @see JsonWriter#setStrictness(Strictness)\r\n * @since 2.11.0\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder setStrictness(Strictness strictness) {\r\n    this.strictness = Objects.requireNonNull(strictness);\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "method",
    "name": "disableHtmlEscaping",
    "start_line": 577,
    "end_line": 581,
    "code": "/**\r\n * By default, Gson escapes HTML characters such as &lt; &gt; etc. Use this option to configure\r\n * Gson to pass-through HTML characters as is.\r\n *\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @since 1.3\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder disableHtmlEscaping() {\r\n    this.escapeHtmlChars = false;\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "method",
    "name": "setDateFormat",
    "start_line": 602,
    "end_line": 614,
    "code": "/**\r\n * Configures Gson to serialize {@code Date} objects according to the pattern provided. You can\r\n * call this method or {@link #setDateFormat(int, int)} multiple times, but only the last\r\n * invocation will be used to decide the serialization format.\r\n *\r\n * <p>The date format will be used to serialize and deserialize {@link java.util.Date} and in case\r\n * the {@code java.sql} module is present, also {@link java.sql.Timestamp} and {@link\r\n * java.sql.Date}.\r\n *\r\n * <p>Note that this pattern must abide by the convention provided by {@code SimpleDateFormat}\r\n * class. See the documentation in {@link SimpleDateFormat} for more information on valid date and\r\n * time patterns.\r\n *\r\n * @param pattern the pattern that dates will be serialized/deserialized to/from; can be {@code\r\n *     null} to reset the pattern\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @throws IllegalArgumentException if the pattern is invalid\r\n * @since 1.2\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder setDateFormat(String pattern) {\r\n    if (pattern != null) {\r\n        try {\r\n            new SimpleDateFormat(pattern);\r\n        } catch (IllegalArgumentException e) {\r\n            // Throw exception if it is an invalid date format\r\n            throw new IllegalArgumentException(\"The date pattern '\" + pattern + \"' is not valid\", e);\r\n        }\r\n    }\r\n    this.datePattern = pattern;\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "method",
    "name": "setDateFormat",
    "start_line": 636,
    "end_line": 642,
    "code": "/**\r\n * Configures Gson to serialize {@code Date} objects according to the date style value provided.\r\n * You can call this method or {@link #setDateFormat(String)} multiple times, but only the last\r\n * invocation will be used to decide the serialization format. This methods leaves the current\r\n * 'time style' unchanged.\r\n *\r\n * <p>Note that this style value should be one of the predefined constants in the {@link\r\n * DateFormat} class, such as {@link DateFormat#MEDIUM}. See the documentation of the {@link\r\n * DateFormat} class for more information on the valid style constants.\r\n *\r\n * @deprecated Counterintuitively, despite this method taking only a 'date style' Gson will use a\r\n *     format which includes both date and time, with the 'time style' being the last value set by\r\n *     {@link #setDateFormat(int, int)}. Therefore prefer using {@link #setDateFormat(int, int)}\r\n *     and explicitly provide the desired 'time style'.\r\n * @param dateStyle the predefined date style that date objects will be serialized/deserialized\r\n *     to/from\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @throws IllegalArgumentException if the style is invalid\r\n * @since 1.2\r\n */\r\n@Deprecated\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder setDateFormat(int dateStyle) {\r\n    this.dateStyle = checkDateFormatStyle(dateStyle);\r\n    this.datePattern = null;\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "method",
    "name": "setDateFormat",
    "start_line": 660,
    "end_line": 666,
    "code": "/**\r\n * Configures Gson to serialize {@code Date} objects according to the style value provided. You\r\n * can call this method or {@link #setDateFormat(String)} multiple times, but only the last\r\n * invocation will be used to decide the serialization format.\r\n *\r\n * <p>Note that this style value should be one of the predefined constants in the {@link\r\n * DateFormat} class, such as {@link DateFormat#MEDIUM}. See the documentation of the {@link\r\n * DateFormat} class for more information on the valid style constants.\r\n *\r\n * @param dateStyle the predefined date style that date objects will be serialized/deserialized\r\n *     to/from\r\n * @param timeStyle the predefined style for the time portion of the date objects\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @throws IllegalArgumentException if the style values are invalid\r\n * @since 1.2\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder setDateFormat(int dateStyle, int timeStyle) {\r\n    this.dateStyle = checkDateFormatStyle(dateStyle);\r\n    this.timeStyle = checkDateFormatStyle(timeStyle);\r\n    this.datePattern = null;\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "method",
    "name": "checkDateFormatStyle",
    "start_line": 668,
    "end_line": 674,
    "code": "private static int checkDateFormatStyle(int style) {\r\n    // Valid DateFormat styles are: 0, 1, 2, 3 (FULL, LONG, MEDIUM, SHORT)\r\n    if (style < 0 || style > 3) {\r\n        throw new IllegalArgumentException(\"Invalid style: \" + style);\r\n    }\r\n    return style;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "method",
    "name": "registerTypeAdapter",
    "start_line": 703,
    "end_line": 735,
    "code": "/**\r\n * Configures Gson for custom serialization or deserialization. This method combines the\r\n * registration of an {@link TypeAdapter}, {@link InstanceCreator}, {@link JsonSerializer}, and a\r\n * {@link JsonDeserializer}. It is best used when a single object {@code typeAdapter} implements\r\n * all the required interfaces for custom serialization with Gson. If a type adapter was\r\n * previously registered for the specified {@code type}, it is overwritten.\r\n *\r\n * <p>This registers the type specified and no other types: you must manually register related\r\n * types! For example, applications registering {@code boolean.class} should also register {@code\r\n * Boolean.class}. And when registering an adapter for a class which has subclasses, you might\r\n * also want to register the adapter for subclasses, or use {@link\r\n * #registerTypeHierarchyAdapter(Class, Object)} instead.\r\n *\r\n * <p>{@link JsonSerializer} and {@link JsonDeserializer} are made \"{@code null}-safe\". This means\r\n * when trying to serialize {@code null}, Gson will write a JSON {@code null} and the serializer\r\n * is not called. Similarly when deserializing a JSON {@code null}, Gson will emit {@code null}\r\n * without calling the deserializer. If it is desired to handle {@code null} values, a {@link\r\n * TypeAdapter} should be used instead.\r\n *\r\n * @param type the type definition for the type adapter being registered\r\n * @param typeAdapter This object must implement at least one of the {@link TypeAdapter}, {@link\r\n *     InstanceCreator}, {@link JsonSerializer}, and a {@link JsonDeserializer} interfaces.\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @throws IllegalArgumentException if the type adapter being registered is for {@code Object}\r\n *     class or {@link JsonElement} or any of its subclasses\r\n * @see #registerTypeHierarchyAdapter(Class, Object)\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder registerTypeAdapter(Type type, Object typeAdapter) {\r\n    Objects.requireNonNull(type);\r\n    Objects.requireNonNull(typeAdapter);\r\n    if (!(typeAdapter instanceof JsonSerializer<?> || typeAdapter instanceof JsonDeserializer<?> || typeAdapter instanceof InstanceCreator<?> || typeAdapter instanceof TypeAdapter<?>)) {\r\n        throw new IllegalArgumentException(\"Class \" + typeAdapter.getClass().getName() + \" does not implement any supported type adapter class or interface\");\r\n    }\r\n    if (hasNonOverridableAdapter(type)) {\r\n        throw new IllegalArgumentException(\"Cannot override built-in adapter for \" + type);\r\n    }\r\n    if (typeAdapter instanceof InstanceCreator<?>) {\r\n        instanceCreators.put(type, (InstanceCreator<?>) typeAdapter);\r\n    }\r\n    if (typeAdapter instanceof JsonSerializer<?> || typeAdapter instanceof JsonDeserializer<?>) {\r\n        TypeToken<?> typeToken = TypeToken.get(type);\r\n        factories.add(TreeTypeAdapter.newFactoryWithMatchRawType(typeToken, typeAdapter));\r\n    }\r\n    if (typeAdapter instanceof TypeAdapter<?>) {\r\n        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n        TypeAdapterFactory factory = TypeAdapters.newFactory(TypeToken.get(type), (TypeAdapter) typeAdapter);\r\n        factories.add(factory);\r\n    }\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "method",
    "name": "hasNonOverridableAdapter",
    "start_line": 738,
    "end_line": 745,
    "code": "/**\r\n * Whether the type has a built-in adapter which cannot be overridden.\r\n */\r\nprivate static boolean hasNonOverridableAdapter(Type type) {\r\n    return type == Object.class;\r\n    // This should also cover `JsonElement.class.isAssignableFrom(type)`, however for backward\r\n    // compatibility this is not covered here because really old Gson versions had no built-in\r\n    // adapter for JsonElement so users registered custom adapters. These adapters don't have any\r\n    // effect in recent Gson versions. See\r\n    // https://github.com/google/gson/issues/2787#issuecomment-2581568157\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "method",
    "name": "registerTypeAdapterFactory",
    "start_line": 759,
    "end_line": 764,
    "code": "/**\r\n * Registers a factory for type adapters. Registering a factory is useful when the type adapter\r\n * needs to be configured based on the type of the field being processed. Gson is designed to\r\n * handle a large number of factories, so you should consider registering them to be at par with\r\n * registering an individual type adapter.\r\n *\r\n * <p>The created Gson instance might only use the factory once to create an adapter for a\r\n * specific type and cache the result. It is not guaranteed that the factory will be used again\r\n * every time the type is serialized or deserialized.\r\n *\r\n * @since 2.1\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder registerTypeAdapterFactory(TypeAdapterFactory factory) {\r\n    Objects.requireNonNull(factory);\r\n    factories.add(factory);\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "method",
    "name": "registerTypeHierarchyAdapter",
    "start_line": 782,
    "end_line": 805,
    "code": "/**\r\n * Configures Gson for custom serialization or deserialization for an inheritance type hierarchy.\r\n * This method combines the registration of a {@link TypeAdapter}, {@link JsonSerializer} and a\r\n * {@link JsonDeserializer}. If a type adapter was previously registered for the specified type\r\n * hierarchy, it is overridden. If a type adapter is registered for a specific type in the type\r\n * hierarchy, it will be invoked instead of the one registered for the type hierarchy.\r\n *\r\n * @param baseType the class definition for the type adapter being registered for the base class\r\n *     or interface\r\n * @param typeAdapter This object must implement at least one of {@link TypeAdapter}, {@link\r\n *     JsonSerializer} or {@link JsonDeserializer} interfaces.\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @throws IllegalArgumentException if the type adapter being registered is for {@link\r\n *     JsonElement} or any of its subclasses\r\n * @since 1.7\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter) {\r\n    Objects.requireNonNull(baseType);\r\n    Objects.requireNonNull(typeAdapter);\r\n    if (!(typeAdapter instanceof JsonSerializer<?> || typeAdapter instanceof JsonDeserializer<?> || typeAdapter instanceof TypeAdapter<?>)) {\r\n        throw new IllegalArgumentException(\"Class \" + typeAdapter.getClass().getName() + \" does not implement any supported type adapter class or interface\");\r\n    }\r\n    if (typeAdapter instanceof JsonDeserializer || typeAdapter instanceof JsonSerializer) {\r\n        hierarchyFactories.add(TreeTypeAdapter.newTypeHierarchyFactory(baseType, typeAdapter));\r\n    }\r\n    if (typeAdapter instanceof TypeAdapter<?>) {\r\n        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n        TypeAdapterFactory factory = TypeAdapters.newTypeHierarchyFactory(baseType, (TypeAdapter) typeAdapter);\r\n        factories.add(factory);\r\n    }\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "method",
    "name": "serializeSpecialFloatingPointValues",
    "start_line": 826,
    "end_line": 830,
    "code": "/**\r\n * Section 6 of <a href=\"https://www.ietf.org/rfc/rfc8259.txt\">JSON specification</a> disallows\r\n * special double values (NaN, Infinity, -Infinity). However, <a\r\n * href=\"http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\">Javascript\r\n * specification</a> (see section 4.3.20, 4.3.22, 4.3.23) allows these values as valid Javascript\r\n * values. Moreover, most JavaScript engines will accept these special values in JSON without\r\n * problem. So, at a practical level, it makes sense to accept these values as valid JSON even\r\n * though JSON specification disallows them.\r\n *\r\n * <p>Gson always accepts these special values during deserialization. However, it outputs\r\n * strictly compliant JSON. Hence, if it encounters a float value {@link Float#NaN}, {@link\r\n * Float#POSITIVE_INFINITY}, {@link Float#NEGATIVE_INFINITY}, or a double value {@link\r\n * Double#NaN}, {@link Double#POSITIVE_INFINITY}, {@link Double#NEGATIVE_INFINITY}, it will throw\r\n * an {@link IllegalArgumentException}. This method provides a way to override the default\r\n * behavior when you know that the JSON receiver will be able to handle these special values.\r\n *\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @since 1.3\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder serializeSpecialFloatingPointValues() {\r\n    this.serializeSpecialFloatingPointValues = true;\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "method",
    "name": "disableJdkUnsafe",
    "start_line": 847,
    "end_line": 851,
    "code": "/**\r\n * Disables usage of JDK's {@code sun.misc.Unsafe}.\r\n *\r\n * <p>By default Gson uses {@code Unsafe} to create instances of classes which don't have a\r\n * no-args constructor. However, {@code Unsafe} might not be available for all Java runtimes. For\r\n * example Android does not provide {@code Unsafe}, or only with limited functionality.\r\n * Additionally {@code Unsafe} creates instances without executing any constructor or initializer\r\n * block, or performing initialization of field values. This can lead to surprising and difficult\r\n * to debug errors. Therefore, to get reliable behavior regardless of which runtime is used, and\r\n * to detect classes which cannot be deserialized in an early stage of development, this method\r\n * allows disabling usage of {@code Unsafe}.\r\n *\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @since 2.9.0\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder disableJdkUnsafe() {\r\n    this.useJdkUnsafe = false;\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "method",
    "name": "addReflectionAccessFilter",
    "start_line": 873,
    "end_line": 878,
    "code": "/**\r\n * Adds a reflection access filter. A reflection access filter prevents Gson from using reflection\r\n * for the serialization and deserialization of certain classes. The logic in the filter specifies\r\n * which classes those are.\r\n *\r\n * <p>Filters will be invoked in reverse registration order, that is, the most recently added\r\n * filter will be invoked first.\r\n *\r\n * <p>By default Gson has no filters configured and will try to use reflection for all classes for\r\n * which no {@link TypeAdapter} has been registered, and for which no built-in Gson {@code\r\n * TypeAdapter} exists.\r\n *\r\n * <p>The created Gson instance might only use an access filter once for a class or its members\r\n * and cache the result. It is not guaranteed that the filter will be used again every time a\r\n * class or its members are accessed during serialization or deserialization.\r\n *\r\n * @param filter filter to add\r\n * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\r\n * @since 2.9.1\r\n */\r\n@CanIgnoreReturnValue\r\npublic GsonBuilder addReflectionAccessFilter(ReflectionAccessFilter filter) {\r\n    Objects.requireNonNull(filter);\r\n    reflectionFilters.addFirst(filter);\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "method",
    "name": "create",
    "start_line": 886,
    "end_line": 920,
    "code": "/**\r\n * Creates a {@link Gson} instance based on the current configuration. This method is free of\r\n * side-effects to this {@code GsonBuilder} instance and hence can be called multiple times.\r\n *\r\n * @return an instance of Gson configured with the options currently set in this builder\r\n */\r\npublic Gson create() {\r\n    List<TypeAdapterFactory> factories = new ArrayList<>(this.factories.size() + this.hierarchyFactories.size() + 3);\r\n    factories.addAll(this.factories);\r\n    Collections.reverse(factories);\r\n    List<TypeAdapterFactory> hierarchyFactories = new ArrayList<>(this.hierarchyFactories);\r\n    Collections.reverse(hierarchyFactories);\r\n    factories.addAll(hierarchyFactories);\r\n    addTypeAdaptersForDate(datePattern, dateStyle, timeStyle, factories);\r\n    return new Gson(excluder, fieldNamingPolicy, new HashMap<>(instanceCreators), serializeNulls, complexMapKeySerialization, generateNonExecutableJson, escapeHtmlChars, formattingStyle, strictness, serializeSpecialFloatingPointValues, useJdkUnsafe, longSerializationPolicy, datePattern, dateStyle, timeStyle, new ArrayList<>(this.factories), new ArrayList<>(this.hierarchyFactories), factories, objectToNumberStrategy, numberToNumberStrategy, new ArrayList<>(reflectionFilters));\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  },
  {
    "type": "method",
    "name": "addTypeAdaptersForDate",
    "start_line": 922,
    "end_line": 956,
    "code": "private static void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle, List<TypeAdapterFactory> factories) {\r\n    TypeAdapterFactory dateAdapterFactory;\r\n    boolean sqlTypesSupported = SqlTypesSupport.SUPPORTS_SQL_TYPES;\r\n    TypeAdapterFactory sqlTimestampAdapterFactory = null;\r\n    TypeAdapterFactory sqlDateAdapterFactory = null;\r\n    if (datePattern != null && !datePattern.trim().isEmpty()) {\r\n        dateAdapterFactory = DefaultDateTypeAdapter.DateType.DATE.createAdapterFactory(datePattern);\r\n        if (sqlTypesSupported) {\r\n            sqlTimestampAdapterFactory = SqlTypesSupport.TIMESTAMP_DATE_TYPE.createAdapterFactory(datePattern);\r\n            sqlDateAdapterFactory = SqlTypesSupport.DATE_DATE_TYPE.createAdapterFactory(datePattern);\r\n        }\r\n    } else if (dateStyle != DateFormat.DEFAULT || timeStyle != DateFormat.DEFAULT) {\r\n        dateAdapterFactory = DefaultDateTypeAdapter.DateType.DATE.createAdapterFactory(dateStyle, timeStyle);\r\n        if (sqlTypesSupported) {\r\n            sqlTimestampAdapterFactory = SqlTypesSupport.TIMESTAMP_DATE_TYPE.createAdapterFactory(dateStyle, timeStyle);\r\n            sqlDateAdapterFactory = SqlTypesSupport.DATE_DATE_TYPE.createAdapterFactory(dateStyle, timeStyle);\r\n        }\r\n    } else {\r\n        return;\r\n    }\r\n    factories.add(dateAdapterFactory);\r\n    if (sqlTypesSupported) {\r\n        factories.add(sqlTimestampAdapterFactory);\r\n        factories.add(sqlDateAdapterFactory);\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\GsonBuilder.java"
  }
]