[
  {
    "type": "package",
    "name": "com.google.gson.internal",
    "start_line": 17,
    "end_line": 17,
    "code": "package com.google.gson.internal;\r\n\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "import",
    "name": "java.util.Objects.requireNonNull",
    "start_line": 19,
    "end_line": 19,
    "code": "import static java.util.Objects.requireNonNull;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "import",
    "name": "java.io.Serializable",
    "start_line": 21,
    "end_line": 21,
    "code": "import java.io.Serializable;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "import",
    "name": "java.lang.reflect.Array",
    "start_line": 22,
    "end_line": 22,
    "code": "import java.lang.reflect.Array;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "import",
    "name": "java.lang.reflect.GenericArrayType",
    "start_line": 23,
    "end_line": 23,
    "code": "import java.lang.reflect.GenericArrayType;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "import",
    "name": "java.lang.reflect.GenericDeclaration",
    "start_line": 24,
    "end_line": 24,
    "code": "import java.lang.reflect.GenericDeclaration;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "import",
    "name": "java.lang.reflect.Modifier",
    "start_line": 25,
    "end_line": 25,
    "code": "import java.lang.reflect.Modifier;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "import",
    "name": "java.lang.reflect.ParameterizedType",
    "start_line": 26,
    "end_line": 26,
    "code": "import java.lang.reflect.ParameterizedType;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "import",
    "name": "java.lang.reflect.Type",
    "start_line": 27,
    "end_line": 27,
    "code": "import java.lang.reflect.Type;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "import",
    "name": "java.lang.reflect.TypeVariable",
    "start_line": 28,
    "end_line": 28,
    "code": "import java.lang.reflect.TypeVariable;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "import",
    "name": "java.lang.reflect.WildcardType",
    "start_line": 29,
    "end_line": 29,
    "code": "import java.lang.reflect.WildcardType;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "import",
    "name": "java.util.Arrays",
    "start_line": 30,
    "end_line": 30,
    "code": "import java.util.Arrays;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "import",
    "name": "java.util.Collection",
    "start_line": 31,
    "end_line": 31,
    "code": "import java.util.Collection;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "import",
    "name": "java.util.HashMap",
    "start_line": 32,
    "end_line": 32,
    "code": "import java.util.HashMap;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "import",
    "name": "java.util.Map",
    "start_line": 33,
    "end_line": 33,
    "code": "import java.util.Map;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "import",
    "name": "java.util.NoSuchElementException",
    "start_line": 34,
    "end_line": 34,
    "code": "import java.util.NoSuchElementException;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "import",
    "name": "java.util.Objects",
    "start_line": 35,
    "end_line": 35,
    "code": "import java.util.Objects;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "import",
    "name": "java.util.Properties",
    "start_line": 36,
    "end_line": 36,
    "code": "import java.util.Properties;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "class",
    "name": "GsonTypes",
    "start_line": 44,
    "end_line": 696,
    "code": "/**\r\n * Static methods for working with types.\r\n *\r\n * @author Bob Lee\r\n * @author Jesse Wilson\r\n */\r\npublic final class GsonTypes {\r\n\r\n    static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\r\n\r\n    private GsonTypes() {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n    /**\r\n     * Returns a new parameterized type, applying {@code typeArguments} to {@code rawType} and\r\n     * enclosed by {@code ownerType}.\r\n     *\r\n     * @return a {@link java.io.Serializable serializable} parameterized type.\r\n     */\r\n    public static ParameterizedType newParameterizedTypeWithOwner(Type ownerType, Class<?> rawType, Type... typeArguments) {\r\n        return new ParameterizedTypeImpl(ownerType, rawType, typeArguments);\r\n    }\r\n\r\n    /**\r\n     * Returns an array type whose elements are all instances of {@code componentType}.\r\n     *\r\n     * @return a {@link java.io.Serializable serializable} generic array type.\r\n     */\r\n    public static GenericArrayType arrayOf(Type componentType) {\r\n        return new GenericArrayTypeImpl(componentType);\r\n    }\r\n\r\n    /**\r\n     * Returns a type that represents an unknown type that extends {@code bound}. For example, if\r\n     * {@code bound} is {@code CharSequence.class}, this returns {@code ? extends CharSequence}. If\r\n     * {@code bound} is {@code Object.class}, this returns {@code ?}, which is shorthand for {@code ?\r\n     * extends Object}.\r\n     */\r\n    public static WildcardType subtypeOf(Type bound) {\r\n        Type[] upperBounds;\r\n        if (bound instanceof WildcardType) {\r\n            upperBounds = ((WildcardType) bound).getUpperBounds();\r\n        } else {\r\n            upperBounds = new Type[] { bound };\r\n        }\r\n        return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY);\r\n    }\r\n\r\n    /**\r\n     * Returns a type that represents an unknown supertype of {@code bound}. For example, if {@code\r\n     * bound} is {@code String.class}, this returns {@code ? super String}.\r\n     */\r\n    public static WildcardType supertypeOf(Type bound) {\r\n        Type[] lowerBounds;\r\n        if (bound instanceof WildcardType) {\r\n            lowerBounds = ((WildcardType) bound).getLowerBounds();\r\n        } else {\r\n            lowerBounds = new Type[] { bound };\r\n        }\r\n        return new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds);\r\n    }\r\n\r\n    /**\r\n     * Returns a type that is functionally equal but not necessarily equal according to {@link\r\n     * Object#equals(Object) Object.equals()}. The returned type is {@link java.io.Serializable}.\r\n     */\r\n    public static Type canonicalize(Type type) {\r\n        if (type instanceof Class) {\r\n            Class<?> c = (Class<?>) type;\r\n            return c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\r\n        } else if (type instanceof ParameterizedType) {\r\n            ParameterizedType p = (ParameterizedType) type;\r\n            return new ParameterizedTypeImpl(p.getOwnerType(), (Class<?>) p.getRawType(), p.getActualTypeArguments());\r\n        } else if (type instanceof GenericArrayType) {\r\n            GenericArrayType g = (GenericArrayType) type;\r\n            return new GenericArrayTypeImpl(g.getGenericComponentType());\r\n        } else if (type instanceof WildcardType) {\r\n            WildcardType w = (WildcardType) type;\r\n            return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\r\n        } else {\r\n            // type is either serializable as-is or unsupported\r\n            return type;\r\n        }\r\n    }\r\n\r\n    public static Class<?> getRawType(Type type) {\r\n        if (type instanceof Class<?>) {\r\n            // type is a normal class.\r\n            return (Class<?>) type;\r\n        } else if (type instanceof ParameterizedType) {\r\n            ParameterizedType parameterizedType = (ParameterizedType) type;\r\n            // getRawType() returns Type instead of Class; that seems to be an API mistake,\r\n            // see https://bugs.openjdk.org/browse/JDK-8250659\r\n            Type rawType = parameterizedType.getRawType();\r\n            return (Class<?>) rawType;\r\n        } else if (type instanceof GenericArrayType) {\r\n            Type componentType = ((GenericArrayType) type).getGenericComponentType();\r\n            return Array.newInstance(getRawType(componentType), 0).getClass();\r\n        } else if (type instanceof TypeVariable) {\r\n            // we could use the variable's bounds, but that won't work if there are multiple.\r\n            // having a raw type that's more general than necessary is okay\r\n            return Object.class;\r\n        } else if (type instanceof WildcardType) {\r\n            Type[] bounds = ((WildcardType) type).getUpperBounds();\r\n            // Currently the JLS only permits one bound for wildcards so using first bound is safe\r\n            assert bounds.length == 1;\r\n            return getRawType(bounds[0]);\r\n        } else {\r\n            String className = type == null ? \"null\" : type.getClass().getName();\r\n            throw new IllegalArgumentException(\"Expected a Class, ParameterizedType, or GenericArrayType, but <\" + type + \"> is of type \" + className);\r\n        }\r\n    }\r\n\r\n    private static boolean equal(Object a, Object b) {\r\n        return Objects.equals(a, b);\r\n    }\r\n\r\n    /**\r\n     * Returns true if {@code a} and {@code b} are equal.\r\n     */\r\n    public static boolean equals(Type a, Type b) {\r\n        if (a == b) {\r\n            // also handles (a == null && b == null)\r\n            return true;\r\n        } else if (a instanceof Class) {\r\n            // Class already specifies equals().\r\n            return a.equals(b);\r\n        } else if (a instanceof ParameterizedType) {\r\n            if (!(b instanceof ParameterizedType)) {\r\n                return false;\r\n            }\r\n            // TODO: save a .clone() call\r\n            ParameterizedType pa = (ParameterizedType) a;\r\n            ParameterizedType pb = (ParameterizedType) b;\r\n            return equal(pa.getOwnerType(), pb.getOwnerType()) && pa.getRawType().equals(pb.getRawType()) && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());\r\n        } else if (a instanceof GenericArrayType) {\r\n            if (!(b instanceof GenericArrayType)) {\r\n                return false;\r\n            }\r\n            GenericArrayType ga = (GenericArrayType) a;\r\n            GenericArrayType gb = (GenericArrayType) b;\r\n            return equals(ga.getGenericComponentType(), gb.getGenericComponentType());\r\n        } else if (a instanceof WildcardType) {\r\n            if (!(b instanceof WildcardType)) {\r\n                return false;\r\n            }\r\n            WildcardType wa = (WildcardType) a;\r\n            WildcardType wb = (WildcardType) b;\r\n            return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds()) && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());\r\n        } else if (a instanceof TypeVariable) {\r\n            if (!(b instanceof TypeVariable)) {\r\n                return false;\r\n            }\r\n            TypeVariable<?> va = (TypeVariable<?>) a;\r\n            TypeVariable<?> vb = (TypeVariable<?>) b;\r\n            return Objects.equals(va.getGenericDeclaration(), vb.getGenericDeclaration()) && va.getName().equals(vb.getName());\r\n        } else {\r\n            // This isn't a type we support. Could be a generic array type, wildcard type, etc.\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public static String typeToString(Type type) {\r\n        return type instanceof Class ? ((Class<?>) type).getName() : type.toString();\r\n    }\r\n\r\n    /**\r\n     * Returns the generic supertype for {@code supertype}. For example, given a class {@code\r\n     * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the\r\n     * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.\r\n     */\r\n    private static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> supertype) {\r\n        if (supertype == rawType) {\r\n            return context;\r\n        }\r\n        // we skip searching through interfaces if unknown is an interface\r\n        if (supertype.isInterface()) {\r\n            Class<?>[] interfaces = rawType.getInterfaces();\r\n            for (int i = 0, length = interfaces.length; i < length; i++) {\r\n                if (interfaces[i] == supertype) {\r\n                    return rawType.getGenericInterfaces()[i];\r\n                } else if (supertype.isAssignableFrom(interfaces[i])) {\r\n                    return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], supertype);\r\n                }\r\n            }\r\n        }\r\n        // check our supertypes\r\n        if (!rawType.isInterface()) {\r\n            while (rawType != Object.class) {\r\n                Class<?> rawSupertype = rawType.getSuperclass();\r\n                if (rawSupertype == supertype) {\r\n                    return rawType.getGenericSuperclass();\r\n                } else if (supertype.isAssignableFrom(rawSupertype)) {\r\n                    return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, supertype);\r\n                }\r\n                rawType = rawSupertype;\r\n            }\r\n        }\r\n        // we can't resolve this further\r\n        return supertype;\r\n    }\r\n\r\n    /**\r\n     * Returns the generic form of {@code supertype}. For example, if this is {@code\r\n     * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code\r\n     * Iterable.class}.\r\n     *\r\n     * @param supertype a superclass of, or interface implemented by, this.\r\n     */\r\n    private static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {\r\n        if (context instanceof WildcardType) {\r\n            // Wildcards are useless for resolving supertypes. As the upper bound has the same raw type,\r\n            // use it instead\r\n            Type[] bounds = ((WildcardType) context).getUpperBounds();\r\n            // Currently the JLS only permits one bound for wildcards so using first bound is safe\r\n            assert bounds.length == 1;\r\n            context = bounds[0];\r\n        }\r\n        if (!supertype.isAssignableFrom(contextRawType)) {\r\n            throw new IllegalArgumentException(contextRawType + \" is not the same as or a subtype of \" + supertype);\r\n        }\r\n        return resolve(context, contextRawType, GsonTypes.getGenericSupertype(context, contextRawType, supertype));\r\n    }\r\n\r\n    /**\r\n     * Returns the component type of this array type.\r\n     *\r\n     * @throws ClassCastException if this type is not an array.\r\n     */\r\n    public static Type getArrayComponentType(Type array) {\r\n        return array instanceof GenericArrayType ? ((GenericArrayType) array).getGenericComponentType() : ((Class<?>) array).getComponentType();\r\n    }\r\n\r\n    /**\r\n     * Returns the element type of this collection type.\r\n     *\r\n     * @throws IllegalArgumentException if this type is not a collection.\r\n     */\r\n    public static Type getCollectionElementType(Type context, Class<?> contextRawType) {\r\n        Type collectionType = getSupertype(context, contextRawType, Collection.class);\r\n        if (collectionType instanceof ParameterizedType) {\r\n            return ((ParameterizedType) collectionType).getActualTypeArguments()[0];\r\n        }\r\n        return Object.class;\r\n    }\r\n\r\n    /**\r\n     * Returns a two element array containing this map's key and value types in positions 0 and 1\r\n     * respectively.\r\n     */\r\n    public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) {\r\n        /*\r\n     * Work around a problem with the declaration of java.util.Properties. That\r\n     * class should extend Hashtable<String, String>, but it's declared to\r\n     * extend Hashtable<Object, Object>.\r\n     */\r\n        if (Properties.class.isAssignableFrom(contextRawType)) {\r\n            return new Type[] { String.class, String.class };\r\n        }\r\n        Type mapType = getSupertype(context, contextRawType, Map.class);\r\n        // TODO: strip wildcards?\r\n        if (mapType instanceof ParameterizedType) {\r\n            ParameterizedType mapParameterizedType = (ParameterizedType) mapType;\r\n            return mapParameterizedType.getActualTypeArguments();\r\n        }\r\n        return new Type[] { Object.class, Object.class };\r\n    }\r\n\r\n    public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\r\n        return resolve(context, contextRawType, toResolve, new HashMap<TypeVariable<?>, Type>());\r\n    }\r\n\r\n    private static Type resolve(Type context, Class<?> contextRawType, Type toResolve, Map<TypeVariable<?>, Type> visitedTypeVariables) {\r\n        // this implementation is made a little more complicated in an attempt to avoid object-creation\r\n        TypeVariable<?> resolving = null;\r\n        while (true) {\r\n            if (toResolve instanceof TypeVariable) {\r\n                TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\r\n                Type previouslyResolved = visitedTypeVariables.get(typeVariable);\r\n                if (previouslyResolved != null) {\r\n                    // cannot reduce due to infinite recursion\r\n                    return (previouslyResolved == Void.TYPE) ? toResolve : previouslyResolved;\r\n                }\r\n                // Insert a placeholder to mark the fact that we are in the process of resolving this type\r\n                visitedTypeVariables.put(typeVariable, Void.TYPE);\r\n                if (resolving == null) {\r\n                    resolving = typeVariable;\r\n                }\r\n                toResolve = resolveTypeVariable(context, contextRawType, typeVariable);\r\n                if (toResolve == typeVariable) {\r\n                    break;\r\n                }\r\n            } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\r\n                Class<?> original = (Class<?>) toResolve;\r\n                Type componentType = original.getComponentType();\r\n                Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\r\n                toResolve = equal(componentType, newComponentType) ? original : arrayOf(newComponentType);\r\n                break;\r\n            } else if (toResolve instanceof GenericArrayType) {\r\n                GenericArrayType original = (GenericArrayType) toResolve;\r\n                Type componentType = original.getGenericComponentType();\r\n                Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\r\n                toResolve = equal(componentType, newComponentType) ? original : arrayOf(newComponentType);\r\n                break;\r\n            } else if (toResolve instanceof ParameterizedType) {\r\n                ParameterizedType original = (ParameterizedType) toResolve;\r\n                Type ownerType = original.getOwnerType();\r\n                Type newOwnerType = resolve(context, contextRawType, ownerType, visitedTypeVariables);\r\n                boolean ownerChanged = !equal(newOwnerType, ownerType);\r\n                Type[] args = original.getActualTypeArguments();\r\n                boolean argsChanged = false;\r\n                for (int t = 0, length = args.length; t < length; t++) {\r\n                    Type resolvedTypeArgument = resolve(context, contextRawType, args[t], visitedTypeVariables);\r\n                    if (!equal(resolvedTypeArgument, args[t])) {\r\n                        if (!argsChanged) {\r\n                            args = args.clone();\r\n                            argsChanged = true;\r\n                        }\r\n                        args[t] = resolvedTypeArgument;\r\n                    }\r\n                }\r\n                toResolve = ownerChanged || argsChanged ? newParameterizedTypeWithOwner(newOwnerType, (Class<?>) original.getRawType(), args) : original;\r\n                break;\r\n            } else if (toResolve instanceof WildcardType) {\r\n                WildcardType original = (WildcardType) toResolve;\r\n                Type[] originalLowerBound = original.getLowerBounds();\r\n                Type[] originalUpperBound = original.getUpperBounds();\r\n                if (originalLowerBound.length == 1) {\r\n                    Type lowerBound = resolve(context, contextRawType, originalLowerBound[0], visitedTypeVariables);\r\n                    if (lowerBound != originalLowerBound[0]) {\r\n                        toResolve = supertypeOf(lowerBound);\r\n                        break;\r\n                    }\r\n                } else if (originalUpperBound.length == 1) {\r\n                    Type upperBound = resolve(context, contextRawType, originalUpperBound[0], visitedTypeVariables);\r\n                    if (upperBound != originalUpperBound[0]) {\r\n                        toResolve = subtypeOf(upperBound);\r\n                        break;\r\n                    }\r\n                }\r\n                toResolve = original;\r\n                break;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        // ensure that any in-process resolution gets updated with the final result\r\n        if (resolving != null) {\r\n            visitedTypeVariables.put(resolving, toResolve);\r\n        }\r\n        return toResolve;\r\n    }\r\n\r\n    private static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable<?> unknown) {\r\n        Class<?> declaredByRaw = declaringClassOf(unknown);\r\n        // we can't reduce this further\r\n        if (declaredByRaw == null) {\r\n            return unknown;\r\n        }\r\n        Type declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);\r\n        if (declaredBy instanceof ParameterizedType) {\r\n            int index = indexOf(declaredByRaw.getTypeParameters(), unknown);\r\n            return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];\r\n        }\r\n        return unknown;\r\n    }\r\n\r\n    private static int indexOf(Object[] array, Object toFind) {\r\n        for (int i = 0, length = array.length; i < length; i++) {\r\n            if (toFind.equals(array[i])) {\r\n                return i;\r\n            }\r\n        }\r\n        throw new NoSuchElementException();\r\n    }\r\n\r\n    /**\r\n     * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by\r\n     * a class.\r\n     */\r\n    private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {\r\n        GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();\r\n        return genericDeclaration instanceof Class ? (Class<?>) genericDeclaration : null;\r\n    }\r\n\r\n    static void checkNotPrimitive(Type type) {\r\n        if (type instanceof Class<?> && ((Class<?>) type).isPrimitive()) {\r\n            throw new IllegalArgumentException(\"Primitive type is not allowed\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Whether an {@linkplain ParameterizedType#getOwnerType() owner type} must be specified when\r\n     * constructing a {@link ParameterizedType} for {@code rawType}.\r\n     *\r\n     * <p>Note that this method might not require an owner type for all cases where Java reflection\r\n     * would create parameterized types with owner type.\r\n     */\r\n    public static boolean requiresOwnerType(Type rawType) {\r\n        if (rawType instanceof Class<?>) {\r\n            Class<?> rawTypeAsClass = (Class<?>) rawType;\r\n            return !Modifier.isStatic(rawTypeAsClass.getModifiers()) && rawTypeAsClass.getDeclaringClass() != null;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // Here and below we put @SuppressWarnings(\"serial\") on fields of type `Type`. Recent Java\r\n    // compilers complain that the declared type is not Serializable. But in this context we go out of\r\n    // our way to ensure that the Type in question is either Class (which is serializable) or one of\r\n    // the nested Type implementations here (which are also serializable).\r\n    private static final class ParameterizedTypeImpl implements ParameterizedType, Serializable {\r\n\r\n        @SuppressWarnings(\"serial\")\r\n        private final Type ownerType;\r\n\r\n        @SuppressWarnings(\"serial\")\r\n        private final Type rawType;\r\n\r\n        @SuppressWarnings(\"serial\")\r\n        private final Type[] typeArguments;\r\n\r\n        public ParameterizedTypeImpl(Type ownerType, Class<?> rawType, Type... typeArguments) {\r\n            requireNonNull(rawType);\r\n            if (ownerType == null && requiresOwnerType(rawType)) {\r\n                throw new IllegalArgumentException(\"Must specify owner type for \" + rawType);\r\n            }\r\n            this.ownerType = ownerType == null ? null : canonicalize(ownerType);\r\n            this.rawType = canonicalize(rawType);\r\n            this.typeArguments = typeArguments.clone();\r\n            for (int t = 0, length = this.typeArguments.length; t < length; t++) {\r\n                requireNonNull(this.typeArguments[t]);\r\n                checkNotPrimitive(this.typeArguments[t]);\r\n                this.typeArguments[t] = canonicalize(this.typeArguments[t]);\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public Type[] getActualTypeArguments() {\r\n            return typeArguments.clone();\r\n        }\r\n\r\n        @Override\r\n        public Type getRawType() {\r\n            return rawType;\r\n        }\r\n\r\n        @Override\r\n        public Type getOwnerType() {\r\n            return ownerType;\r\n        }\r\n\r\n        @Override\r\n        public boolean equals(Object other) {\r\n            return other instanceof ParameterizedType && GsonTypes.equals(this, (ParameterizedType) other);\r\n        }\r\n\r\n        private static int hashCodeOrZero(Object o) {\r\n            return o != null ? o.hashCode() : 0;\r\n        }\r\n\r\n        @Override\r\n        public int hashCode() {\r\n            return Arrays.hashCode(typeArguments) ^ rawType.hashCode() ^ hashCodeOrZero(ownerType);\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            int length = typeArguments.length;\r\n            if (length == 0) {\r\n                return typeToString(rawType);\r\n            }\r\n            StringBuilder stringBuilder = new StringBuilder(30 * (length + 1));\r\n            stringBuilder.append(typeToString(rawType)).append(\"<\").append(typeToString(typeArguments[0]));\r\n            for (int i = 1; i < length; i++) {\r\n                stringBuilder.append(\", \").append(typeToString(typeArguments[i]));\r\n            }\r\n            return stringBuilder.append(\">\").toString();\r\n        }\r\n\r\n        private static final long serialVersionUID = 0;\r\n    }\r\n\r\n    private static final class GenericArrayTypeImpl implements GenericArrayType, Serializable {\r\n\r\n        @SuppressWarnings(\"serial\")\r\n        private final Type componentType;\r\n\r\n        public GenericArrayTypeImpl(Type componentType) {\r\n            requireNonNull(componentType);\r\n            this.componentType = canonicalize(componentType);\r\n        }\r\n\r\n        @Override\r\n        public Type getGenericComponentType() {\r\n            return componentType;\r\n        }\r\n\r\n        @Override\r\n        public boolean equals(Object o) {\r\n            return o instanceof GenericArrayType && GsonTypes.equals(this, (GenericArrayType) o);\r\n        }\r\n\r\n        @Override\r\n        public int hashCode() {\r\n            return componentType.hashCode();\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return typeToString(componentType) + \"[]\";\r\n        }\r\n\r\n        private static final long serialVersionUID = 0;\r\n    }\r\n\r\n    /**\r\n     * The WildcardType interface supports multiple upper bounds and multiple lower bounds. We only\r\n     * support what the target Java version supports - at most one bound, see also\r\n     * https://bugs.openjdk.java.net/browse/JDK-8250660. If a lower bound is set, the upper bound must\r\n     * be Object.class.\r\n     */\r\n    private static final class WildcardTypeImpl implements WildcardType, Serializable {\r\n\r\n        @SuppressWarnings(\"serial\")\r\n        private final Type upperBound;\r\n\r\n        @SuppressWarnings(\"serial\")\r\n        private final Type lowerBound;\r\n\r\n        public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {\r\n            if (lowerBounds.length > 1) {\r\n                throw new IllegalArgumentException(\"At most one lower bound is supported\");\r\n            }\r\n            if (upperBounds.length != 1) {\r\n                throw new IllegalArgumentException(\"Exactly one upper bound must be specified\");\r\n            }\r\n            if (lowerBounds.length == 1) {\r\n                requireNonNull(lowerBounds[0]);\r\n                checkNotPrimitive(lowerBounds[0]);\r\n                if (upperBounds[0] != Object.class) {\r\n                    throw new IllegalArgumentException(\"When lower bound is specified, upper bound must be Object\");\r\n                }\r\n                this.lowerBound = canonicalize(lowerBounds[0]);\r\n                this.upperBound = Object.class;\r\n            } else {\r\n                requireNonNull(upperBounds[0]);\r\n                checkNotPrimitive(upperBounds[0]);\r\n                this.lowerBound = null;\r\n                this.upperBound = canonicalize(upperBounds[0]);\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public Type[] getUpperBounds() {\r\n            return new Type[] { upperBound };\r\n        }\r\n\r\n        @Override\r\n        public Type[] getLowerBounds() {\r\n            return lowerBound != null ? new Type[] { lowerBound } : EMPTY_TYPE_ARRAY;\r\n        }\r\n\r\n        @Override\r\n        public boolean equals(Object other) {\r\n            return other instanceof WildcardType && GsonTypes.equals(this, (WildcardType) other);\r\n        }\r\n\r\n        @Override\r\n        public int hashCode() {\r\n            // this equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds());\r\n            return (lowerBound != null ? 31 + lowerBound.hashCode() : 1) ^ (31 + upperBound.hashCode());\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            if (lowerBound != null) {\r\n                return \"? super \" + typeToString(lowerBound);\r\n            } else if (upperBound == Object.class) {\r\n                return \"?\";\r\n            } else {\r\n                return \"? extends \" + typeToString(upperBound);\r\n            }\r\n        }\r\n\r\n        private static final long serialVersionUID = 0;\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "field",
    "name": "EMPTY_TYPE_ARRAY",
    "start_line": 45,
    "end_line": 45,
    "code": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "constructor",
    "name": "GsonTypes",
    "start_line": 47,
    "end_line": 49,
    "code": "private GsonTypes() {\r\n    throw new UnsupportedOperationException();\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "method",
    "name": "newParameterizedTypeWithOwner",
    "start_line": 57,
    "end_line": 60,
    "code": "/**\r\n * Returns a new parameterized type, applying {@code typeArguments} to {@code rawType} and\r\n * enclosed by {@code ownerType}.\r\n *\r\n * @return a {@link java.io.Serializable serializable} parameterized type.\r\n */\r\npublic static ParameterizedType newParameterizedTypeWithOwner(Type ownerType, Class<?> rawType, Type... typeArguments) {\r\n    return new ParameterizedTypeImpl(ownerType, rawType, typeArguments);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "method",
    "name": "arrayOf",
    "start_line": 67,
    "end_line": 69,
    "code": "/**\r\n * Returns an array type whose elements are all instances of {@code componentType}.\r\n *\r\n * @return a {@link java.io.Serializable serializable} generic array type.\r\n */\r\npublic static GenericArrayType arrayOf(Type componentType) {\r\n    return new GenericArrayTypeImpl(componentType);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "method",
    "name": "subtypeOf",
    "start_line": 77,
    "end_line": 85,
    "code": "/**\r\n * Returns a type that represents an unknown type that extends {@code bound}. For example, if\r\n * {@code bound} is {@code CharSequence.class}, this returns {@code ? extends CharSequence}. If\r\n * {@code bound} is {@code Object.class}, this returns {@code ?}, which is shorthand for {@code ?\r\n * extends Object}.\r\n */\r\npublic static WildcardType subtypeOf(Type bound) {\r\n    Type[] upperBounds;\r\n    if (bound instanceof WildcardType) {\r\n        upperBounds = ((WildcardType) bound).getUpperBounds();\r\n    } else {\r\n        upperBounds = new Type[] { bound };\r\n    }\r\n    return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "method",
    "name": "supertypeOf",
    "start_line": 91,
    "end_line": 99,
    "code": "/**\r\n * Returns a type that represents an unknown supertype of {@code bound}. For example, if {@code\r\n * bound} is {@code String.class}, this returns {@code ? super String}.\r\n */\r\npublic static WildcardType supertypeOf(Type bound) {\r\n    Type[] lowerBounds;\r\n    if (bound instanceof WildcardType) {\r\n        lowerBounds = ((WildcardType) bound).getLowerBounds();\r\n    } else {\r\n        lowerBounds = new Type[] { bound };\r\n    }\r\n    return new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "method",
    "name": "canonicalize",
    "start_line": 105,
    "end_line": 127,
    "code": "/**\r\n * Returns a type that is functionally equal but not necessarily equal according to {@link\r\n * Object#equals(Object) Object.equals()}. The returned type is {@link java.io.Serializable}.\r\n */\r\npublic static Type canonicalize(Type type) {\r\n    if (type instanceof Class) {\r\n        Class<?> c = (Class<?>) type;\r\n        return c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\r\n    } else if (type instanceof ParameterizedType) {\r\n        ParameterizedType p = (ParameterizedType) type;\r\n        return new ParameterizedTypeImpl(p.getOwnerType(), (Class<?>) p.getRawType(), p.getActualTypeArguments());\r\n    } else if (type instanceof GenericArrayType) {\r\n        GenericArrayType g = (GenericArrayType) type;\r\n        return new GenericArrayTypeImpl(g.getGenericComponentType());\r\n    } else if (type instanceof WildcardType) {\r\n        WildcardType w = (WildcardType) type;\r\n        return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\r\n    } else {\r\n        // type is either serializable as-is or unsupported\r\n        return type;\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "method",
    "name": "getRawType",
    "start_line": 129,
    "end_line": 165,
    "code": "public static Class<?> getRawType(Type type) {\r\n    if (type instanceof Class<?>) {\r\n        // type is a normal class.\r\n        return (Class<?>) type;\r\n    } else if (type instanceof ParameterizedType) {\r\n        ParameterizedType parameterizedType = (ParameterizedType) type;\r\n        // getRawType() returns Type instead of Class; that seems to be an API mistake,\r\n        // see https://bugs.openjdk.org/browse/JDK-8250659\r\n        Type rawType = parameterizedType.getRawType();\r\n        return (Class<?>) rawType;\r\n    } else if (type instanceof GenericArrayType) {\r\n        Type componentType = ((GenericArrayType) type).getGenericComponentType();\r\n        return Array.newInstance(getRawType(componentType), 0).getClass();\r\n    } else if (type instanceof TypeVariable) {\r\n        // we could use the variable's bounds, but that won't work if there are multiple.\r\n        // having a raw type that's more general than necessary is okay\r\n        return Object.class;\r\n    } else if (type instanceof WildcardType) {\r\n        Type[] bounds = ((WildcardType) type).getUpperBounds();\r\n        // Currently the JLS only permits one bound for wildcards so using first bound is safe\r\n        assert bounds.length == 1;\r\n        return getRawType(bounds[0]);\r\n    } else {\r\n        String className = type == null ? \"null\" : type.getClass().getName();\r\n        throw new IllegalArgumentException(\"Expected a Class, ParameterizedType, or GenericArrayType, but <\" + type + \"> is of type \" + className);\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "method",
    "name": "equal",
    "start_line": 167,
    "end_line": 169,
    "code": "private static boolean equal(Object a, Object b) {\r\n    return Objects.equals(a, b);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "method",
    "name": "equals",
    "start_line": 172,
    "end_line": 225,
    "code": "/**\r\n * Returns true if {@code a} and {@code b} are equal.\r\n */\r\npublic static boolean equals(Type a, Type b) {\r\n    if (a == b) {\r\n        // also handles (a == null && b == null)\r\n        return true;\r\n    } else if (a instanceof Class) {\r\n        // Class already specifies equals().\r\n        return a.equals(b);\r\n    } else if (a instanceof ParameterizedType) {\r\n        if (!(b instanceof ParameterizedType)) {\r\n            return false;\r\n        }\r\n        // TODO: save a .clone() call\r\n        ParameterizedType pa = (ParameterizedType) a;\r\n        ParameterizedType pb = (ParameterizedType) b;\r\n        return equal(pa.getOwnerType(), pb.getOwnerType()) && pa.getRawType().equals(pb.getRawType()) && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());\r\n    } else if (a instanceof GenericArrayType) {\r\n        if (!(b instanceof GenericArrayType)) {\r\n            return false;\r\n        }\r\n        GenericArrayType ga = (GenericArrayType) a;\r\n        GenericArrayType gb = (GenericArrayType) b;\r\n        return equals(ga.getGenericComponentType(), gb.getGenericComponentType());\r\n    } else if (a instanceof WildcardType) {\r\n        if (!(b instanceof WildcardType)) {\r\n            return false;\r\n        }\r\n        WildcardType wa = (WildcardType) a;\r\n        WildcardType wb = (WildcardType) b;\r\n        return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds()) && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());\r\n    } else if (a instanceof TypeVariable) {\r\n        if (!(b instanceof TypeVariable)) {\r\n            return false;\r\n        }\r\n        TypeVariable<?> va = (TypeVariable<?>) a;\r\n        TypeVariable<?> vb = (TypeVariable<?>) b;\r\n        return Objects.equals(va.getGenericDeclaration(), vb.getGenericDeclaration()) && va.getName().equals(vb.getName());\r\n    } else {\r\n        // This isn't a type we support. Could be a generic array type, wildcard type, etc.\r\n        return false;\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "method",
    "name": "typeToString",
    "start_line": 227,
    "end_line": 229,
    "code": "public static String typeToString(Type type) {\r\n    return type instanceof Class ? ((Class<?>) type).getName() : type.toString();\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "method",
    "name": "getGenericSupertype",
    "start_line": 236,
    "end_line": 268,
    "code": "/**\r\n * Returns the generic supertype for {@code supertype}. For example, given a class {@code\r\n * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the\r\n * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.\r\n */\r\nprivate static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> supertype) {\r\n    if (supertype == rawType) {\r\n        return context;\r\n    }\r\n    // we skip searching through interfaces if unknown is an interface\r\n    if (supertype.isInterface()) {\r\n        Class<?>[] interfaces = rawType.getInterfaces();\r\n        for (int i = 0, length = interfaces.length; i < length; i++) {\r\n            if (interfaces[i] == supertype) {\r\n                return rawType.getGenericInterfaces()[i];\r\n            } else if (supertype.isAssignableFrom(interfaces[i])) {\r\n                return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], supertype);\r\n            }\r\n        }\r\n    }\r\n    // check our supertypes\r\n    if (!rawType.isInterface()) {\r\n        while (rawType != Object.class) {\r\n            Class<?> rawSupertype = rawType.getSuperclass();\r\n            if (rawSupertype == supertype) {\r\n                return rawType.getGenericSuperclass();\r\n            } else if (supertype.isAssignableFrom(rawSupertype)) {\r\n                return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, supertype);\r\n            }\r\n            rawType = rawSupertype;\r\n        }\r\n    }\r\n    // we can't resolve this further\r\n    return supertype;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "method",
    "name": "getSupertype",
    "start_line": 277,
    "end_line": 292,
    "code": "/**\r\n * Returns the generic form of {@code supertype}. For example, if this is {@code\r\n * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code\r\n * Iterable.class}.\r\n *\r\n * @param supertype a superclass of, or interface implemented by, this.\r\n */\r\nprivate static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {\r\n    if (context instanceof WildcardType) {\r\n        // Wildcards are useless for resolving supertypes. As the upper bound has the same raw type,\r\n        // use it instead\r\n        Type[] bounds = ((WildcardType) context).getUpperBounds();\r\n        // Currently the JLS only permits one bound for wildcards so using first bound is safe\r\n        assert bounds.length == 1;\r\n        context = bounds[0];\r\n    }\r\n    if (!supertype.isAssignableFrom(contextRawType)) {\r\n        throw new IllegalArgumentException(contextRawType + \" is not the same as or a subtype of \" + supertype);\r\n    }\r\n    return resolve(context, contextRawType, GsonTypes.getGenericSupertype(context, contextRawType, supertype));\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "method",
    "name": "getArrayComponentType",
    "start_line": 299,
    "end_line": 303,
    "code": "/**\r\n * Returns the component type of this array type.\r\n *\r\n * @throws ClassCastException if this type is not an array.\r\n */\r\npublic static Type getArrayComponentType(Type array) {\r\n    return array instanceof GenericArrayType ? ((GenericArrayType) array).getGenericComponentType() : ((Class<?>) array).getComponentType();\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "method",
    "name": "getCollectionElementType",
    "start_line": 310,
    "end_line": 317,
    "code": "/**\r\n * Returns the element type of this collection type.\r\n *\r\n * @throws IllegalArgumentException if this type is not a collection.\r\n */\r\npublic static Type getCollectionElementType(Type context, Class<?> contextRawType) {\r\n    Type collectionType = getSupertype(context, contextRawType, Collection.class);\r\n    if (collectionType instanceof ParameterizedType) {\r\n        return ((ParameterizedType) collectionType).getActualTypeArguments()[0];\r\n    }\r\n    return Object.class;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "method",
    "name": "getMapKeyAndValueTypes",
    "start_line": 323,
    "end_line": 340,
    "code": "/**\r\n * Returns a two element array containing this map's key and value types in positions 0 and 1\r\n * respectively.\r\n */\r\npublic static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) {\r\n    /*\r\n     * Work around a problem with the declaration of java.util.Properties. That\r\n     * class should extend Hashtable<String, String>, but it's declared to\r\n     * extend Hashtable<Object, Object>.\r\n     */\r\n    if (Properties.class.isAssignableFrom(contextRawType)) {\r\n        return new Type[] { String.class, String.class };\r\n    }\r\n    Type mapType = getSupertype(context, contextRawType, Map.class);\r\n    // TODO: strip wildcards?\r\n    if (mapType instanceof ParameterizedType) {\r\n        ParameterizedType mapParameterizedType = (ParameterizedType) mapType;\r\n        return mapParameterizedType.getActualTypeArguments();\r\n    }\r\n    return new Type[] { Object.class, Object.class };\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "method",
    "name": "resolve",
    "start_line": 342,
    "end_line": 345,
    "code": "public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\r\n    return resolve(context, contextRawType, toResolve, new HashMap<TypeVariable<?>, Type>());\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "method",
    "name": "resolve",
    "start_line": 347,
    "end_line": 449,
    "code": "private static Type resolve(Type context, Class<?> contextRawType, Type toResolve, Map<TypeVariable<?>, Type> visitedTypeVariables) {\r\n    // this implementation is made a little more complicated in an attempt to avoid object-creation\r\n    TypeVariable<?> resolving = null;\r\n    while (true) {\r\n        if (toResolve instanceof TypeVariable) {\r\n            TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\r\n            Type previouslyResolved = visitedTypeVariables.get(typeVariable);\r\n            if (previouslyResolved != null) {\r\n                // cannot reduce due to infinite recursion\r\n                return (previouslyResolved == Void.TYPE) ? toResolve : previouslyResolved;\r\n            }\r\n            // Insert a placeholder to mark the fact that we are in the process of resolving this type\r\n            visitedTypeVariables.put(typeVariable, Void.TYPE);\r\n            if (resolving == null) {\r\n                resolving = typeVariable;\r\n            }\r\n            toResolve = resolveTypeVariable(context, contextRawType, typeVariable);\r\n            if (toResolve == typeVariable) {\r\n                break;\r\n            }\r\n        } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\r\n            Class<?> original = (Class<?>) toResolve;\r\n            Type componentType = original.getComponentType();\r\n            Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\r\n            toResolve = equal(componentType, newComponentType) ? original : arrayOf(newComponentType);\r\n            break;\r\n        } else if (toResolve instanceof GenericArrayType) {\r\n            GenericArrayType original = (GenericArrayType) toResolve;\r\n            Type componentType = original.getGenericComponentType();\r\n            Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\r\n            toResolve = equal(componentType, newComponentType) ? original : arrayOf(newComponentType);\r\n            break;\r\n        } else if (toResolve instanceof ParameterizedType) {\r\n            ParameterizedType original = (ParameterizedType) toResolve;\r\n            Type ownerType = original.getOwnerType();\r\n            Type newOwnerType = resolve(context, contextRawType, ownerType, visitedTypeVariables);\r\n            boolean ownerChanged = !equal(newOwnerType, ownerType);\r\n            Type[] args = original.getActualTypeArguments();\r\n            boolean argsChanged = false;\r\n            for (int t = 0, length = args.length; t < length; t++) {\r\n                Type resolvedTypeArgument = resolve(context, contextRawType, args[t], visitedTypeVariables);\r\n                if (!equal(resolvedTypeArgument, args[t])) {\r\n                    if (!argsChanged) {\r\n                        args = args.clone();\r\n                        argsChanged = true;\r\n                    }\r\n                    args[t] = resolvedTypeArgument;\r\n                }\r\n            }\r\n            toResolve = ownerChanged || argsChanged ? newParameterizedTypeWithOwner(newOwnerType, (Class<?>) original.getRawType(), args) : original;\r\n            break;\r\n        } else if (toResolve instanceof WildcardType) {\r\n            WildcardType original = (WildcardType) toResolve;\r\n            Type[] originalLowerBound = original.getLowerBounds();\r\n            Type[] originalUpperBound = original.getUpperBounds();\r\n            if (originalLowerBound.length == 1) {\r\n                Type lowerBound = resolve(context, contextRawType, originalLowerBound[0], visitedTypeVariables);\r\n                if (lowerBound != originalLowerBound[0]) {\r\n                    toResolve = supertypeOf(lowerBound);\r\n                    break;\r\n                }\r\n            } else if (originalUpperBound.length == 1) {\r\n                Type upperBound = resolve(context, contextRawType, originalUpperBound[0], visitedTypeVariables);\r\n                if (upperBound != originalUpperBound[0]) {\r\n                    toResolve = subtypeOf(upperBound);\r\n                    break;\r\n                }\r\n            }\r\n            toResolve = original;\r\n            break;\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    // ensure that any in-process resolution gets updated with the final result\r\n    if (resolving != null) {\r\n        visitedTypeVariables.put(resolving, toResolve);\r\n    }\r\n    return toResolve;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "method",
    "name": "resolveTypeVariable",
    "start_line": 451,
    "end_line": 467,
    "code": "private static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable<?> unknown) {\r\n    Class<?> declaredByRaw = declaringClassOf(unknown);\r\n    // we can't reduce this further\r\n    if (declaredByRaw == null) {\r\n        return unknown;\r\n    }\r\n    Type declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);\r\n    if (declaredBy instanceof ParameterizedType) {\r\n        int index = indexOf(declaredByRaw.getTypeParameters(), unknown);\r\n        return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];\r\n    }\r\n    return unknown;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "method",
    "name": "indexOf",
    "start_line": 469,
    "end_line": 476,
    "code": "private static int indexOf(Object[] array, Object toFind) {\r\n    for (int i = 0, length = array.length; i < length; i++) {\r\n        if (toFind.equals(array[i])) {\r\n            return i;\r\n        }\r\n    }\r\n    throw new NoSuchElementException();\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "method",
    "name": "declaringClassOf",
    "start_line": 482,
    "end_line": 485,
    "code": "/**\r\n * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by\r\n * a class.\r\n */\r\nprivate static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {\r\n    GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();\r\n    return genericDeclaration instanceof Class ? (Class<?>) genericDeclaration : null;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "method",
    "name": "checkNotPrimitive",
    "start_line": 487,
    "end_line": 491,
    "code": "static void checkNotPrimitive(Type type) {\r\n    if (type instanceof Class<?> && ((Class<?>) type).isPrimitive()) {\r\n        throw new IllegalArgumentException(\"Primitive type is not allowed\");\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  },
  {
    "type": "method",
    "name": "requiresOwnerType",
    "start_line": 500,
    "end_line": 507,
    "code": "/**\r\n * Whether an {@linkplain ParameterizedType#getOwnerType() owner type} must be specified when\r\n * constructing a {@link ParameterizedType} for {@code rawType}.\r\n *\r\n * <p>Note that this method might not require an owner type for all cases where Java reflection\r\n * would create parameterized types with owner type.\r\n */\r\npublic static boolean requiresOwnerType(Type rawType) {\r\n    if (rawType instanceof Class<?>) {\r\n        Class<?> rawTypeAsClass = (Class<?>) rawType;\r\n        return !Modifier.isStatic(rawTypeAsClass.getModifiers()) && rawTypeAsClass.getDeclaringClass() != null;\r\n    }\r\n    return false;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\GsonTypes.java"
  }
]