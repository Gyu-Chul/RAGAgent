[
  {
    "type": "package",
    "name": "com.google.gson",
    "start_line": 17,
    "end_line": 17,
    "code": "package com.google.gson;\r\n\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\TypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.reflect.TypeToken",
    "start_line": 19,
    "end_line": 19,
    "code": "import com.google.gson.reflect.TypeToken;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\TypeAdapterFactory.java"
  },
  {
    "type": "interface",
    "name": "TypeAdapterFactory",
    "start_line": 164,
    "end_line": 170,
    "code": "/**\r\n * Creates type adapters for set of related types. Type adapter factories are most useful when\r\n * several types share similar structure in their JSON form.\r\n *\r\n * <h2>Examples</h2>\r\n *\r\n * <h3>Example: Converting enums to lowercase</h3>\r\n *\r\n * In this example, we implement a factory that creates type adapters for all enums. The type\r\n * adapters will write enums in lowercase, despite the fact that they're defined in {@code\r\n * CONSTANT_CASE} in the corresponding Java model:\r\n *\r\n * <pre>{@code\r\n * public class LowercaseEnumTypeAdapterFactory implements TypeAdapterFactory {\r\n *   public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\r\n *     Class<T> rawType = (Class<T>) type.getRawType();\r\n *     if (!rawType.isEnum()) {\r\n *       return null;\r\n *     }\r\n *\r\n *     final Map<String, T> lowercaseToConstant = new HashMap<>();\r\n *     for (T constant : rawType.getEnumConstants()) {\r\n *       lowercaseToConstant.put(toLowercase(constant), constant);\r\n *     }\r\n *\r\n *     return new TypeAdapter<T>() {\r\n *       public void write(JsonWriter out, T value) throws IOException {\r\n *         if (value == null) {\r\n *           out.nullValue();\r\n *         } else {\r\n *           out.value(toLowercase(value));\r\n *         }\r\n *       }\r\n *\r\n *       public T read(JsonReader reader) throws IOException {\r\n *         if (reader.peek() == JsonToken.NULL) {\r\n *           reader.nextNull();\r\n *           return null;\r\n *         } else {\r\n *           return lowercaseToConstant.get(reader.nextString());\r\n *         }\r\n *       }\r\n *     };\r\n *   }\r\n *\r\n *   private String toLowercase(Object o) {\r\n *     return o.toString().toLowerCase(Locale.US);\r\n *   }\r\n * }\r\n * }</pre>\r\n *\r\n * <p>Type adapter factories select which types they provide type adapters for. If a factory cannot\r\n * support a given type, it must return null when that type is passed to {@link #create}. Factories\r\n * should expect {@code create()} to be called on them for many types and should return null for\r\n * most of those types. In the above example the factory returns null for calls to {@code create()}\r\n * where {@code type} is not an enum.\r\n *\r\n * <p>A factory is typically called once per type, but the returned type adapter may be used many\r\n * times. It is most efficient to do expensive work like reflection in {@code create()} so that the\r\n * type adapter's {@code read()} and {@code write()} methods can be very fast. In this example the\r\n * mapping from lowercase name to enum value is computed eagerly.\r\n *\r\n * <p>As with type adapters, factories must be <i>registered</i> with a {@link\r\n * com.google.gson.GsonBuilder} for them to take effect:\r\n *\r\n * <pre>{@code\r\n * GsonBuilder builder = new GsonBuilder();\r\n * builder.registerTypeAdapterFactory(new LowercaseEnumTypeAdapterFactory());\r\n * ...\r\n * Gson gson = builder.create();\r\n * }</pre>\r\n *\r\n * If multiple factories support the same type, the factory registered earlier takes precedence.\r\n *\r\n * <h3>Example: Composing other type adapters</h3>\r\n *\r\n * In this example we implement a factory for Guava's {@code Multiset} collection type. The factory\r\n * can be used to create type adapters for multisets of any element type: the type adapter for\r\n * {@code Multiset<String>} is different from the type adapter for {@code Multiset<URL>}.\r\n *\r\n * <p>The type adapter <i>delegates</i> to another type adapter for the multiset elements. It\r\n * figures out the element type by reflecting on the multiset's type token. A {@code Gson} is passed\r\n * in to {@code create} for just this purpose:\r\n *\r\n * <pre>{@code\r\n * public class MultisetTypeAdapterFactory implements TypeAdapterFactory {\r\n *   public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\r\n *     Type type = typeToken.getType();\r\n *     if (typeToken.getRawType() != Multiset.class\r\n *         || !(type instanceof ParameterizedType)) {\r\n *       return null;\r\n *     }\r\n *\r\n *     Type elementType = ((ParameterizedType) type).getActualTypeArguments()[0];\r\n *     TypeAdapter<?> elementAdapter = gson.getAdapter(TypeToken.get(elementType));\r\n *     return (TypeAdapter<T>) newMultisetAdapter(elementAdapter);\r\n *   }\r\n *\r\n *   private <E> TypeAdapter<Multiset<E>> newMultisetAdapter(\r\n *       TypeAdapter<E> elementAdapter) {\r\n *     return new TypeAdapter<Multiset<E>>() {\r\n *       public void write(JsonWriter out, Multiset<E> value) throws IOException {\r\n *         if (value == null) {\r\n *           out.nullValue();\r\n *           return;\r\n *         }\r\n *\r\n *         out.beginArray();\r\n *         for (Multiset.Entry<E> entry : value.entrySet()) {\r\n *           out.value(entry.getCount());\r\n *           elementAdapter.write(out, entry.getElement());\r\n *         }\r\n *         out.endArray();\r\n *       }\r\n *\r\n *       public Multiset<E> read(JsonReader in) throws IOException {\r\n *         if (in.peek() == JsonToken.NULL) {\r\n *           in.nextNull();\r\n *           return null;\r\n *         }\r\n *\r\n *         Multiset<E> result = LinkedHashMultiset.create();\r\n *         in.beginArray();\r\n *         while (in.hasNext()) {\r\n *           int count = in.nextInt();\r\n *           E element = elementAdapter.read(in);\r\n *           result.add(element, count);\r\n *         }\r\n *         in.endArray();\r\n *         return result;\r\n *       }\r\n *     };\r\n *   }\r\n * }\r\n * }</pre>\r\n *\r\n * Delegating from one type adapter to another is extremely powerful; it's the foundation of how\r\n * Gson converts Java objects and collections. Whenever possible your factory should retrieve its\r\n * delegate type adapter in the {@code create()} method; this ensures potentially-expensive type\r\n * adapter creation happens only once.\r\n *\r\n * @since 2.1\r\n */\r\npublic interface TypeAdapterFactory {\r\n\r\n    /**\r\n     * Returns a type adapter for {@code type}, or null if this factory doesn't support {@code type}.\r\n     */\r\n    <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\TypeAdapterFactory.java"
  },
  {
    "type": "method",
    "name": "create",
    "start_line": 169,
    "end_line": 169,
    "code": "/**\r\n * Returns a type adapter for {@code type}, or null if this factory doesn't support {@code type}.\r\n */\r\n<T> TypeAdapter<T> create(Gson gson, TypeToken<T> type);",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\TypeAdapterFactory.java"
  }
]