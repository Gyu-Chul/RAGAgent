[
  {
    "type": "package",
    "name": "com.google.gson.internal.bind.util",
    "start_line": 17,
    "end_line": 17,
    "code": "package com.google.gson.internal.bind.util;\r\n\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\util\\ISO8601Utils.java"
  },
  {
    "type": "import",
    "name": "java.text.ParseException",
    "start_line": 19,
    "end_line": 19,
    "code": "import java.text.ParseException;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\util\\ISO8601Utils.java"
  },
  {
    "type": "import",
    "name": "java.text.ParsePosition",
    "start_line": 20,
    "end_line": 20,
    "code": "import java.text.ParsePosition;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\util\\ISO8601Utils.java"
  },
  {
    "type": "import",
    "name": "java.util.Calendar",
    "start_line": 21,
    "end_line": 21,
    "code": "import java.util.Calendar;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\util\\ISO8601Utils.java"
  },
  {
    "type": "import",
    "name": "java.util.Date",
    "start_line": 22,
    "end_line": 22,
    "code": "import java.util.Date;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\util\\ISO8601Utils.java"
  },
  {
    "type": "import",
    "name": "java.util.GregorianCalendar",
    "start_line": 23,
    "end_line": 23,
    "code": "import java.util.GregorianCalendar;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\util\\ISO8601Utils.java"
  },
  {
    "type": "import",
    "name": "java.util.Locale",
    "start_line": 24,
    "end_line": 24,
    "code": "import java.util.Locale;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\util\\ISO8601Utils.java"
  },
  {
    "type": "import",
    "name": "java.util.TimeZone",
    "start_line": 25,
    "end_line": 25,
    "code": "import java.util.TimeZone;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\util\\ISO8601Utils.java"
  },
  {
    "type": "class",
    "name": "ISO8601Utils",
    "start_line": 38,
    "end_line": 386,
    "code": "/**\r\n * Utilities methods for manipulating dates in iso8601 format. This is much faster and GC friendly\r\n * than using SimpleDateFormat so highly suitable if you (un)serialize lots of date objects.\r\n *\r\n * <p>Supported parse format:\r\n * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:]mm]]\r\n *\r\n * @see <a href=\"http://www.w3.org/TR/NOTE-datetime\">this specification</a>\r\n */\r\n// Date parsing code from Jackson databind ISO8601Utils.java\r\n// https://github.com/FasterXML/jackson-databind/blob/2.8/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java\r\n// legacy class name\r\n@SuppressWarnings(\"MemberName\")\r\npublic class ISO8601Utils {\r\n\r\n    private ISO8601Utils() {\r\n    }\r\n\r\n    /**\r\n     * ID to represent the 'UTC' string, default timezone since Jackson 2.7\r\n     *\r\n     * @since 2.7\r\n     */\r\n    private static final String UTC_ID = \"UTC\";\r\n\r\n    /**\r\n     * The UTC timezone, prefetched to avoid more lookups.\r\n     *\r\n     * @since 2.7\r\n     */\r\n    private static final TimeZone TIMEZONE_UTC = TimeZone.getTimeZone(UTC_ID);\r\n\r\n    /*\r\n  /**********************************************************\r\n  /* Formatting\r\n  /**********************************************************\r\n   */\r\n    /**\r\n     * Format a date into 'yyyy-MM-ddThh:mm:ssZ' (default timezone, no milliseconds precision)\r\n     *\r\n     * @param date the date to format\r\n     * @return the date formatted as 'yyyy-MM-ddThh:mm:ssZ'\r\n     */\r\n    public static String format(Date date) {\r\n        return format(date, false, TIMEZONE_UTC);\r\n    }\r\n\r\n    /**\r\n     * Format a date into 'yyyy-MM-ddThh:mm:ss[.sss]Z' (GMT timezone)\r\n     *\r\n     * @param date the date to format\r\n     * @param millis true to include millis precision otherwise false\r\n     * @return the date formatted as 'yyyy-MM-ddThh:mm:ss[.sss]Z'\r\n     */\r\n    public static String format(Date date, boolean millis) {\r\n        return format(date, millis, TIMEZONE_UTC);\r\n    }\r\n\r\n    /**\r\n     * Format date into yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\r\n     *\r\n     * @param date the date to format\r\n     * @param millis true to include millis precision otherwise false\r\n     * @param tz timezone to use for the formatting (UTC will produce 'Z')\r\n     * @return the date formatted as yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\r\n     */\r\n    public static String format(Date date, boolean millis, TimeZone tz) {\r\n        Calendar calendar = new GregorianCalendar(tz, Locale.US);\r\n        calendar.setTime(date);\r\n        // estimate capacity of buffer as close as we can (yeah, that's pedantic ;)\r\n        int capacity = \"yyyy-MM-ddThh:mm:ss\".length();\r\n        capacity += millis ? \".sss\".length() : 0;\r\n        capacity += tz.getRawOffset() == 0 ? \"Z\".length() : \"+hh:mm\".length();\r\n        StringBuilder formatted = new StringBuilder(capacity);\r\n        padInt(formatted, calendar.get(Calendar.YEAR), \"yyyy\".length());\r\n        formatted.append('-');\r\n        padInt(formatted, calendar.get(Calendar.MONTH) + 1, \"MM\".length());\r\n        formatted.append('-');\r\n        padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), \"dd\".length());\r\n        formatted.append('T');\r\n        padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), \"hh\".length());\r\n        formatted.append(':');\r\n        padInt(formatted, calendar.get(Calendar.MINUTE), \"mm\".length());\r\n        formatted.append(':');\r\n        padInt(formatted, calendar.get(Calendar.SECOND), \"ss\".length());\r\n        if (millis) {\r\n            formatted.append('.');\r\n            padInt(formatted, calendar.get(Calendar.MILLISECOND), \"sss\".length());\r\n        }\r\n        int offset = tz.getOffset(calendar.getTimeInMillis());\r\n        if (offset != 0) {\r\n            int hours = Math.abs((offset / (60 * 1000)) / 60);\r\n            int minutes = Math.abs((offset / (60 * 1000)) % 60);\r\n            formatted.append(offset < 0 ? '-' : '+');\r\n            padInt(formatted, hours, \"hh\".length());\r\n            formatted.append(':');\r\n            padInt(formatted, minutes, \"mm\".length());\r\n        } else {\r\n            formatted.append('Z');\r\n        }\r\n        return formatted.toString();\r\n    }\r\n\r\n    /*\r\n  /**********************************************************\r\n  /* Parsing\r\n  /**********************************************************\r\n   */\r\n    /**\r\n     * Parse a date from ISO-8601 formatted string. It expects a format\r\n     * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:mm]]]\r\n     *\r\n     * @param date ISO string to parse in the appropriate format.\r\n     * @param pos The position to start parsing from, updated to where parsing stopped.\r\n     * @return the parsed date\r\n     * @throws ParseException if the date is not in the appropriate format\r\n     */\r\n    public static Date parse(String date, ParsePosition pos) throws ParseException {\r\n        Exception fail = null;\r\n        try {\r\n            int offset = pos.getIndex();\r\n            // extract year\r\n            int year = parseInt(date, offset, offset += 4);\r\n            if (checkOffset(date, offset, '-')) {\r\n                offset += 1;\r\n            }\r\n            // extract month\r\n            int month = parseInt(date, offset, offset += 2);\r\n            if (checkOffset(date, offset, '-')) {\r\n                offset += 1;\r\n            }\r\n            // extract day\r\n            int day = parseInt(date, offset, offset += 2);\r\n            // default time value\r\n            int hour = 0;\r\n            int minutes = 0;\r\n            int seconds = 0;\r\n            // always use 0 otherwise returned date will include millis of current time\r\n            int milliseconds = 0;\r\n            // if the value has no time component (and no time zone), we are done\r\n            boolean hasT = checkOffset(date, offset, 'T');\r\n            if (!hasT && (date.length() <= offset)) {\r\n                Calendar calendar = new GregorianCalendar(year, month - 1, day);\r\n                calendar.setLenient(false);\r\n                pos.setIndex(offset);\r\n                return calendar.getTime();\r\n            }\r\n            if (hasT) {\r\n                // extract hours, minutes, seconds and milliseconds\r\n                hour = parseInt(date, offset += 1, offset += 2);\r\n                if (checkOffset(date, offset, ':')) {\r\n                    offset += 1;\r\n                }\r\n                minutes = parseInt(date, offset, offset += 2);\r\n                if (checkOffset(date, offset, ':')) {\r\n                    offset += 1;\r\n                }\r\n                // second and milliseconds can be optional\r\n                if (date.length() > offset) {\r\n                    char c = date.charAt(offset);\r\n                    if (c != 'Z' && c != '+' && c != '-') {\r\n                        seconds = parseInt(date, offset, offset += 2);\r\n                        if (seconds > 59 && seconds < 63) {\r\n                            // truncate up to 3 leap seconds\r\n                            seconds = 59;\r\n                        }\r\n                        // milliseconds can be optional in the format\r\n                        if (checkOffset(date, offset, '.')) {\r\n                            offset += 1;\r\n                            // assume at least one digit\r\n                            int endOffset = indexOfNonDigit(date, offset + 1);\r\n                            // parse up to 3 digits\r\n                            int parseEndOffset = Math.min(endOffset, offset + 3);\r\n                            int fraction = parseInt(date, offset, parseEndOffset);\r\n                            // compensate for \"missing\" digits\r\n                            switch(// number of digits parsed\r\n                            parseEndOffset - offset) {\r\n                                case 2:\r\n                                    milliseconds = fraction * 10;\r\n                                    break;\r\n                                case 1:\r\n                                    milliseconds = fraction * 100;\r\n                                    break;\r\n                                default:\r\n                                    milliseconds = fraction;\r\n                            }\r\n                            offset = endOffset;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // extract timezone\r\n            if (date.length() <= offset) {\r\n                throw new IllegalArgumentException(\"No time zone indicator\");\r\n            }\r\n            TimeZone timezone = null;\r\n            char timezoneIndicator = date.charAt(offset);\r\n            if (timezoneIndicator == 'Z') {\r\n                timezone = TIMEZONE_UTC;\r\n                offset += 1;\r\n            } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\r\n                String timezoneOffset = date.substring(offset);\r\n                // When timezone has no minutes, we should append it, valid timezones are, for example:\r\n                // +00:00, +0000 and +00\r\n                timezoneOffset = timezoneOffset.length() >= 5 ? timezoneOffset : timezoneOffset + \"00\";\r\n                offset += timezoneOffset.length();\r\n                // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\r\n                if (timezoneOffset.equals(\"+0000\") || timezoneOffset.equals(\"+00:00\")) {\r\n                    timezone = TIMEZONE_UTC;\r\n                } else {\r\n                    // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\r\n                    //    not sure why, but that's the way it looks. Further, Javadocs for\r\n                    //    `java.util.TimeZone` specifically instruct use of GMT as base for\r\n                    //    custom timezones... odd.\r\n                    String timezoneId = \"GMT\" + timezoneOffset;\r\n                    // String timezoneId = \"UTC\" + timezoneOffset;\r\n                    timezone = TimeZone.getTimeZone(timezoneId);\r\n                    String act = timezone.getID();\r\n                    if (!act.equals(timezoneId)) {\r\n                        /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given\r\n             *    one without. If so, don't sweat.\r\n             *   Yes, very inefficient. Hopefully not hit often.\r\n             *   If it becomes a perf problem, add 'loose' comparison instead.\r\n             */\r\n                        String cleaned = act.replace(\":\", \"\");\r\n                        if (!cleaned.equals(timezoneId)) {\r\n                            throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneId + \" given, resolves to \" + timezone.getID());\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\");\r\n            }\r\n            Calendar calendar = new GregorianCalendar(timezone);\r\n            calendar.setLenient(false);\r\n            calendar.set(Calendar.YEAR, year);\r\n            calendar.set(Calendar.MONTH, month - 1);\r\n            calendar.set(Calendar.DAY_OF_MONTH, day);\r\n            calendar.set(Calendar.HOUR_OF_DAY, hour);\r\n            calendar.set(Calendar.MINUTE, minutes);\r\n            calendar.set(Calendar.SECOND, seconds);\r\n            calendar.set(Calendar.MILLISECOND, milliseconds);\r\n            pos.setIndex(offset);\r\n            return calendar.getTime();\r\n            // If we get a ParseException it'll already have the right message/offset.\r\n            // Other exception types can convert here.\r\n        } catch (IndexOutOfBoundsException | IllegalArgumentException e) {\r\n            fail = e;\r\n        }\r\n        String input = (date == null) ? null : ('\"' + date + '\"');\r\n        String msg = fail.getMessage();\r\n        if (msg == null || msg.isEmpty()) {\r\n            msg = \"(\" + fail.getClass().getName() + \")\";\r\n        }\r\n        ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\r\n        ex.initCause(fail);\r\n        throw ex;\r\n    }\r\n\r\n    /**\r\n     * Check if the expected character exist at the given offset in the value.\r\n     *\r\n     * @param value the string to check at the specified offset\r\n     * @param offset the offset to look for the expected character\r\n     * @param expected the expected character\r\n     * @return true if the expected character exist at the given offset\r\n     */\r\n    private static boolean checkOffset(String value, int offset, char expected) {\r\n        return (offset < value.length()) && (value.charAt(offset) == expected);\r\n    }\r\n\r\n    /**\r\n     * Parse an integer located between 2 given offsets in a string\r\n     *\r\n     * @param value the string to parse\r\n     * @param beginIndex the start index for the integer in the string\r\n     * @param endIndex the end index for the integer in the string\r\n     * @return the int\r\n     * @throws NumberFormatException if the value is not a number\r\n     */\r\n    private static int parseInt(String value, int beginIndex, int endIndex) throws NumberFormatException {\r\n        if (beginIndex < 0 || endIndex > value.length() || beginIndex > endIndex) {\r\n            throw new NumberFormatException(value);\r\n        }\r\n        // use same logic as in Integer.parseInt() but less generic we're not supporting negative values\r\n        int i = beginIndex;\r\n        int result = 0;\r\n        int digit;\r\n        if (i < endIndex) {\r\n            digit = Character.digit(value.charAt(i++), 10);\r\n            if (digit < 0) {\r\n                throw new NumberFormatException(\"Invalid number: \" + value.substring(beginIndex, endIndex));\r\n            }\r\n            result = -digit;\r\n        }\r\n        while (i < endIndex) {\r\n            digit = Character.digit(value.charAt(i++), 10);\r\n            if (digit < 0) {\r\n                throw new NumberFormatException(\"Invalid number: \" + value.substring(beginIndex, endIndex));\r\n            }\r\n            result *= 10;\r\n            result -= digit;\r\n        }\r\n        return -result;\r\n    }\r\n\r\n    /**\r\n     * Zero pad a number to a specified length\r\n     *\r\n     * @param buffer buffer to use for padding\r\n     * @param value the integer value to pad if necessary.\r\n     * @param length the length of the string we should zero pad\r\n     */\r\n    private static void padInt(StringBuilder buffer, int value, int length) {\r\n        String strValue = Integer.toString(value);\r\n        for (int i = length - strValue.length(); i > 0; i--) {\r\n            buffer.append('0');\r\n        }\r\n        buffer.append(strValue);\r\n    }\r\n\r\n    /**\r\n     * Returns the index of the first character in the string that is not a digit, starting at offset.\r\n     */\r\n    private static int indexOfNonDigit(String string, int offset) {\r\n        for (int i = offset; i < string.length(); i++) {\r\n            char c = string.charAt(i);\r\n            if (c < '0' || c > '9') {\r\n                return i;\r\n            }\r\n        }\r\n        return string.length();\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\util\\ISO8601Utils.java"
  },
  {
    "type": "field",
    "name": "UTC_ID",
    "start_line": 47,
    "end_line": 47,
    "code": "/**\r\n * ID to represent the 'UTC' string, default timezone since Jackson 2.7\r\n *\r\n * @since 2.7\r\n */\r\nprivate static final String UTC_ID = \"UTC\";",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\util\\ISO8601Utils.java"
  },
  {
    "type": "field",
    "name": "TIMEZONE_UTC",
    "start_line": 54,
    "end_line": 54,
    "code": "/**\r\n * The UTC timezone, prefetched to avoid more lookups.\r\n *\r\n * @since 2.7\r\n */\r\nprivate static final TimeZone TIMEZONE_UTC = TimeZone.getTimeZone(UTC_ID);",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\util\\ISO8601Utils.java"
  },
  {
    "type": "constructor",
    "name": "ISO8601Utils",
    "start_line": 40,
    "end_line": 40,
    "code": "private ISO8601Utils() {\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\util\\ISO8601Utils.java"
  },
  {
    "type": "method",
    "name": "format",
    "start_line": 68,
    "end_line": 70,
    "code": "/*\r\n  /**********************************************************\r\n  /* Formatting\r\n  /**********************************************************\r\n   */\r\n/**\r\n * Format a date into 'yyyy-MM-ddThh:mm:ssZ' (default timezone, no milliseconds precision)\r\n *\r\n * @param date the date to format\r\n * @return the date formatted as 'yyyy-MM-ddThh:mm:ssZ'\r\n */\r\npublic static String format(Date date) {\r\n    return format(date, false, TIMEZONE_UTC);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\util\\ISO8601Utils.java"
  },
  {
    "type": "method",
    "name": "format",
    "start_line": 79,
    "end_line": 81,
    "code": "/**\r\n * Format a date into 'yyyy-MM-ddThh:mm:ss[.sss]Z' (GMT timezone)\r\n *\r\n * @param date the date to format\r\n * @param millis true to include millis precision otherwise false\r\n * @return the date formatted as 'yyyy-MM-ddThh:mm:ss[.sss]Z'\r\n */\r\npublic static String format(Date date, boolean millis) {\r\n    return format(date, millis, TIMEZONE_UTC);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\util\\ISO8601Utils.java"
  },
  {
    "type": "method",
    "name": "format",
    "start_line": 91,
    "end_line": 130,
    "code": "/**\r\n * Format date into yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\r\n *\r\n * @param date the date to format\r\n * @param millis true to include millis precision otherwise false\r\n * @param tz timezone to use for the formatting (UTC will produce 'Z')\r\n * @return the date formatted as yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\r\n */\r\npublic static String format(Date date, boolean millis, TimeZone tz) {\r\n    Calendar calendar = new GregorianCalendar(tz, Locale.US);\r\n    calendar.setTime(date);\r\n    // estimate capacity of buffer as close as we can (yeah, that's pedantic ;)\r\n    int capacity = \"yyyy-MM-ddThh:mm:ss\".length();\r\n    capacity += millis ? \".sss\".length() : 0;\r\n    capacity += tz.getRawOffset() == 0 ? \"Z\".length() : \"+hh:mm\".length();\r\n    StringBuilder formatted = new StringBuilder(capacity);\r\n    padInt(formatted, calendar.get(Calendar.YEAR), \"yyyy\".length());\r\n    formatted.append('-');\r\n    padInt(formatted, calendar.get(Calendar.MONTH) + 1, \"MM\".length());\r\n    formatted.append('-');\r\n    padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), \"dd\".length());\r\n    formatted.append('T');\r\n    padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), \"hh\".length());\r\n    formatted.append(':');\r\n    padInt(formatted, calendar.get(Calendar.MINUTE), \"mm\".length());\r\n    formatted.append(':');\r\n    padInt(formatted, calendar.get(Calendar.SECOND), \"ss\".length());\r\n    if (millis) {\r\n        formatted.append('.');\r\n        padInt(formatted, calendar.get(Calendar.MILLISECOND), \"sss\".length());\r\n    }\r\n    int offset = tz.getOffset(calendar.getTimeInMillis());\r\n    if (offset != 0) {\r\n        int hours = Math.abs((offset / (60 * 1000)) / 60);\r\n        int minutes = Math.abs((offset / (60 * 1000)) % 60);\r\n        formatted.append(offset < 0 ? '-' : '+');\r\n        padInt(formatted, hours, \"hh\".length());\r\n        formatted.append(':');\r\n        padInt(formatted, minutes, \"mm\".length());\r\n    } else {\r\n        formatted.append('Z');\r\n    }\r\n    return formatted.toString();\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\util\\ISO8601Utils.java"
  },
  {
    "type": "method",
    "name": "parse",
    "start_line": 147,
    "end_line": 309,
    "code": "/*\r\n  /**********************************************************\r\n  /* Parsing\r\n  /**********************************************************\r\n   */\r\n/**\r\n * Parse a date from ISO-8601 formatted string. It expects a format\r\n * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:mm]]]\r\n *\r\n * @param date ISO string to parse in the appropriate format.\r\n * @param pos The position to start parsing from, updated to where parsing stopped.\r\n * @return the parsed date\r\n * @throws ParseException if the date is not in the appropriate format\r\n */\r\npublic static Date parse(String date, ParsePosition pos) throws ParseException {\r\n    Exception fail = null;\r\n    try {\r\n        int offset = pos.getIndex();\r\n        // extract year\r\n        int year = parseInt(date, offset, offset += 4);\r\n        if (checkOffset(date, offset, '-')) {\r\n            offset += 1;\r\n        }\r\n        // extract month\r\n        int month = parseInt(date, offset, offset += 2);\r\n        if (checkOffset(date, offset, '-')) {\r\n            offset += 1;\r\n        }\r\n        // extract day\r\n        int day = parseInt(date, offset, offset += 2);\r\n        // default time value\r\n        int hour = 0;\r\n        int minutes = 0;\r\n        int seconds = 0;\r\n        // always use 0 otherwise returned date will include millis of current time\r\n        int milliseconds = 0;\r\n        // if the value has no time component (and no time zone), we are done\r\n        boolean hasT = checkOffset(date, offset, 'T');\r\n        if (!hasT && (date.length() <= offset)) {\r\n            Calendar calendar = new GregorianCalendar(year, month - 1, day);\r\n            calendar.setLenient(false);\r\n            pos.setIndex(offset);\r\n            return calendar.getTime();\r\n        }\r\n        if (hasT) {\r\n            // extract hours, minutes, seconds and milliseconds\r\n            hour = parseInt(date, offset += 1, offset += 2);\r\n            if (checkOffset(date, offset, ':')) {\r\n                offset += 1;\r\n            }\r\n            minutes = parseInt(date, offset, offset += 2);\r\n            if (checkOffset(date, offset, ':')) {\r\n                offset += 1;\r\n            }\r\n            // second and milliseconds can be optional\r\n            if (date.length() > offset) {\r\n                char c = date.charAt(offset);\r\n                if (c != 'Z' && c != '+' && c != '-') {\r\n                    seconds = parseInt(date, offset, offset += 2);\r\n                    if (seconds > 59 && seconds < 63) {\r\n                        // truncate up to 3 leap seconds\r\n                        seconds = 59;\r\n                    }\r\n                    // milliseconds can be optional in the format\r\n                    if (checkOffset(date, offset, '.')) {\r\n                        offset += 1;\r\n                        // assume at least one digit\r\n                        int endOffset = indexOfNonDigit(date, offset + 1);\r\n                        // parse up to 3 digits\r\n                        int parseEndOffset = Math.min(endOffset, offset + 3);\r\n                        int fraction = parseInt(date, offset, parseEndOffset);\r\n                        // compensate for \"missing\" digits\r\n                        switch(// number of digits parsed\r\n                        parseEndOffset - offset) {\r\n                            case 2:\r\n                                milliseconds = fraction * 10;\r\n                                break;\r\n                            case 1:\r\n                                milliseconds = fraction * 100;\r\n                                break;\r\n                            default:\r\n                                milliseconds = fraction;\r\n                        }\r\n                        offset = endOffset;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // extract timezone\r\n        if (date.length() <= offset) {\r\n            throw new IllegalArgumentException(\"No time zone indicator\");\r\n        }\r\n        TimeZone timezone = null;\r\n        char timezoneIndicator = date.charAt(offset);\r\n        if (timezoneIndicator == 'Z') {\r\n            timezone = TIMEZONE_UTC;\r\n            offset += 1;\r\n        } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\r\n            String timezoneOffset = date.substring(offset);\r\n            // When timezone has no minutes, we should append it, valid timezones are, for example:\r\n            // +00:00, +0000 and +00\r\n            timezoneOffset = timezoneOffset.length() >= 5 ? timezoneOffset : timezoneOffset + \"00\";\r\n            offset += timezoneOffset.length();\r\n            // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\r\n            if (timezoneOffset.equals(\"+0000\") || timezoneOffset.equals(\"+00:00\")) {\r\n                timezone = TIMEZONE_UTC;\r\n            } else {\r\n                // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\r\n                //    not sure why, but that's the way it looks. Further, Javadocs for\r\n                //    `java.util.TimeZone` specifically instruct use of GMT as base for\r\n                //    custom timezones... odd.\r\n                String timezoneId = \"GMT\" + timezoneOffset;\r\n                // String timezoneId = \"UTC\" + timezoneOffset;\r\n                timezone = TimeZone.getTimeZone(timezoneId);\r\n                String act = timezone.getID();\r\n                if (!act.equals(timezoneId)) {\r\n                    /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given\r\n             *    one without. If so, don't sweat.\r\n             *   Yes, very inefficient. Hopefully not hit often.\r\n             *   If it becomes a perf problem, add 'loose' comparison instead.\r\n             */\r\n                    String cleaned = act.replace(\":\", \"\");\r\n                    if (!cleaned.equals(timezoneId)) {\r\n                        throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \" + timezoneId + \" given, resolves to \" + timezone.getID());\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\");\r\n        }\r\n        Calendar calendar = new GregorianCalendar(timezone);\r\n        calendar.setLenient(false);\r\n        calendar.set(Calendar.YEAR, year);\r\n        calendar.set(Calendar.MONTH, month - 1);\r\n        calendar.set(Calendar.DAY_OF_MONTH, day);\r\n        calendar.set(Calendar.HOUR_OF_DAY, hour);\r\n        calendar.set(Calendar.MINUTE, minutes);\r\n        calendar.set(Calendar.SECOND, seconds);\r\n        calendar.set(Calendar.MILLISECOND, milliseconds);\r\n        pos.setIndex(offset);\r\n        return calendar.getTime();\r\n        // If we get a ParseException it'll already have the right message/offset.\r\n        // Other exception types can convert here.\r\n    } catch (IndexOutOfBoundsException | IllegalArgumentException e) {\r\n        fail = e;\r\n    }\r\n    String input = (date == null) ? null : ('\"' + date + '\"');\r\n    String msg = fail.getMessage();\r\n    if (msg == null || msg.isEmpty()) {\r\n        msg = \"(\" + fail.getClass().getName() + \")\";\r\n    }\r\n    ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\r\n    ex.initCause(fail);\r\n    throw ex;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\util\\ISO8601Utils.java"
  },
  {
    "type": "method",
    "name": "checkOffset",
    "start_line": 319,
    "end_line": 321,
    "code": "/**\r\n * Check if the expected character exist at the given offset in the value.\r\n *\r\n * @param value the string to check at the specified offset\r\n * @param offset the offset to look for the expected character\r\n * @param expected the expected character\r\n * @return true if the expected character exist at the given offset\r\n */\r\nprivate static boolean checkOffset(String value, int offset, char expected) {\r\n    return (offset < value.length()) && (value.charAt(offset) == expected);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\util\\ISO8601Utils.java"
  },
  {
    "type": "method",
    "name": "parseInt",
    "start_line": 332,
    "end_line": 357,
    "code": "/**\r\n * Parse an integer located between 2 given offsets in a string\r\n *\r\n * @param value the string to parse\r\n * @param beginIndex the start index for the integer in the string\r\n * @param endIndex the end index for the integer in the string\r\n * @return the int\r\n * @throws NumberFormatException if the value is not a number\r\n */\r\nprivate static int parseInt(String value, int beginIndex, int endIndex) throws NumberFormatException {\r\n    if (beginIndex < 0 || endIndex > value.length() || beginIndex > endIndex) {\r\n        throw new NumberFormatException(value);\r\n    }\r\n    // use same logic as in Integer.parseInt() but less generic we're not supporting negative values\r\n    int i = beginIndex;\r\n    int result = 0;\r\n    int digit;\r\n    if (i < endIndex) {\r\n        digit = Character.digit(value.charAt(i++), 10);\r\n        if (digit < 0) {\r\n            throw new NumberFormatException(\"Invalid number: \" + value.substring(beginIndex, endIndex));\r\n        }\r\n        result = -digit;\r\n    }\r\n    while (i < endIndex) {\r\n        digit = Character.digit(value.charAt(i++), 10);\r\n        if (digit < 0) {\r\n            throw new NumberFormatException(\"Invalid number: \" + value.substring(beginIndex, endIndex));\r\n        }\r\n        result *= 10;\r\n        result -= digit;\r\n    }\r\n    return -result;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\util\\ISO8601Utils.java"
  },
  {
    "type": "method",
    "name": "padInt",
    "start_line": 366,
    "end_line": 372,
    "code": "/**\r\n * Zero pad a number to a specified length\r\n *\r\n * @param buffer buffer to use for padding\r\n * @param value the integer value to pad if necessary.\r\n * @param length the length of the string we should zero pad\r\n */\r\nprivate static void padInt(StringBuilder buffer, int value, int length) {\r\n    String strValue = Integer.toString(value);\r\n    for (int i = length - strValue.length(); i > 0; i--) {\r\n        buffer.append('0');\r\n    }\r\n    buffer.append(strValue);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\util\\ISO8601Utils.java"
  },
  {
    "type": "method",
    "name": "indexOfNonDigit",
    "start_line": 377,
    "end_line": 385,
    "code": "/**\r\n * Returns the index of the first character in the string that is not a digit, starting at offset.\r\n */\r\nprivate static int indexOfNonDigit(String string, int offset) {\r\n    for (int i = offset; i < string.length(); i++) {\r\n        char c = string.charAt(i);\r\n        if (c < '0' || c > '9') {\r\n            return i;\r\n        }\r\n    }\r\n    return string.length();\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\util\\ISO8601Utils.java"
  }
]