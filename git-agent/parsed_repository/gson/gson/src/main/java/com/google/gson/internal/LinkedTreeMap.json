[
  {
    "type": "package",
    "name": "com.google.gson.internal",
    "start_line": 18,
    "end_line": 18,
    "code": "package com.google.gson.internal;\r\n\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "import",
    "name": "com.google.errorprone.annotations.CanIgnoreReturnValue",
    "start_line": 20,
    "end_line": 20,
    "code": "import com.google.errorprone.annotations.CanIgnoreReturnValue;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "import",
    "name": "java.io.IOException",
    "start_line": 21,
    "end_line": 21,
    "code": "import java.io.IOException;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "import",
    "name": "java.io.InvalidObjectException",
    "start_line": 22,
    "end_line": 22,
    "code": "import java.io.InvalidObjectException;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "import",
    "name": "java.io.ObjectInputStream",
    "start_line": 23,
    "end_line": 23,
    "code": "import java.io.ObjectInputStream;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "import",
    "name": "java.io.ObjectStreamException",
    "start_line": 24,
    "end_line": 24,
    "code": "import java.io.ObjectStreamException;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "import",
    "name": "java.io.Serializable",
    "start_line": 25,
    "end_line": 25,
    "code": "import java.io.Serializable;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "import",
    "name": "java.util.AbstractMap",
    "start_line": 26,
    "end_line": 26,
    "code": "import java.util.AbstractMap;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "import",
    "name": "java.util.AbstractSet",
    "start_line": 27,
    "end_line": 27,
    "code": "import java.util.AbstractSet;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "import",
    "name": "java.util.Comparator",
    "start_line": 28,
    "end_line": 28,
    "code": "import java.util.Comparator;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "import",
    "name": "java.util.ConcurrentModificationException",
    "start_line": 29,
    "end_line": 29,
    "code": "import java.util.ConcurrentModificationException;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "import",
    "name": "java.util.Iterator",
    "start_line": 30,
    "end_line": 30,
    "code": "import java.util.Iterator;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "import",
    "name": "java.util.LinkedHashMap",
    "start_line": 31,
    "end_line": 31,
    "code": "import java.util.LinkedHashMap;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "import",
    "name": "java.util.NoSuchElementException",
    "start_line": 32,
    "end_line": 32,
    "code": "import java.util.NoSuchElementException;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "import",
    "name": "java.util.Objects",
    "start_line": 33,
    "end_line": 33,
    "code": "import java.util.Objects;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "import",
    "name": "java.util.Set",
    "start_line": 34,
    "end_line": 34,
    "code": "import java.util.Set;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "class",
    "name": "LinkedTreeMap",
    "start_line": 43,
    "end_line": 687,
    "code": "/**\r\n * A map of comparable keys to values. Unlike {@code TreeMap}, this class uses insertion order for\r\n * iteration order. Comparison order is only used as an optimization for efficient insertion and\r\n * removal.\r\n *\r\n * <p>This implementation was derived from Android 4.1's TreeMap class.\r\n */\r\n// ignore warning about missing serialVersionUID\r\n@SuppressWarnings(\"serial\")\r\npublic final class LinkedTreeMap<K, V> extends AbstractMap<K, V> implements Serializable {\r\n\r\n    // to avoid Comparable<Comparable<Comparable<...>>>\r\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n    private static final Comparator<Comparable> NATURAL_ORDER = new Comparator<Comparable>() {\r\n\r\n        @Override\r\n        public int compare(Comparable a, Comparable b) {\r\n            return a.compareTo(b);\r\n        }\r\n    };\r\n\r\n    private final Comparator<? super K> comparator;\r\n\r\n    private final boolean allowNullValues;\r\n\r\n    Node<K, V> root;\r\n\r\n    int size = 0;\r\n\r\n    int modCount = 0;\r\n\r\n    // Used to preserve iteration order\r\n    final Node<K, V> header;\r\n\r\n    /**\r\n     * Create a natural order, empty tree map whose keys must be mutually comparable and non-null, and\r\n     * whose values can be {@code null}.\r\n     */\r\n    // unsafe! this assumes K is comparable\r\n    @SuppressWarnings(\"unchecked\")\r\n    public LinkedTreeMap() {\r\n        this((Comparator<? super K>) NATURAL_ORDER, true);\r\n    }\r\n\r\n    /**\r\n     * Create a natural order, empty tree map whose keys must be mutually comparable and non-null.\r\n     *\r\n     * @param allowNullValues whether {@code null} is allowed as entry value\r\n     */\r\n    // unsafe! this assumes K is comparable\r\n    @SuppressWarnings(\"unchecked\")\r\n    public LinkedTreeMap(boolean allowNullValues) {\r\n        this((Comparator<? super K>) NATURAL_ORDER, allowNullValues);\r\n    }\r\n\r\n    /**\r\n     * Create a tree map ordered by {@code comparator}. This map's keys may only be null if {@code\r\n     * comparator} permits.\r\n     *\r\n     * @param comparator the comparator to order elements with, or {@code null} to use the natural\r\n     *     ordering.\r\n     * @param allowNullValues whether {@code null} is allowed as entry value\r\n     */\r\n    // unsafe! if comparator is null, this assumes K is comparable\r\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n    public LinkedTreeMap(Comparator<? super K> comparator, boolean allowNullValues) {\r\n        this.comparator = comparator != null ? comparator : (Comparator) NATURAL_ORDER;\r\n        this.allowNullValues = allowNullValues;\r\n        this.header = new Node<>(allowNullValues);\r\n    }\r\n\r\n    @Override\r\n    public int size() {\r\n        return size;\r\n    }\r\n\r\n    @Override\r\n    public V get(Object key) {\r\n        Node<K, V> node = findByObject(key);\r\n        return node != null ? node.value : null;\r\n    }\r\n\r\n    @Override\r\n    public boolean containsKey(Object key) {\r\n        return findByObject(key) != null;\r\n    }\r\n\r\n    @CanIgnoreReturnValue\r\n    @Override\r\n    public V put(K key, V value) {\r\n        if (key == null) {\r\n            throw new NullPointerException(\"key == null\");\r\n        }\r\n        if (value == null && !allowNullValues) {\r\n            throw new NullPointerException(\"value == null\");\r\n        }\r\n        Node<K, V> created = find(key, true);\r\n        V result = created.value;\r\n        created.value = value;\r\n        return result;\r\n    }\r\n\r\n    @Override\r\n    public void clear() {\r\n        root = null;\r\n        size = 0;\r\n        modCount++;\r\n        // Clear iteration order\r\n        Node<K, V> header = this.header;\r\n        header.next = header.prev = header;\r\n    }\r\n\r\n    @Override\r\n    public V remove(Object key) {\r\n        Node<K, V> node = removeInternalByKey(key);\r\n        return node != null ? node.value : null;\r\n    }\r\n\r\n    /**\r\n     * Returns the node at or adjacent to the given key, creating it if requested.\r\n     *\r\n     * @throws ClassCastException if {@code key} and the tree's keys aren't mutually comparable.\r\n     */\r\n    Node<K, V> find(K key, boolean create) {\r\n        Comparator<? super K> comparator = this.comparator;\r\n        Node<K, V> nearest = root;\r\n        int comparison = 0;\r\n        if (nearest != null) {\r\n            // Micro-optimization: avoid polymorphic calls to Comparator.compare().\r\n            // Throws a ClassCastException below if there's trouble.\r\n            @SuppressWarnings(\"unchecked\")\r\n            Comparable<Object> comparableKey = (comparator == NATURAL_ORDER) ? (Comparable<Object>) key : null;\r\n            while (true) {\r\n                comparison = (comparableKey != null) ? comparableKey.compareTo(nearest.key) : comparator.compare(key, nearest.key);\r\n                // We found the requested key.\r\n                if (comparison == 0) {\r\n                    return nearest;\r\n                }\r\n                // If it exists, the key is in a subtree. Go deeper.\r\n                Node<K, V> child = (comparison < 0) ? nearest.left : nearest.right;\r\n                if (child == null) {\r\n                    break;\r\n                }\r\n                nearest = child;\r\n            }\r\n        }\r\n        // The key doesn't exist in this tree.\r\n        if (!create) {\r\n            return null;\r\n        }\r\n        // Create the node and add it to the tree or the table.\r\n        Node<K, V> header = this.header;\r\n        Node<K, V> created;\r\n        if (nearest == null) {\r\n            // Check that the value is comparable if we didn't do any comparisons.\r\n            if (comparator == NATURAL_ORDER && !(key instanceof Comparable)) {\r\n                throw new ClassCastException(key.getClass().getName() + \" is not Comparable\");\r\n            }\r\n            created = new Node<>(allowNullValues, nearest, key, header, header.prev);\r\n            root = created;\r\n        } else {\r\n            created = new Node<>(allowNullValues, nearest, key, header, header.prev);\r\n            if (comparison < 0) {\r\n                // nearest.key is higher\r\n                nearest.left = created;\r\n            } else {\r\n                // comparison > 0, nearest.key is lower\r\n                nearest.right = created;\r\n            }\r\n            rebalance(nearest, true);\r\n        }\r\n        size++;\r\n        modCount++;\r\n        return created;\r\n    }\r\n\r\n    @SuppressWarnings(\"unchecked\")\r\n    Node<K, V> findByObject(Object key) {\r\n        try {\r\n            return key != null ? find((K) key, false) : null;\r\n        } catch (ClassCastException e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns this map's entry that has the same key and value as {@code entry}, or null if this map\r\n     * has no such entry.\r\n     *\r\n     * <p>This method uses the comparator for key equality rather than {@code equals}. If this map's\r\n     * comparator isn't consistent with equals (such as {@code String.CASE_INSENSITIVE_ORDER}), then\r\n     * {@code remove()} and {@code contains()} will violate the collections API.\r\n     */\r\n    Node<K, V> findByEntry(Entry<?, ?> entry) {\r\n        Node<K, V> mine = findByObject(entry.getKey());\r\n        boolean valuesEqual = mine != null && equal(mine.value, entry.getValue());\r\n        return valuesEqual ? mine : null;\r\n    }\r\n\r\n    private static boolean equal(Object a, Object b) {\r\n        return Objects.equals(a, b);\r\n    }\r\n\r\n    /**\r\n     * Removes {@code node} from this tree, rearranging the tree's structure as necessary.\r\n     *\r\n     * @param unlink true to also unlink this node from the iteration linked list.\r\n     */\r\n    void removeInternal(Node<K, V> node, boolean unlink) {\r\n        if (unlink) {\r\n            node.prev.next = node.next;\r\n            node.next.prev = node.prev;\r\n        }\r\n        Node<K, V> left = node.left;\r\n        Node<K, V> right = node.right;\r\n        Node<K, V> originalParent = node.parent;\r\n        if (left != null && right != null) {\r\n            /*\r\n       * To remove a node with both left and right subtrees, move an\r\n       * adjacent node from one of those subtrees into this node's place.\r\n       *\r\n       * Removing the adjacent node may change this node's subtrees. This\r\n       * node may no longer have two subtrees once the adjacent node is\r\n       * gone!\r\n       */\r\n            Node<K, V> adjacent = (left.height > right.height) ? left.last() : right.first();\r\n            // takes care of rebalance and size--\r\n            removeInternal(adjacent, false);\r\n            int leftHeight = 0;\r\n            left = node.left;\r\n            if (left != null) {\r\n                leftHeight = left.height;\r\n                adjacent.left = left;\r\n                left.parent = adjacent;\r\n                node.left = null;\r\n            }\r\n            int rightHeight = 0;\r\n            right = node.right;\r\n            if (right != null) {\r\n                rightHeight = right.height;\r\n                adjacent.right = right;\r\n                right.parent = adjacent;\r\n                node.right = null;\r\n            }\r\n            adjacent.height = Math.max(leftHeight, rightHeight) + 1;\r\n            replaceInParent(node, adjacent);\r\n            return;\r\n        } else if (left != null) {\r\n            replaceInParent(node, left);\r\n            node.left = null;\r\n        } else if (right != null) {\r\n            replaceInParent(node, right);\r\n            node.right = null;\r\n        } else {\r\n            replaceInParent(node, null);\r\n        }\r\n        rebalance(originalParent, false);\r\n        size--;\r\n        modCount++;\r\n    }\r\n\r\n    Node<K, V> removeInternalByKey(Object key) {\r\n        Node<K, V> node = findByObject(key);\r\n        if (node != null) {\r\n            removeInternal(node, true);\r\n        }\r\n        return node;\r\n    }\r\n\r\n    @SuppressWarnings(\"ReferenceEquality\")\r\n    private void replaceInParent(Node<K, V> node, Node<K, V> replacement) {\r\n        Node<K, V> parent = node.parent;\r\n        node.parent = null;\r\n        if (replacement != null) {\r\n            replacement.parent = parent;\r\n        }\r\n        if (parent != null) {\r\n            if (parent.left == node) {\r\n                parent.left = replacement;\r\n            } else {\r\n                assert parent.right == node;\r\n                parent.right = replacement;\r\n            }\r\n        } else {\r\n            root = replacement;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rebalances the tree by making any AVL rotations necessary between the newly-unbalanced node and\r\n     * the tree's root.\r\n     *\r\n     * @param insert true if the node was unbalanced by an insert; false if it was by a removal.\r\n     */\r\n    private void rebalance(Node<K, V> unbalanced, boolean insert) {\r\n        for (Node<K, V> node = unbalanced; node != null; node = node.parent) {\r\n            Node<K, V> left = node.left;\r\n            Node<K, V> right = node.right;\r\n            int leftHeight = left != null ? left.height : 0;\r\n            int rightHeight = right != null ? right.height : 0;\r\n            int delta = leftHeight - rightHeight;\r\n            if (delta == -2) {\r\n                Node<K, V> rightLeft = right.left;\r\n                Node<K, V> rightRight = right.right;\r\n                int rightRightHeight = rightRight != null ? rightRight.height : 0;\r\n                int rightLeftHeight = rightLeft != null ? rightLeft.height : 0;\r\n                int rightDelta = rightLeftHeight - rightRightHeight;\r\n                if (rightDelta == -1 || (rightDelta == 0 && !insert)) {\r\n                    // AVL right right\r\n                    rotateLeft(node);\r\n                } else {\r\n                    assert (rightDelta == 1);\r\n                    // AVL right left\r\n                    rotateRight(right);\r\n                    rotateLeft(node);\r\n                }\r\n                if (insert) {\r\n                    // no further rotations will be necessary\r\n                    break;\r\n                }\r\n            } else if (delta == 2) {\r\n                Node<K, V> leftLeft = left.left;\r\n                Node<K, V> leftRight = left.right;\r\n                int leftRightHeight = leftRight != null ? leftRight.height : 0;\r\n                int leftLeftHeight = leftLeft != null ? leftLeft.height : 0;\r\n                int leftDelta = leftLeftHeight - leftRightHeight;\r\n                if (leftDelta == 1 || (leftDelta == 0 && !insert)) {\r\n                    // AVL left left\r\n                    rotateRight(node);\r\n                } else {\r\n                    assert (leftDelta == -1);\r\n                    // AVL left right\r\n                    rotateLeft(left);\r\n                    rotateRight(node);\r\n                }\r\n                if (insert) {\r\n                    // no further rotations will be necessary\r\n                    break;\r\n                }\r\n            } else if (delta == 0) {\r\n                // leftHeight == rightHeight\r\n                node.height = leftHeight + 1;\r\n                if (insert) {\r\n                    // the insert caused balance, so rebalancing is done!\r\n                    break;\r\n                }\r\n            } else {\r\n                assert (delta == -1 || delta == 1);\r\n                node.height = Math.max(leftHeight, rightHeight) + 1;\r\n                if (!insert) {\r\n                    // the height hasn't changed, so rebalancing is done!\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rotates the subtree so that its root's right child is the new root.\r\n     */\r\n    private void rotateLeft(Node<K, V> root) {\r\n        Node<K, V> left = root.left;\r\n        Node<K, V> pivot = root.right;\r\n        Node<K, V> pivotLeft = pivot.left;\r\n        Node<K, V> pivotRight = pivot.right;\r\n        // move the pivot's left child to the root's right\r\n        root.right = pivotLeft;\r\n        if (pivotLeft != null) {\r\n            pivotLeft.parent = root;\r\n        }\r\n        replaceInParent(root, pivot);\r\n        // move the root to the pivot's left\r\n        pivot.left = root;\r\n        root.parent = pivot;\r\n        // fix heights\r\n        root.height = Math.max(left != null ? left.height : 0, pivotLeft != null ? pivotLeft.height : 0) + 1;\r\n        pivot.height = Math.max(root.height, pivotRight != null ? pivotRight.height : 0) + 1;\r\n    }\r\n\r\n    /**\r\n     * Rotates the subtree so that its root's left child is the new root.\r\n     */\r\n    private void rotateRight(Node<K, V> root) {\r\n        Node<K, V> pivot = root.left;\r\n        Node<K, V> right = root.right;\r\n        Node<K, V> pivotLeft = pivot.left;\r\n        Node<K, V> pivotRight = pivot.right;\r\n        // move the pivot's right child to the root's left\r\n        root.left = pivotRight;\r\n        if (pivotRight != null) {\r\n            pivotRight.parent = root;\r\n        }\r\n        replaceInParent(root, pivot);\r\n        // move the root to the pivot's right\r\n        pivot.right = root;\r\n        root.parent = pivot;\r\n        // fixup heights\r\n        root.height = Math.max(right != null ? right.height : 0, pivotRight != null ? pivotRight.height : 0) + 1;\r\n        pivot.height = Math.max(root.height, pivotLeft != null ? pivotLeft.height : 0) + 1;\r\n    }\r\n\r\n    private EntrySet entrySet;\r\n\r\n    private KeySet keySet;\r\n\r\n    @Override\r\n    public Set<Entry<K, V>> entrySet() {\r\n        EntrySet result = entrySet;\r\n        if (result == null) {\r\n            result = entrySet = new EntrySet();\r\n        }\r\n        return result;\r\n    }\r\n\r\n    @Override\r\n    public Set<K> keySet() {\r\n        KeySet result = keySet;\r\n        if (result == null) {\r\n            result = keySet = new KeySet();\r\n        }\r\n        return result;\r\n    }\r\n\r\n    static final class Node<K, V> implements Entry<K, V> {\r\n\r\n        Node<K, V> parent;\r\n\r\n        Node<K, V> left;\r\n\r\n        Node<K, V> right;\r\n\r\n        Node<K, V> next;\r\n\r\n        Node<K, V> prev;\r\n\r\n        final K key;\r\n\r\n        final boolean allowNullValue;\r\n\r\n        V value;\r\n\r\n        int height;\r\n\r\n        /**\r\n         * Create the header entry\r\n         */\r\n        Node(boolean allowNullValue) {\r\n            key = null;\r\n            this.allowNullValue = allowNullValue;\r\n            next = prev = this;\r\n        }\r\n\r\n        /**\r\n         * Create a regular entry\r\n         */\r\n        Node(boolean allowNullValue, Node<K, V> parent, K key, Node<K, V> next, Node<K, V> prev) {\r\n            this.parent = parent;\r\n            this.key = key;\r\n            this.allowNullValue = allowNullValue;\r\n            this.height = 1;\r\n            this.next = next;\r\n            this.prev = prev;\r\n            prev.next = this;\r\n            next.prev = this;\r\n        }\r\n\r\n        @Override\r\n        public K getKey() {\r\n            return key;\r\n        }\r\n\r\n        @Override\r\n        public V getValue() {\r\n            return value;\r\n        }\r\n\r\n        @Override\r\n        public V setValue(V value) {\r\n            if (value == null && !allowNullValue) {\r\n                throw new NullPointerException(\"value == null\");\r\n            }\r\n            V oldValue = this.value;\r\n            this.value = value;\r\n            return oldValue;\r\n        }\r\n\r\n        @Override\r\n        public boolean equals(Object o) {\r\n            if (o instanceof Entry) {\r\n                Entry<?, ?> other = (Entry<?, ?>) o;\r\n                return (key == null ? other.getKey() == null : key.equals(other.getKey())) && (value == null ? other.getValue() == null : value.equals(other.getValue()));\r\n            }\r\n            return false;\r\n        }\r\n\r\n        @Override\r\n        public int hashCode() {\r\n            return (key == null ? 0 : key.hashCode()) ^ (value == null ? 0 : value.hashCode());\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return key + \"=\" + value;\r\n        }\r\n\r\n        /**\r\n         * Returns the first node in this subtree.\r\n         */\r\n        public Node<K, V> first() {\r\n            Node<K, V> node = this;\r\n            Node<K, V> child = node.left;\r\n            while (child != null) {\r\n                node = child;\r\n                child = node.left;\r\n            }\r\n            return node;\r\n        }\r\n\r\n        /**\r\n         * Returns the last node in this subtree.\r\n         */\r\n        public Node<K, V> last() {\r\n            Node<K, V> node = this;\r\n            Node<K, V> child = node.right;\r\n            while (child != null) {\r\n                node = child;\r\n                child = node.right;\r\n            }\r\n            return node;\r\n        }\r\n    }\r\n\r\n    private abstract class LinkedTreeMapIterator<T> implements Iterator<T> {\r\n\r\n        Node<K, V> next = header.next;\r\n\r\n        Node<K, V> lastReturned = null;\r\n\r\n        int expectedModCount = modCount;\r\n\r\n        LinkedTreeMapIterator() {\r\n        }\r\n\r\n        @Override\r\n        @SuppressWarnings(\"ReferenceEquality\")\r\n        public final boolean hasNext() {\r\n            return next != header;\r\n        }\r\n\r\n        @SuppressWarnings(\"ReferenceEquality\")\r\n        final Node<K, V> nextNode() {\r\n            Node<K, V> e = next;\r\n            if (e == header) {\r\n                throw new NoSuchElementException();\r\n            }\r\n            if (modCount != expectedModCount) {\r\n                throw new ConcurrentModificationException();\r\n            }\r\n            next = e.next;\r\n            lastReturned = e;\r\n            return e;\r\n        }\r\n\r\n        @Override\r\n        public final void remove() {\r\n            if (lastReturned == null) {\r\n                throw new IllegalStateException();\r\n            }\r\n            removeInternal(lastReturned, true);\r\n            lastReturned = null;\r\n            expectedModCount = modCount;\r\n        }\r\n    }\r\n\r\n    class EntrySet extends AbstractSet<Entry<K, V>> {\r\n\r\n        @Override\r\n        public int size() {\r\n            return size;\r\n        }\r\n\r\n        @Override\r\n        public Iterator<Entry<K, V>> iterator() {\r\n            return new LinkedTreeMapIterator<Entry<K, V>>() {\r\n\r\n                @Override\r\n                public Entry<K, V> next() {\r\n                    return nextNode();\r\n                }\r\n            };\r\n        }\r\n\r\n        @Override\r\n        public boolean contains(Object o) {\r\n            return o instanceof Entry && findByEntry((Entry<?, ?>) o) != null;\r\n        }\r\n\r\n        @Override\r\n        public boolean remove(Object o) {\r\n            if (!(o instanceof Entry)) {\r\n                return false;\r\n            }\r\n            Node<K, V> node = findByEntry((Entry<?, ?>) o);\r\n            if (node == null) {\r\n                return false;\r\n            }\r\n            removeInternal(node, true);\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public void clear() {\r\n            LinkedTreeMap.this.clear();\r\n        }\r\n    }\r\n\r\n    final class KeySet extends AbstractSet<K> {\r\n\r\n        @Override\r\n        public int size() {\r\n            return size;\r\n        }\r\n\r\n        @Override\r\n        public Iterator<K> iterator() {\r\n            return new LinkedTreeMapIterator<K>() {\r\n\r\n                @Override\r\n                public K next() {\r\n                    return nextNode().key;\r\n                }\r\n            };\r\n        }\r\n\r\n        @Override\r\n        public boolean contains(Object o) {\r\n            return containsKey(o);\r\n        }\r\n\r\n        @Override\r\n        public boolean remove(Object key) {\r\n            return removeInternalByKey(key) != null;\r\n        }\r\n\r\n        @Override\r\n        public void clear() {\r\n            LinkedTreeMap.this.clear();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * If somebody is unlucky enough to have to serialize one of these, serialize it as a\r\n     * LinkedHashMap so that they won't need Gson on the other side to deserialize it. Using\r\n     * serialization defeats our DoS defence, so most apps shouldn't use it.\r\n     */\r\n    private Object writeReplace() throws ObjectStreamException {\r\n        return new LinkedHashMap<>(this);\r\n    }\r\n\r\n    private void readObject(ObjectInputStream in) throws IOException {\r\n        // Don't permit directly deserializing this class; writeReplace() should have written a\r\n        // replacement\r\n        throw new InvalidObjectException(\"Deserialization is unsupported\");\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "field",
    "name": "NATURAL_ORDER",
    "start_line": 45,
    "end_line": 52,
    "code": "// to avoid Comparable<Comparable<Comparable<...>>>\r\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\nprivate static final Comparator<Comparable> NATURAL_ORDER = new Comparator<Comparable>() {\r\n\r\n    @Override\r\n    public int compare(Comparable a, Comparable b) {\r\n        return a.compareTo(b);\r\n    }\r\n};",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "field",
    "name": "comparator",
    "start_line": 54,
    "end_line": 54,
    "code": "private final Comparator<? super K> comparator;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "field",
    "name": "allowNullValues",
    "start_line": 55,
    "end_line": 55,
    "code": "private final boolean allowNullValues;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "field",
    "name": "root",
    "start_line": 56,
    "end_line": 56,
    "code": "Node<K, V> root;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "field",
    "name": "size",
    "start_line": 57,
    "end_line": 57,
    "code": "int size = 0;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "field",
    "name": "modCount",
    "start_line": 58,
    "end_line": 58,
    "code": "int modCount = 0;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "field",
    "name": "header",
    "start_line": 61,
    "end_line": 61,
    "code": "// Used to preserve iteration order\r\nfinal Node<K, V> header;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "field",
    "name": "entrySet",
    "start_line": 448,
    "end_line": 448,
    "code": "private EntrySet entrySet;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "field",
    "name": "keySet",
    "start_line": 449,
    "end_line": 449,
    "code": "private KeySet keySet;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "constructor",
    "name": "LinkedTreeMap",
    "start_line": 67,
    "end_line": 70,
    "code": "/**\r\n * Create a natural order, empty tree map whose keys must be mutually comparable and non-null, and\r\n * whose values can be {@code null}.\r\n */\r\n// unsafe! this assumes K is comparable\r\n@SuppressWarnings(\"unchecked\")\r\npublic LinkedTreeMap() {\r\n    this((Comparator<? super K>) NATURAL_ORDER, true);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "constructor",
    "name": "LinkedTreeMap",
    "start_line": 77,
    "end_line": 80,
    "code": "/**\r\n * Create a natural order, empty tree map whose keys must be mutually comparable and non-null.\r\n *\r\n * @param allowNullValues whether {@code null} is allowed as entry value\r\n */\r\n// unsafe! this assumes K is comparable\r\n@SuppressWarnings(\"unchecked\")\r\npublic LinkedTreeMap(boolean allowNullValues) {\r\n    this((Comparator<? super K>) NATURAL_ORDER, allowNullValues);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "constructor",
    "name": "LinkedTreeMap",
    "start_line": 91,
    "end_line": 96,
    "code": "/**\r\n * Create a tree map ordered by {@code comparator}. This map's keys may only be null if {@code\r\n * comparator} permits.\r\n *\r\n * @param comparator the comparator to order elements with, or {@code null} to use the natural\r\n *     ordering.\r\n * @param allowNullValues whether {@code null} is allowed as entry value\r\n */\r\n// unsafe! if comparator is null, this assumes K is comparable\r\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\npublic LinkedTreeMap(Comparator<? super K> comparator, boolean allowNullValues) {\r\n    this.comparator = comparator != null ? comparator : (Comparator) NATURAL_ORDER;\r\n    this.allowNullValues = allowNullValues;\r\n    this.header = new Node<>(allowNullValues);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "method",
    "name": "size",
    "start_line": 98,
    "end_line": 101,
    "code": "@Override\r\npublic int size() {\r\n    return size;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "method",
    "name": "get",
    "start_line": 103,
    "end_line": 107,
    "code": "@Override\r\npublic V get(Object key) {\r\n    Node<K, V> node = findByObject(key);\r\n    return node != null ? node.value : null;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "method",
    "name": "containsKey",
    "start_line": 109,
    "end_line": 112,
    "code": "@Override\r\npublic boolean containsKey(Object key) {\r\n    return findByObject(key) != null;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "method",
    "name": "put",
    "start_line": 114,
    "end_line": 127,
    "code": "@CanIgnoreReturnValue\r\n@Override\r\npublic V put(K key, V value) {\r\n    if (key == null) {\r\n        throw new NullPointerException(\"key == null\");\r\n    }\r\n    if (value == null && !allowNullValues) {\r\n        throw new NullPointerException(\"value == null\");\r\n    }\r\n    Node<K, V> created = find(key, true);\r\n    V result = created.value;\r\n    created.value = value;\r\n    return result;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "method",
    "name": "clear",
    "start_line": 129,
    "end_line": 138,
    "code": "@Override\r\npublic void clear() {\r\n    root = null;\r\n    size = 0;\r\n    modCount++;\r\n    // Clear iteration order\r\n    Node<K, V> header = this.header;\r\n    header.next = header.prev = header;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "method",
    "name": "remove",
    "start_line": 140,
    "end_line": 144,
    "code": "@Override\r\npublic V remove(Object key) {\r\n    Node<K, V> node = removeInternalByKey(key);\r\n    return node != null ? node.value : null;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "method",
    "name": "find",
    "start_line": 151,
    "end_line": 211,
    "code": "/**\r\n * Returns the node at or adjacent to the given key, creating it if requested.\r\n *\r\n * @throws ClassCastException if {@code key} and the tree's keys aren't mutually comparable.\r\n */\r\nNode<K, V> find(K key, boolean create) {\r\n    Comparator<? super K> comparator = this.comparator;\r\n    Node<K, V> nearest = root;\r\n    int comparison = 0;\r\n    if (nearest != null) {\r\n        // Micro-optimization: avoid polymorphic calls to Comparator.compare().\r\n        // Throws a ClassCastException below if there's trouble.\r\n        @SuppressWarnings(\"unchecked\")\r\n        Comparable<Object> comparableKey = (comparator == NATURAL_ORDER) ? (Comparable<Object>) key : null;\r\n        while (true) {\r\n            comparison = (comparableKey != null) ? comparableKey.compareTo(nearest.key) : comparator.compare(key, nearest.key);\r\n            // We found the requested key.\r\n            if (comparison == 0) {\r\n                return nearest;\r\n            }\r\n            // If it exists, the key is in a subtree. Go deeper.\r\n            Node<K, V> child = (comparison < 0) ? nearest.left : nearest.right;\r\n            if (child == null) {\r\n                break;\r\n            }\r\n            nearest = child;\r\n        }\r\n    }\r\n    // The key doesn't exist in this tree.\r\n    if (!create) {\r\n        return null;\r\n    }\r\n    // Create the node and add it to the tree or the table.\r\n    Node<K, V> header = this.header;\r\n    Node<K, V> created;\r\n    if (nearest == null) {\r\n        // Check that the value is comparable if we didn't do any comparisons.\r\n        if (comparator == NATURAL_ORDER && !(key instanceof Comparable)) {\r\n            throw new ClassCastException(key.getClass().getName() + \" is not Comparable\");\r\n        }\r\n        created = new Node<>(allowNullValues, nearest, key, header, header.prev);\r\n        root = created;\r\n    } else {\r\n        created = new Node<>(allowNullValues, nearest, key, header, header.prev);\r\n        if (comparison < 0) {\r\n            // nearest.key is higher\r\n            nearest.left = created;\r\n        } else {\r\n            // comparison > 0, nearest.key is lower\r\n            nearest.right = created;\r\n        }\r\n        rebalance(nearest, true);\r\n    }\r\n    size++;\r\n    modCount++;\r\n    return created;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "method",
    "name": "findByObject",
    "start_line": 213,
    "end_line": 220,
    "code": "@SuppressWarnings(\"unchecked\")\r\nNode<K, V> findByObject(Object key) {\r\n    try {\r\n        return key != null ? find((K) key, false) : null;\r\n    } catch (ClassCastException e) {\r\n        return null;\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "method",
    "name": "findByEntry",
    "start_line": 230,
    "end_line": 234,
    "code": "/**\r\n * Returns this map's entry that has the same key and value as {@code entry}, or null if this map\r\n * has no such entry.\r\n *\r\n * <p>This method uses the comparator for key equality rather than {@code equals}. If this map's\r\n * comparator isn't consistent with equals (such as {@code String.CASE_INSENSITIVE_ORDER}), then\r\n * {@code remove()} and {@code contains()} will violate the collections API.\r\n */\r\nNode<K, V> findByEntry(Entry<?, ?> entry) {\r\n    Node<K, V> mine = findByObject(entry.getKey());\r\n    boolean valuesEqual = mine != null && equal(mine.value, entry.getValue());\r\n    return valuesEqual ? mine : null;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "method",
    "name": "equal",
    "start_line": 236,
    "end_line": 238,
    "code": "private static boolean equal(Object a, Object b) {\r\n    return Objects.equals(a, b);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "method",
    "name": "removeInternal",
    "start_line": 245,
    "end_line": 302,
    "code": "/**\r\n * Removes {@code node} from this tree, rearranging the tree's structure as necessary.\r\n *\r\n * @param unlink true to also unlink this node from the iteration linked list.\r\n */\r\nvoid removeInternal(Node<K, V> node, boolean unlink) {\r\n    if (unlink) {\r\n        node.prev.next = node.next;\r\n        node.next.prev = node.prev;\r\n    }\r\n    Node<K, V> left = node.left;\r\n    Node<K, V> right = node.right;\r\n    Node<K, V> originalParent = node.parent;\r\n    if (left != null && right != null) {\r\n        /*\r\n       * To remove a node with both left and right subtrees, move an\r\n       * adjacent node from one of those subtrees into this node's place.\r\n       *\r\n       * Removing the adjacent node may change this node's subtrees. This\r\n       * node may no longer have two subtrees once the adjacent node is\r\n       * gone!\r\n       */\r\n        Node<K, V> adjacent = (left.height > right.height) ? left.last() : right.first();\r\n        // takes care of rebalance and size--\r\n        removeInternal(adjacent, false);\r\n        int leftHeight = 0;\r\n        left = node.left;\r\n        if (left != null) {\r\n            leftHeight = left.height;\r\n            adjacent.left = left;\r\n            left.parent = adjacent;\r\n            node.left = null;\r\n        }\r\n        int rightHeight = 0;\r\n        right = node.right;\r\n        if (right != null) {\r\n            rightHeight = right.height;\r\n            adjacent.right = right;\r\n            right.parent = adjacent;\r\n            node.right = null;\r\n        }\r\n        adjacent.height = Math.max(leftHeight, rightHeight) + 1;\r\n        replaceInParent(node, adjacent);\r\n        return;\r\n    } else if (left != null) {\r\n        replaceInParent(node, left);\r\n        node.left = null;\r\n    } else if (right != null) {\r\n        replaceInParent(node, right);\r\n        node.right = null;\r\n    } else {\r\n        replaceInParent(node, null);\r\n    }\r\n    rebalance(originalParent, false);\r\n    size--;\r\n    modCount++;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "method",
    "name": "removeInternalByKey",
    "start_line": 304,
    "end_line": 310,
    "code": "Node<K, V> removeInternalByKey(Object key) {\r\n    Node<K, V> node = findByObject(key);\r\n    if (node != null) {\r\n        removeInternal(node, true);\r\n    }\r\n    return node;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "method",
    "name": "replaceInParent",
    "start_line": 312,
    "end_line": 330,
    "code": "@SuppressWarnings(\"ReferenceEquality\")\r\nprivate void replaceInParent(Node<K, V> node, Node<K, V> replacement) {\r\n    Node<K, V> parent = node.parent;\r\n    node.parent = null;\r\n    if (replacement != null) {\r\n        replacement.parent = parent;\r\n    }\r\n    if (parent != null) {\r\n        if (parent.left == node) {\r\n            parent.left = replacement;\r\n        } else {\r\n            assert parent.right == node;\r\n            parent.right = replacement;\r\n        }\r\n    } else {\r\n        root = replacement;\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "method",
    "name": "rebalance",
    "start_line": 338,
    "end_line": 396,
    "code": "/**\r\n * Rebalances the tree by making any AVL rotations necessary between the newly-unbalanced node and\r\n * the tree's root.\r\n *\r\n * @param insert true if the node was unbalanced by an insert; false if it was by a removal.\r\n */\r\nprivate void rebalance(Node<K, V> unbalanced, boolean insert) {\r\n    for (Node<K, V> node = unbalanced; node != null; node = node.parent) {\r\n        Node<K, V> left = node.left;\r\n        Node<K, V> right = node.right;\r\n        int leftHeight = left != null ? left.height : 0;\r\n        int rightHeight = right != null ? right.height : 0;\r\n        int delta = leftHeight - rightHeight;\r\n        if (delta == -2) {\r\n            Node<K, V> rightLeft = right.left;\r\n            Node<K, V> rightRight = right.right;\r\n            int rightRightHeight = rightRight != null ? rightRight.height : 0;\r\n            int rightLeftHeight = rightLeft != null ? rightLeft.height : 0;\r\n            int rightDelta = rightLeftHeight - rightRightHeight;\r\n            if (rightDelta == -1 || (rightDelta == 0 && !insert)) {\r\n                // AVL right right\r\n                rotateLeft(node);\r\n            } else {\r\n                assert (rightDelta == 1);\r\n                // AVL right left\r\n                rotateRight(right);\r\n                rotateLeft(node);\r\n            }\r\n            if (insert) {\r\n                // no further rotations will be necessary\r\n                break;\r\n            }\r\n        } else if (delta == 2) {\r\n            Node<K, V> leftLeft = left.left;\r\n            Node<K, V> leftRight = left.right;\r\n            int leftRightHeight = leftRight != null ? leftRight.height : 0;\r\n            int leftLeftHeight = leftLeft != null ? leftLeft.height : 0;\r\n            int leftDelta = leftLeftHeight - leftRightHeight;\r\n            if (leftDelta == 1 || (leftDelta == 0 && !insert)) {\r\n                // AVL left left\r\n                rotateRight(node);\r\n            } else {\r\n                assert (leftDelta == -1);\r\n                // AVL left right\r\n                rotateLeft(left);\r\n                rotateRight(node);\r\n            }\r\n            if (insert) {\r\n                // no further rotations will be necessary\r\n                break;\r\n            }\r\n        } else if (delta == 0) {\r\n            // leftHeight == rightHeight\r\n            node.height = leftHeight + 1;\r\n            if (insert) {\r\n                // the insert caused balance, so rebalancing is done!\r\n                break;\r\n            }\r\n        } else {\r\n            assert (delta == -1 || delta == 1);\r\n            node.height = Math.max(leftHeight, rightHeight) + 1;\r\n            if (!insert) {\r\n                // the height hasn't changed, so rebalancing is done!\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "method",
    "name": "rotateLeft",
    "start_line": 399,
    "end_line": 421,
    "code": "/**\r\n * Rotates the subtree so that its root's right child is the new root.\r\n */\r\nprivate void rotateLeft(Node<K, V> root) {\r\n    Node<K, V> left = root.left;\r\n    Node<K, V> pivot = root.right;\r\n    Node<K, V> pivotLeft = pivot.left;\r\n    Node<K, V> pivotRight = pivot.right;\r\n    // move the pivot's left child to the root's right\r\n    root.right = pivotLeft;\r\n    if (pivotLeft != null) {\r\n        pivotLeft.parent = root;\r\n    }\r\n    replaceInParent(root, pivot);\r\n    // move the root to the pivot's left\r\n    pivot.left = root;\r\n    root.parent = pivot;\r\n    // fix heights\r\n    root.height = Math.max(left != null ? left.height : 0, pivotLeft != null ? pivotLeft.height : 0) + 1;\r\n    pivot.height = Math.max(root.height, pivotRight != null ? pivotRight.height : 0) + 1;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "method",
    "name": "rotateRight",
    "start_line": 424,
    "end_line": 446,
    "code": "/**\r\n * Rotates the subtree so that its root's left child is the new root.\r\n */\r\nprivate void rotateRight(Node<K, V> root) {\r\n    Node<K, V> pivot = root.left;\r\n    Node<K, V> right = root.right;\r\n    Node<K, V> pivotLeft = pivot.left;\r\n    Node<K, V> pivotRight = pivot.right;\r\n    // move the pivot's right child to the root's left\r\n    root.left = pivotRight;\r\n    if (pivotRight != null) {\r\n        pivotRight.parent = root;\r\n    }\r\n    replaceInParent(root, pivot);\r\n    // move the root to the pivot's right\r\n    pivot.right = root;\r\n    root.parent = pivot;\r\n    // fixup heights\r\n    root.height = Math.max(right != null ? right.height : 0, pivotRight != null ? pivotRight.height : 0) + 1;\r\n    pivot.height = Math.max(root.height, pivotLeft != null ? pivotLeft.height : 0) + 1;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "method",
    "name": "entrySet",
    "start_line": 451,
    "end_line": 458,
    "code": "@Override\r\npublic Set<Entry<K, V>> entrySet() {\r\n    EntrySet result = entrySet;\r\n    if (result == null) {\r\n        result = entrySet = new EntrySet();\r\n    }\r\n    return result;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "method",
    "name": "keySet",
    "start_line": 460,
    "end_line": 467,
    "code": "@Override\r\npublic Set<K> keySet() {\r\n    KeySet result = keySet;\r\n    if (result == null) {\r\n        result = keySet = new KeySet();\r\n    }\r\n    return result;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "method",
    "name": "writeReplace",
    "start_line": 678,
    "end_line": 680,
    "code": "/**\r\n * If somebody is unlucky enough to have to serialize one of these, serialize it as a\r\n * LinkedHashMap so that they won't need Gson on the other side to deserialize it. Using\r\n * serialization defeats our DoS defence, so most apps shouldn't use it.\r\n */\r\nprivate Object writeReplace() throws ObjectStreamException {\r\n    return new LinkedHashMap<>(this);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  },
  {
    "type": "method",
    "name": "readObject",
    "start_line": 682,
    "end_line": 686,
    "code": "private void readObject(ObjectInputStream in) throws IOException {\r\n    // Don't permit directly deserializing this class; writeReplace() should have written a\r\n    // replacement\r\n    throw new InvalidObjectException(\"Deserialization is unsupported\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\LinkedTreeMap.java"
  }
]