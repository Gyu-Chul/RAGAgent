[
  {
    "type": "package",
    "name": "com.google.gson.reflect",
    "start_line": 17,
    "end_line": 17,
    "code": "package com.google.gson.reflect;\r\n\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\TypeToken.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.internal.GsonTypes",
    "start_line": 19,
    "end_line": 19,
    "code": "import com.google.gson.internal.GsonTypes;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\TypeToken.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.internal.TroubleshootingGuide",
    "start_line": 20,
    "end_line": 20,
    "code": "import com.google.gson.internal.TroubleshootingGuide;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\TypeToken.java"
  },
  {
    "type": "import",
    "name": "java.lang.reflect.GenericArrayType",
    "start_line": 21,
    "end_line": 21,
    "code": "import java.lang.reflect.GenericArrayType;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\TypeToken.java"
  },
  {
    "type": "import",
    "name": "java.lang.reflect.ParameterizedType",
    "start_line": 22,
    "end_line": 22,
    "code": "import java.lang.reflect.ParameterizedType;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\TypeToken.java"
  },
  {
    "type": "import",
    "name": "java.lang.reflect.Type",
    "start_line": 23,
    "end_line": 23,
    "code": "import java.lang.reflect.Type;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\TypeToken.java"
  },
  {
    "type": "import",
    "name": "java.lang.reflect.TypeVariable",
    "start_line": 24,
    "end_line": 24,
    "code": "import java.lang.reflect.TypeVariable;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\TypeToken.java"
  },
  {
    "type": "import",
    "name": "java.lang.reflect.WildcardType",
    "start_line": 25,
    "end_line": 25,
    "code": "import java.lang.reflect.WildcardType;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\TypeToken.java"
  },
  {
    "type": "import",
    "name": "java.util.HashMap",
    "start_line": 26,
    "end_line": 26,
    "code": "import java.util.HashMap;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\TypeToken.java"
  },
  {
    "type": "import",
    "name": "java.util.Map",
    "start_line": 27,
    "end_line": 27,
    "code": "import java.util.Map;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\TypeToken.java"
  },
  {
    "type": "import",
    "name": "java.util.Objects",
    "start_line": 28,
    "end_line": 28,
    "code": "import java.util.Objects;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\TypeToken.java"
  },
  {
    "type": "class",
    "name": "TypeToken",
    "start_line": 54,
    "end_line": 452,
    "code": "/**\r\n * Represents a generic type {@code T}. Java doesn't yet provide a way to represent generic types,\r\n * so this class does. Forces clients to create a subclass of this class which enables retrieval the\r\n * type information even at runtime.\r\n *\r\n * <p>For example, to create a type literal for {@code List<String>}, you can create an empty\r\n * anonymous class:\r\n *\r\n * <p>{@code TypeToken<List<String>> list = new TypeToken<List<String>>() {};}\r\n *\r\n * <p>Capturing a type variable as type argument of an anonymous {@code TypeToken} subclass is not\r\n * allowed, for example {@code TypeToken<List<T>>}. Due to type erasure the runtime type of a type\r\n * variable is not available to Gson and therefore it cannot provide the functionality one might\r\n * expect. This would give a false sense of type-safety at compile time and could lead to an\r\n * unexpected {@code ClassCastException} at runtime.\r\n *\r\n * <p>If the type arguments of the parameterized type are only available at runtime, for example\r\n * when you want to create a {@code List<E>} based on a {@code Class<E>} representing the element\r\n * type, the method {@link #getParameterized(Type, Type...)} can be used.\r\n *\r\n * @author Bob Lee\r\n * @author Sven Mawson\r\n * @author Jesse Wilson\r\n */\r\npublic class TypeToken<T> {\r\n\r\n    private final Class<? super T> rawType;\r\n\r\n    private final Type type;\r\n\r\n    private final int hashCode;\r\n\r\n    /**\r\n     * Constructs a new type literal. Derives represented class from type parameter.\r\n     *\r\n     * <p>Clients create an empty anonymous subclass. Doing so embeds the type parameter in the\r\n     * anonymous class's type hierarchy so we can reconstitute it at runtime despite erasure, for\r\n     * example:\r\n     *\r\n     * <p>{@code new TypeToken<List<String>>() {}}\r\n     *\r\n     * @throws IllegalArgumentException If the anonymous {@code TypeToken} subclass captures a type\r\n     *     variable, for example {@code TypeToken<List<T>>}. See the {@code TypeToken} class\r\n     *     documentation for more details.\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    protected TypeToken() {\r\n        this.type = getTypeTokenTypeArgument();\r\n        this.rawType = (Class<? super T>) GsonTypes.getRawType(type);\r\n        this.hashCode = type.hashCode();\r\n    }\r\n\r\n    /**\r\n     * Unsafe. Constructs a type literal manually.\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    private TypeToken(Type type) {\r\n        this.type = GsonTypes.canonicalize(Objects.requireNonNull(type));\r\n        this.rawType = (Class<? super T>) GsonTypes.getRawType(this.type);\r\n        this.hashCode = this.type.hashCode();\r\n    }\r\n\r\n    private static boolean isCapturingTypeVariablesForbidden() {\r\n        return !Objects.equals(System.getProperty(\"gson.allowCapturingTypeVariables\"), \"true\");\r\n    }\r\n\r\n    /**\r\n     * Verifies that {@code this} is an instance of a direct subclass of TypeToken and returns the\r\n     * type argument for {@code T} in {@link GsonTypes#canonicalize canonical form}.\r\n     */\r\n    private Type getTypeTokenTypeArgument() {\r\n        Type superclass = getClass().getGenericSuperclass();\r\n        if (superclass instanceof ParameterizedType) {\r\n            ParameterizedType parameterized = (ParameterizedType) superclass;\r\n            if (parameterized.getRawType() == TypeToken.class) {\r\n                Type typeArgument = GsonTypes.canonicalize(parameterized.getActualTypeArguments()[0]);\r\n                if (isCapturingTypeVariablesForbidden()) {\r\n                    verifyNoTypeVariable(typeArgument);\r\n                }\r\n                return typeArgument;\r\n            }\r\n        } else // Check for raw TypeToken as superclass\r\n        if (superclass == TypeToken.class) {\r\n            throw new IllegalStateException(\"TypeToken must be created with a type argument: new TypeToken<...>() {}; When using code\" + \" shrinkers (ProGuard, R8, ...) make sure that generic signatures are preserved.\" + \"\\nSee \" + TroubleshootingGuide.createUrl(\"type-token-raw\"));\r\n        }\r\n        // User created subclass of subclass of TypeToken\r\n        throw new IllegalStateException(\"Must only create direct subclasses of TypeToken\");\r\n    }\r\n\r\n    private static void verifyNoTypeVariable(Type type) {\r\n        if (type instanceof TypeVariable) {\r\n            TypeVariable<?> typeVariable = (TypeVariable<?>) type;\r\n            throw new IllegalArgumentException(\"TypeToken type argument must not contain a type variable; captured type variable \" + typeVariable.getName() + \" declared by \" + typeVariable.getGenericDeclaration() + \"\\nSee \" + TroubleshootingGuide.createUrl(\"typetoken-type-variable\"));\r\n        } else if (type instanceof GenericArrayType) {\r\n            verifyNoTypeVariable(((GenericArrayType) type).getGenericComponentType());\r\n        } else if (type instanceof ParameterizedType) {\r\n            ParameterizedType parameterizedType = (ParameterizedType) type;\r\n            Type ownerType = parameterizedType.getOwnerType();\r\n            if (ownerType != null) {\r\n                verifyNoTypeVariable(ownerType);\r\n            }\r\n            for (Type typeArgument : parameterizedType.getActualTypeArguments()) {\r\n                verifyNoTypeVariable(typeArgument);\r\n            }\r\n        } else if (type instanceof WildcardType) {\r\n            WildcardType wildcardType = (WildcardType) type;\r\n            for (Type bound : wildcardType.getLowerBounds()) {\r\n                verifyNoTypeVariable(bound);\r\n            }\r\n            for (Type bound : wildcardType.getUpperBounds()) {\r\n                verifyNoTypeVariable(bound);\r\n            }\r\n        } else if (type == null) {\r\n            // Occurs in Eclipse IDE and certain Java versions (e.g. Java 11.0.18) when capturing type\r\n            // variable declared by method of local class, see\r\n            // https://github.com/eclipse-jdt/eclipse.jdt.core/issues/975\r\n            throw new IllegalArgumentException(\"TypeToken captured `null` as type argument; probably a compiler / runtime bug\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the raw (non-generic) type for this type.\r\n     */\r\n    public final Class<? super T> getRawType() {\r\n        return rawType;\r\n    }\r\n\r\n    /**\r\n     * Gets underlying {@code Type} instance.\r\n     */\r\n    public final Type getType() {\r\n        return type;\r\n    }\r\n\r\n    /**\r\n     * Check if this type is assignable from the given class object.\r\n     *\r\n     * @deprecated this implementation may be inconsistent with javac for types with wildcards.\r\n     */\r\n    @Deprecated\r\n    public boolean isAssignableFrom(Class<?> cls) {\r\n        return isAssignableFrom((Type) cls);\r\n    }\r\n\r\n    /**\r\n     * Check if this type is assignable from the given Type.\r\n     *\r\n     * @deprecated this implementation may be inconsistent with javac for types with wildcards.\r\n     */\r\n    @Deprecated\r\n    public boolean isAssignableFrom(Type from) {\r\n        if (from == null) {\r\n            return false;\r\n        }\r\n        if (type.equals(from)) {\r\n            return true;\r\n        }\r\n        if (type instanceof Class<?>) {\r\n            return rawType.isAssignableFrom(GsonTypes.getRawType(from));\r\n        } else if (type instanceof ParameterizedType) {\r\n            return isAssignableFrom(from, (ParameterizedType) type, new HashMap<String, Type>());\r\n        } else if (type instanceof GenericArrayType) {\r\n            return rawType.isAssignableFrom(GsonTypes.getRawType(from)) && isAssignableFrom(from, (GenericArrayType) type);\r\n        } else {\r\n            throw buildUnsupportedTypeException(type, Class.class, ParameterizedType.class, GenericArrayType.class);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if this type is assignable from the given type token.\r\n     *\r\n     * @deprecated this implementation may be inconsistent with javac for types with wildcards.\r\n     */\r\n    @Deprecated\r\n    public boolean isAssignableFrom(TypeToken<?> token) {\r\n        return isAssignableFrom(token.getType());\r\n    }\r\n\r\n    /**\r\n     * Private helper function that performs some assignability checks for the provided\r\n     * GenericArrayType.\r\n     */\r\n    private static boolean isAssignableFrom(Type from, GenericArrayType to) {\r\n        Type toGenericComponentType = to.getGenericComponentType();\r\n        if (toGenericComponentType instanceof ParameterizedType) {\r\n            Type t = from;\r\n            if (from instanceof GenericArrayType) {\r\n                t = ((GenericArrayType) from).getGenericComponentType();\r\n            } else if (from instanceof Class<?>) {\r\n                Class<?> classType = (Class<?>) from;\r\n                while (classType.isArray()) {\r\n                    classType = classType.getComponentType();\r\n                }\r\n                t = classType;\r\n            }\r\n            return isAssignableFrom(t, (ParameterizedType) toGenericComponentType, new HashMap<String, Type>());\r\n        }\r\n        // No generic defined on \"to\"; therefore, return true and let other\r\n        // checks determine assignability\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Private recursive helper function to actually do the type-safe checking of assignability.\r\n     */\r\n    private static boolean isAssignableFrom(Type from, ParameterizedType to, Map<String, Type> typeVarMap) {\r\n        if (from == null) {\r\n            return false;\r\n        }\r\n        if (to.equals(from)) {\r\n            return true;\r\n        }\r\n        // First figure out the class and any type information.\r\n        Class<?> clazz = GsonTypes.getRawType(from);\r\n        ParameterizedType ptype = null;\r\n        if (from instanceof ParameterizedType) {\r\n            ptype = (ParameterizedType) from;\r\n        }\r\n        // Load up parameterized variable info if it was parameterized.\r\n        if (ptype != null) {\r\n            Type[] tArgs = ptype.getActualTypeArguments();\r\n            TypeVariable<?>[] tParams = clazz.getTypeParameters();\r\n            for (int i = 0; i < tArgs.length; i++) {\r\n                Type arg = tArgs[i];\r\n                TypeVariable<?> var = tParams[i];\r\n                while (arg instanceof TypeVariable<?>) {\r\n                    TypeVariable<?> v = (TypeVariable<?>) arg;\r\n                    arg = typeVarMap.get(v.getName());\r\n                }\r\n                typeVarMap.put(var.getName(), arg);\r\n            }\r\n            // check if they are equivalent under our current mapping.\r\n            if (typeEquals(ptype, to, typeVarMap)) {\r\n                return true;\r\n            }\r\n        }\r\n        for (Type itype : clazz.getGenericInterfaces()) {\r\n            if (isAssignableFrom(itype, to, new HashMap<>(typeVarMap))) {\r\n                return true;\r\n            }\r\n        }\r\n        // Interfaces didn't work, try the superclass.\r\n        Type sType = clazz.getGenericSuperclass();\r\n        return isAssignableFrom(sType, to, new HashMap<>(typeVarMap));\r\n    }\r\n\r\n    /**\r\n     * Checks if two parameterized types are exactly equal, under the variable replacement described\r\n     * in the typeVarMap.\r\n     */\r\n    private static boolean typeEquals(ParameterizedType from, ParameterizedType to, Map<String, Type> typeVarMap) {\r\n        if (from.getRawType().equals(to.getRawType())) {\r\n            Type[] fromArgs = from.getActualTypeArguments();\r\n            Type[] toArgs = to.getActualTypeArguments();\r\n            for (int i = 0; i < fromArgs.length; i++) {\r\n                if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private static IllegalArgumentException buildUnsupportedTypeException(Type token, Class<?>... expected) {\r\n        // Build exception message\r\n        StringBuilder exceptionMessage = new StringBuilder(\"Unsupported type, expected one of: \");\r\n        for (Class<?> clazz : expected) {\r\n            exceptionMessage.append(clazz.getName()).append(\", \");\r\n        }\r\n        exceptionMessage.append(\"but got: \").append(token.getClass().getName()).append(\", for type token: \").append(token.toString());\r\n        return new IllegalArgumentException(exceptionMessage.toString());\r\n    }\r\n\r\n    /**\r\n     * Checks if two types are the same or are equivalent under a variable mapping given in the type\r\n     * map that was provided.\r\n     */\r\n    private static boolean matches(Type from, Type to, Map<String, Type> typeMap) {\r\n        return to.equals(from) || (from instanceof TypeVariable && to.equals(typeMap.get(((TypeVariable<?>) from).getName())));\r\n    }\r\n\r\n    @Override\r\n    public final int hashCode() {\r\n        return this.hashCode;\r\n    }\r\n\r\n    @Override\r\n    public final boolean equals(Object o) {\r\n        return o instanceof TypeToken<?> && GsonTypes.equals(type, ((TypeToken<?>) o).type);\r\n    }\r\n\r\n    @Override\r\n    public final String toString() {\r\n        return GsonTypes.typeToString(type);\r\n    }\r\n\r\n    /**\r\n     * Gets type literal for the given {@code Type} instance.\r\n     */\r\n    public static TypeToken<?> get(Type type) {\r\n        return new TypeToken<>(type);\r\n    }\r\n\r\n    /**\r\n     * Gets type literal for the given {@code Class} instance.\r\n     */\r\n    public static <T> TypeToken<T> get(Class<T> type) {\r\n        return new TypeToken<>(type);\r\n    }\r\n\r\n    /**\r\n     * Gets a type literal for the parameterized type represented by applying {@code typeArguments} to\r\n     * {@code rawType}. This is mainly intended for situations where the type arguments are not\r\n     * available at compile time. The following example shows how a type token for {@code Map<K, V>}\r\n     * can be created:\r\n     *\r\n     * <pre>{@code\r\n     * Class<K> keyClass = ...;\r\n     * Class<V> valueClass = ...;\r\n     * TypeToken<?> mapTypeToken = TypeToken.getParameterized(Map.class, keyClass, valueClass);\r\n     * }</pre>\r\n     *\r\n     * As seen here the result is a {@code TypeToken<?>}; this method cannot provide any type-safety,\r\n     * and care must be taken to pass in the correct number of type arguments.\r\n     *\r\n     * <p>If {@code rawType} is a non-generic class and no type arguments are provided, this method\r\n     * simply delegates to {@link #get(Class)} and creates a {@code TypeToken(Class)}.\r\n     *\r\n     * @throws IllegalArgumentException If {@code rawType} is not of type {@code Class}, or if the\r\n     *     type arguments are invalid for the raw type\r\n     */\r\n    public static TypeToken<?> getParameterized(Type rawType, Type... typeArguments) {\r\n        Objects.requireNonNull(rawType);\r\n        Objects.requireNonNull(typeArguments);\r\n        // Perform basic validation here because this is the only public API where users\r\n        // can create malformed parameterized types\r\n        if (!(rawType instanceof Class)) {\r\n            // See also https://bugs.openjdk.org/browse/JDK-8250659\r\n            throw new IllegalArgumentException(\"rawType must be of type Class, but was \" + rawType);\r\n        }\r\n        Class<?> rawClass = (Class<?>) rawType;\r\n        TypeVariable<?>[] typeVariables = rawClass.getTypeParameters();\r\n        int expectedArgsCount = typeVariables.length;\r\n        int actualArgsCount = typeArguments.length;\r\n        if (actualArgsCount != expectedArgsCount) {\r\n            throw new IllegalArgumentException(rawClass.getName() + \" requires \" + expectedArgsCount + \" type arguments, but got \" + actualArgsCount);\r\n        }\r\n        // For legacy reasons create a TypeToken(Class) if the type is not generic\r\n        if (typeArguments.length == 0) {\r\n            return get(rawClass);\r\n        }\r\n        // Check for this here to avoid misleading exception thrown by ParameterizedTypeImpl\r\n        if (GsonTypes.requiresOwnerType(rawType)) {\r\n            throw new IllegalArgumentException(\"Raw type \" + rawClass.getName() + \" is not supported because it requires specifying an owner type\");\r\n        }\r\n        for (int i = 0; i < expectedArgsCount; i++) {\r\n            Type typeArgument = Objects.requireNonNull(typeArguments[i], \"Type argument must not be null\");\r\n            Class<?> rawTypeArgument = GsonTypes.getRawType(typeArgument);\r\n            TypeVariable<?> typeVariable = typeVariables[i];\r\n            for (Type bound : typeVariable.getBounds()) {\r\n                Class<?> rawBound = GsonTypes.getRawType(bound);\r\n                if (!rawBound.isAssignableFrom(rawTypeArgument)) {\r\n                    throw new IllegalArgumentException(\"Type argument \" + typeArgument + \" does not satisfy bounds for type variable \" + typeVariable + \" declared by \" + rawType);\r\n                }\r\n            }\r\n        }\r\n        return new TypeToken<>(GsonTypes.newParameterizedTypeWithOwner(null, rawClass, typeArguments));\r\n    }\r\n\r\n    /**\r\n     * Gets type literal for the array type whose elements are all instances of {@code componentType}.\r\n     */\r\n    public static TypeToken<?> getArray(Type componentType) {\r\n        return new TypeToken<>(GsonTypes.arrayOf(componentType));\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\TypeToken.java"
  },
  {
    "type": "field",
    "name": "rawType",
    "start_line": 55,
    "end_line": 55,
    "code": "private final Class<? super T> rawType;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\TypeToken.java"
  },
  {
    "type": "field",
    "name": "type",
    "start_line": 56,
    "end_line": 56,
    "code": "private final Type type;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\TypeToken.java"
  },
  {
    "type": "field",
    "name": "hashCode",
    "start_line": 57,
    "end_line": 57,
    "code": "private final int hashCode;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\TypeToken.java"
  },
  {
    "type": "constructor",
    "name": "TypeToken",
    "start_line": 72,
    "end_line": 77,
    "code": "/**\r\n * Constructs a new type literal. Derives represented class from type parameter.\r\n *\r\n * <p>Clients create an empty anonymous subclass. Doing so embeds the type parameter in the\r\n * anonymous class's type hierarchy so we can reconstitute it at runtime despite erasure, for\r\n * example:\r\n *\r\n * <p>{@code new TypeToken<List<String>>() {}}\r\n *\r\n * @throws IllegalArgumentException If the anonymous {@code TypeToken} subclass captures a type\r\n *     variable, for example {@code TypeToken<List<T>>}. See the {@code TypeToken} class\r\n *     documentation for more details.\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\nprotected TypeToken() {\r\n    this.type = getTypeTokenTypeArgument();\r\n    this.rawType = (Class<? super T>) GsonTypes.getRawType(type);\r\n    this.hashCode = type.hashCode();\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\TypeToken.java"
  },
  {
    "type": "constructor",
    "name": "TypeToken",
    "start_line": 80,
    "end_line": 85,
    "code": "/**\r\n * Unsafe. Constructs a type literal manually.\r\n */\r\n@SuppressWarnings(\"unchecked\")\r\nprivate TypeToken(Type type) {\r\n    this.type = GsonTypes.canonicalize(Objects.requireNonNull(type));\r\n    this.rawType = (Class<? super T>) GsonTypes.getRawType(this.type);\r\n    this.hashCode = this.type.hashCode();\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\TypeToken.java"
  },
  {
    "type": "method",
    "name": "isCapturingTypeVariablesForbidden",
    "start_line": 87,
    "end_line": 89,
    "code": "private static boolean isCapturingTypeVariablesForbidden() {\r\n    return !Objects.equals(System.getProperty(\"gson.allowCapturingTypeVariables\"), \"true\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\TypeToken.java"
  },
  {
    "type": "method",
    "name": "getTypeTokenTypeArgument",
    "start_line": 95,
    "end_line": 119,
    "code": "/**\r\n * Verifies that {@code this} is an instance of a direct subclass of TypeToken and returns the\r\n * type argument for {@code T} in {@link GsonTypes#canonicalize canonical form}.\r\n */\r\nprivate Type getTypeTokenTypeArgument() {\r\n    Type superclass = getClass().getGenericSuperclass();\r\n    if (superclass instanceof ParameterizedType) {\r\n        ParameterizedType parameterized = (ParameterizedType) superclass;\r\n        if (parameterized.getRawType() == TypeToken.class) {\r\n            Type typeArgument = GsonTypes.canonicalize(parameterized.getActualTypeArguments()[0]);\r\n            if (isCapturingTypeVariablesForbidden()) {\r\n                verifyNoTypeVariable(typeArgument);\r\n            }\r\n            return typeArgument;\r\n        }\r\n    } else // Check for raw TypeToken as superclass\r\n    if (superclass == TypeToken.class) {\r\n        throw new IllegalStateException(\"TypeToken must be created with a type argument: new TypeToken<...>() {}; When using code\" + \" shrinkers (ProGuard, R8, ...) make sure that generic signatures are preserved.\" + \"\\nSee \" + TroubleshootingGuide.createUrl(\"type-token-raw\"));\r\n    }\r\n    // User created subclass of subclass of TypeToken\r\n    throw new IllegalStateException(\"Must only create direct subclasses of TypeToken\");\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\TypeToken.java"
  },
  {
    "type": "method",
    "name": "verifyNoTypeVariable",
    "start_line": 121,
    "end_line": 158,
    "code": "private static void verifyNoTypeVariable(Type type) {\r\n    if (type instanceof TypeVariable) {\r\n        TypeVariable<?> typeVariable = (TypeVariable<?>) type;\r\n        throw new IllegalArgumentException(\"TypeToken type argument must not contain a type variable; captured type variable \" + typeVariable.getName() + \" declared by \" + typeVariable.getGenericDeclaration() + \"\\nSee \" + TroubleshootingGuide.createUrl(\"typetoken-type-variable\"));\r\n    } else if (type instanceof GenericArrayType) {\r\n        verifyNoTypeVariable(((GenericArrayType) type).getGenericComponentType());\r\n    } else if (type instanceof ParameterizedType) {\r\n        ParameterizedType parameterizedType = (ParameterizedType) type;\r\n        Type ownerType = parameterizedType.getOwnerType();\r\n        if (ownerType != null) {\r\n            verifyNoTypeVariable(ownerType);\r\n        }\r\n        for (Type typeArgument : parameterizedType.getActualTypeArguments()) {\r\n            verifyNoTypeVariable(typeArgument);\r\n        }\r\n    } else if (type instanceof WildcardType) {\r\n        WildcardType wildcardType = (WildcardType) type;\r\n        for (Type bound : wildcardType.getLowerBounds()) {\r\n            verifyNoTypeVariable(bound);\r\n        }\r\n        for (Type bound : wildcardType.getUpperBounds()) {\r\n            verifyNoTypeVariable(bound);\r\n        }\r\n    } else if (type == null) {\r\n        // Occurs in Eclipse IDE and certain Java versions (e.g. Java 11.0.18) when capturing type\r\n        // variable declared by method of local class, see\r\n        // https://github.com/eclipse-jdt/eclipse.jdt.core/issues/975\r\n        throw new IllegalArgumentException(\"TypeToken captured `null` as type argument; probably a compiler / runtime bug\");\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\TypeToken.java"
  },
  {
    "type": "method",
    "name": "getRawType",
    "start_line": 161,
    "end_line": 163,
    "code": "/**\r\n * Returns the raw (non-generic) type for this type.\r\n */\r\npublic final Class<? super T> getRawType() {\r\n    return rawType;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\TypeToken.java"
  },
  {
    "type": "method",
    "name": "getType",
    "start_line": 166,
    "end_line": 168,
    "code": "/**\r\n * Gets underlying {@code Type} instance.\r\n */\r\npublic final Type getType() {\r\n    return type;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\TypeToken.java"
  },
  {
    "type": "method",
    "name": "isAssignableFrom",
    "start_line": 175,
    "end_line": 178,
    "code": "/**\r\n * Check if this type is assignable from the given class object.\r\n *\r\n * @deprecated this implementation may be inconsistent with javac for types with wildcards.\r\n */\r\n@Deprecated\r\npublic boolean isAssignableFrom(Class<?> cls) {\r\n    return isAssignableFrom((Type) cls);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\TypeToken.java"
  },
  {
    "type": "method",
    "name": "isAssignableFrom",
    "start_line": 185,
    "end_line": 206,
    "code": "/**\r\n * Check if this type is assignable from the given Type.\r\n *\r\n * @deprecated this implementation may be inconsistent with javac for types with wildcards.\r\n */\r\n@Deprecated\r\npublic boolean isAssignableFrom(Type from) {\r\n    if (from == null) {\r\n        return false;\r\n    }\r\n    if (type.equals(from)) {\r\n        return true;\r\n    }\r\n    if (type instanceof Class<?>) {\r\n        return rawType.isAssignableFrom(GsonTypes.getRawType(from));\r\n    } else if (type instanceof ParameterizedType) {\r\n        return isAssignableFrom(from, (ParameterizedType) type, new HashMap<String, Type>());\r\n    } else if (type instanceof GenericArrayType) {\r\n        return rawType.isAssignableFrom(GsonTypes.getRawType(from)) && isAssignableFrom(from, (GenericArrayType) type);\r\n    } else {\r\n        throw buildUnsupportedTypeException(type, Class.class, ParameterizedType.class, GenericArrayType.class);\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\TypeToken.java"
  },
  {
    "type": "method",
    "name": "isAssignableFrom",
    "start_line": 213,
    "end_line": 216,
    "code": "/**\r\n * Check if this type is assignable from the given type token.\r\n *\r\n * @deprecated this implementation may be inconsistent with javac for types with wildcards.\r\n */\r\n@Deprecated\r\npublic boolean isAssignableFrom(TypeToken<?> token) {\r\n    return isAssignableFrom(token.getType());\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\TypeToken.java"
  },
  {
    "type": "method",
    "name": "isAssignableFrom",
    "start_line": 222,
    "end_line": 241,
    "code": "/**\r\n * Private helper function that performs some assignability checks for the provided\r\n * GenericArrayType.\r\n */\r\nprivate static boolean isAssignableFrom(Type from, GenericArrayType to) {\r\n    Type toGenericComponentType = to.getGenericComponentType();\r\n    if (toGenericComponentType instanceof ParameterizedType) {\r\n        Type t = from;\r\n        if (from instanceof GenericArrayType) {\r\n            t = ((GenericArrayType) from).getGenericComponentType();\r\n        } else if (from instanceof Class<?>) {\r\n            Class<?> classType = (Class<?>) from;\r\n            while (classType.isArray()) {\r\n                classType = classType.getComponentType();\r\n            }\r\n            t = classType;\r\n        }\r\n        return isAssignableFrom(t, (ParameterizedType) toGenericComponentType, new HashMap<String, Type>());\r\n    }\r\n    // No generic defined on \"to\"; therefore, return true and let other\r\n    // checks determine assignability\r\n    return true;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\TypeToken.java"
  },
  {
    "type": "method",
    "name": "isAssignableFrom",
    "start_line": 244,
    "end_line": 291,
    "code": "/**\r\n * Private recursive helper function to actually do the type-safe checking of assignability.\r\n */\r\nprivate static boolean isAssignableFrom(Type from, ParameterizedType to, Map<String, Type> typeVarMap) {\r\n    if (from == null) {\r\n        return false;\r\n    }\r\n    if (to.equals(from)) {\r\n        return true;\r\n    }\r\n    // First figure out the class and any type information.\r\n    Class<?> clazz = GsonTypes.getRawType(from);\r\n    ParameterizedType ptype = null;\r\n    if (from instanceof ParameterizedType) {\r\n        ptype = (ParameterizedType) from;\r\n    }\r\n    // Load up parameterized variable info if it was parameterized.\r\n    if (ptype != null) {\r\n        Type[] tArgs = ptype.getActualTypeArguments();\r\n        TypeVariable<?>[] tParams = clazz.getTypeParameters();\r\n        for (int i = 0; i < tArgs.length; i++) {\r\n            Type arg = tArgs[i];\r\n            TypeVariable<?> var = tParams[i];\r\n            while (arg instanceof TypeVariable<?>) {\r\n                TypeVariable<?> v = (TypeVariable<?>) arg;\r\n                arg = typeVarMap.get(v.getName());\r\n            }\r\n            typeVarMap.put(var.getName(), arg);\r\n        }\r\n        // check if they are equivalent under our current mapping.\r\n        if (typeEquals(ptype, to, typeVarMap)) {\r\n            return true;\r\n        }\r\n    }\r\n    for (Type itype : clazz.getGenericInterfaces()) {\r\n        if (isAssignableFrom(itype, to, new HashMap<>(typeVarMap))) {\r\n            return true;\r\n        }\r\n    }\r\n    // Interfaces didn't work, try the superclass.\r\n    Type sType = clazz.getGenericSuperclass();\r\n    return isAssignableFrom(sType, to, new HashMap<>(typeVarMap));\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\TypeToken.java"
  },
  {
    "type": "method",
    "name": "typeEquals",
    "start_line": 297,
    "end_line": 310,
    "code": "/**\r\n * Checks if two parameterized types are exactly equal, under the variable replacement described\r\n * in the typeVarMap.\r\n */\r\nprivate static boolean typeEquals(ParameterizedType from, ParameterizedType to, Map<String, Type> typeVarMap) {\r\n    if (from.getRawType().equals(to.getRawType())) {\r\n        Type[] fromArgs = from.getActualTypeArguments();\r\n        Type[] toArgs = to.getActualTypeArguments();\r\n        for (int i = 0; i < fromArgs.length; i++) {\r\n            if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\TypeToken.java"
  },
  {
    "type": "method",
    "name": "buildUnsupportedTypeException",
    "start_line": 312,
    "end_line": 327,
    "code": "private static IllegalArgumentException buildUnsupportedTypeException(Type token, Class<?>... expected) {\r\n    // Build exception message\r\n    StringBuilder exceptionMessage = new StringBuilder(\"Unsupported type, expected one of: \");\r\n    for (Class<?> clazz : expected) {\r\n        exceptionMessage.append(clazz.getName()).append(\", \");\r\n    }\r\n    exceptionMessage.append(\"but got: \").append(token.getClass().getName()).append(\", for type token: \").append(token.toString());\r\n    return new IllegalArgumentException(exceptionMessage.toString());\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\TypeToken.java"
  },
  {
    "type": "method",
    "name": "matches",
    "start_line": 333,
    "end_line": 337,
    "code": "/**\r\n * Checks if two types are the same or are equivalent under a variable mapping given in the type\r\n * map that was provided.\r\n */\r\nprivate static boolean matches(Type from, Type to, Map<String, Type> typeMap) {\r\n    return to.equals(from) || (from instanceof TypeVariable && to.equals(typeMap.get(((TypeVariable<?>) from).getName())));\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\TypeToken.java"
  },
  {
    "type": "method",
    "name": "hashCode",
    "start_line": 339,
    "end_line": 342,
    "code": "@Override\r\npublic final int hashCode() {\r\n    return this.hashCode;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\TypeToken.java"
  },
  {
    "type": "method",
    "name": "equals",
    "start_line": 344,
    "end_line": 347,
    "code": "@Override\r\npublic final boolean equals(Object o) {\r\n    return o instanceof TypeToken<?> && GsonTypes.equals(type, ((TypeToken<?>) o).type);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\TypeToken.java"
  },
  {
    "type": "method",
    "name": "toString",
    "start_line": 349,
    "end_line": 352,
    "code": "@Override\r\npublic final String toString() {\r\n    return GsonTypes.typeToString(type);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\TypeToken.java"
  },
  {
    "type": "method",
    "name": "get",
    "start_line": 355,
    "end_line": 357,
    "code": "/**\r\n * Gets type literal for the given {@code Type} instance.\r\n */\r\npublic static TypeToken<?> get(Type type) {\r\n    return new TypeToken<>(type);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\TypeToken.java"
  },
  {
    "type": "method",
    "name": "get",
    "start_line": 360,
    "end_line": 362,
    "code": "/**\r\n * Gets type literal for the given {@code Class} instance.\r\n */\r\npublic static <T> TypeToken<T> get(Class<T> type) {\r\n    return new TypeToken<>(type);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\TypeToken.java"
  },
  {
    "type": "method",
    "name": "getParameterized",
    "start_line": 385,
    "end_line": 444,
    "code": "/**\r\n * Gets a type literal for the parameterized type represented by applying {@code typeArguments} to\r\n * {@code rawType}. This is mainly intended for situations where the type arguments are not\r\n * available at compile time. The following example shows how a type token for {@code Map<K, V>}\r\n * can be created:\r\n *\r\n * <pre>{@code\r\n * Class<K> keyClass = ...;\r\n * Class<V> valueClass = ...;\r\n * TypeToken<?> mapTypeToken = TypeToken.getParameterized(Map.class, keyClass, valueClass);\r\n * }</pre>\r\n *\r\n * As seen here the result is a {@code TypeToken<?>}; this method cannot provide any type-safety,\r\n * and care must be taken to pass in the correct number of type arguments.\r\n *\r\n * <p>If {@code rawType} is a non-generic class and no type arguments are provided, this method\r\n * simply delegates to {@link #get(Class)} and creates a {@code TypeToken(Class)}.\r\n *\r\n * @throws IllegalArgumentException If {@code rawType} is not of type {@code Class}, or if the\r\n *     type arguments are invalid for the raw type\r\n */\r\npublic static TypeToken<?> getParameterized(Type rawType, Type... typeArguments) {\r\n    Objects.requireNonNull(rawType);\r\n    Objects.requireNonNull(typeArguments);\r\n    // Perform basic validation here because this is the only public API where users\r\n    // can create malformed parameterized types\r\n    if (!(rawType instanceof Class)) {\r\n        // See also https://bugs.openjdk.org/browse/JDK-8250659\r\n        throw new IllegalArgumentException(\"rawType must be of type Class, but was \" + rawType);\r\n    }\r\n    Class<?> rawClass = (Class<?>) rawType;\r\n    TypeVariable<?>[] typeVariables = rawClass.getTypeParameters();\r\n    int expectedArgsCount = typeVariables.length;\r\n    int actualArgsCount = typeArguments.length;\r\n    if (actualArgsCount != expectedArgsCount) {\r\n        throw new IllegalArgumentException(rawClass.getName() + \" requires \" + expectedArgsCount + \" type arguments, but got \" + actualArgsCount);\r\n    }\r\n    // For legacy reasons create a TypeToken(Class) if the type is not generic\r\n    if (typeArguments.length == 0) {\r\n        return get(rawClass);\r\n    }\r\n    // Check for this here to avoid misleading exception thrown by ParameterizedTypeImpl\r\n    if (GsonTypes.requiresOwnerType(rawType)) {\r\n        throw new IllegalArgumentException(\"Raw type \" + rawClass.getName() + \" is not supported because it requires specifying an owner type\");\r\n    }\r\n    for (int i = 0; i < expectedArgsCount; i++) {\r\n        Type typeArgument = Objects.requireNonNull(typeArguments[i], \"Type argument must not be null\");\r\n        Class<?> rawTypeArgument = GsonTypes.getRawType(typeArgument);\r\n        TypeVariable<?> typeVariable = typeVariables[i];\r\n        for (Type bound : typeVariable.getBounds()) {\r\n            Class<?> rawBound = GsonTypes.getRawType(bound);\r\n            if (!rawBound.isAssignableFrom(rawTypeArgument)) {\r\n                throw new IllegalArgumentException(\"Type argument \" + typeArgument + \" does not satisfy bounds for type variable \" + typeVariable + \" declared by \" + rawType);\r\n            }\r\n        }\r\n    }\r\n    return new TypeToken<>(GsonTypes.newParameterizedTypeWithOwner(null, rawClass, typeArguments));\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\TypeToken.java"
  },
  {
    "type": "method",
    "name": "getArray",
    "start_line": 449,
    "end_line": 451,
    "code": "/**\r\n * Gets type literal for the array type whose elements are all instances of {@code componentType}.\r\n */\r\npublic static TypeToken<?> getArray(Type componentType) {\r\n    return new TypeToken<>(GsonTypes.arrayOf(componentType));\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\reflect\\TypeToken.java"
  }
]