[
  {
    "type": "package",
    "name": "com.google.gson.internal.bind",
    "start_line": 17,
    "end_line": 17,
    "code": "package com.google.gson.internal.bind;\r\n\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.Gson",
    "start_line": 19,
    "end_line": 19,
    "code": "import com.google.gson.Gson;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.JsonElement",
    "start_line": 20,
    "end_line": 20,
    "code": "import com.google.gson.JsonElement;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.JsonIOException",
    "start_line": 21,
    "end_line": 21,
    "code": "import com.google.gson.JsonIOException;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.JsonSyntaxException",
    "start_line": 22,
    "end_line": 22,
    "code": "import com.google.gson.JsonSyntaxException;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.TypeAdapter",
    "start_line": 23,
    "end_line": 23,
    "code": "import com.google.gson.TypeAdapter;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.TypeAdapterFactory",
    "start_line": 24,
    "end_line": 24,
    "code": "import com.google.gson.TypeAdapterFactory;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.internal.LazilyParsedNumber",
    "start_line": 25,
    "end_line": 25,
    "code": "import com.google.gson.internal.LazilyParsedNumber;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.internal.NumberLimits",
    "start_line": 26,
    "end_line": 26,
    "code": "import com.google.gson.internal.NumberLimits;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.internal.TroubleshootingGuide",
    "start_line": 27,
    "end_line": 27,
    "code": "import com.google.gson.internal.TroubleshootingGuide;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.reflect.TypeToken",
    "start_line": 28,
    "end_line": 28,
    "code": "import com.google.gson.reflect.TypeToken;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.stream.JsonReader",
    "start_line": 29,
    "end_line": 29,
    "code": "import com.google.gson.stream.JsonReader;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.stream.JsonToken",
    "start_line": 30,
    "end_line": 30,
    "code": "import com.google.gson.stream.JsonToken;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.stream.JsonWriter",
    "start_line": 31,
    "end_line": 31,
    "code": "import com.google.gson.stream.JsonWriter;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "import",
    "name": "java.io.IOException",
    "start_line": 32,
    "end_line": 32,
    "code": "import java.io.IOException;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "import",
    "name": "java.math.BigDecimal",
    "start_line": 33,
    "end_line": 33,
    "code": "import java.math.BigDecimal;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "import",
    "name": "java.math.BigInteger",
    "start_line": 34,
    "end_line": 34,
    "code": "import java.math.BigInteger;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "import",
    "name": "java.net.InetAddress",
    "start_line": 35,
    "end_line": 35,
    "code": "import java.net.InetAddress;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "import",
    "name": "java.net.URI",
    "start_line": 36,
    "end_line": 36,
    "code": "import java.net.URI;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "import",
    "name": "java.net.URISyntaxException",
    "start_line": 37,
    "end_line": 37,
    "code": "import java.net.URISyntaxException;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "import",
    "name": "java.net.URL",
    "start_line": 38,
    "end_line": 38,
    "code": "import java.net.URL;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "import",
    "name": "java.util.ArrayList",
    "start_line": 39,
    "end_line": 39,
    "code": "import java.util.ArrayList;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "import",
    "name": "java.util.BitSet",
    "start_line": 40,
    "end_line": 40,
    "code": "import java.util.BitSet;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "import",
    "name": "java.util.Calendar",
    "start_line": 41,
    "end_line": 41,
    "code": "import java.util.Calendar;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "import",
    "name": "java.util.Currency",
    "start_line": 42,
    "end_line": 42,
    "code": "import java.util.Currency;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "import",
    "name": "java.util.GregorianCalendar",
    "start_line": 43,
    "end_line": 43,
    "code": "import java.util.GregorianCalendar;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "import",
    "name": "java.util.List",
    "start_line": 44,
    "end_line": 44,
    "code": "import java.util.List;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "import",
    "name": "java.util.Locale",
    "start_line": 45,
    "end_line": 45,
    "code": "import java.util.Locale;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "import",
    "name": "java.util.StringTokenizer",
    "start_line": 46,
    "end_line": 46,
    "code": "import java.util.StringTokenizer;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "import",
    "name": "java.util.UUID",
    "start_line": 47,
    "end_line": 47,
    "code": "import java.util.UUID;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "import",
    "name": "java.util.concurrent.atomic.AtomicBoolean",
    "start_line": 48,
    "end_line": 48,
    "code": "import java.util.concurrent.atomic.AtomicBoolean;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "import",
    "name": "java.util.concurrent.atomic.AtomicInteger",
    "start_line": 49,
    "end_line": 49,
    "code": "import java.util.concurrent.atomic.AtomicInteger;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "import",
    "name": "java.util.concurrent.atomic.AtomicIntegerArray",
    "start_line": 50,
    "end_line": 50,
    "code": "import java.util.concurrent.atomic.AtomicIntegerArray;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "class",
    "name": "TypeAdapters",
    "start_line": 56,
    "end_line": 936,
    "code": "/**\r\n * Type adapters for basic types. More complex adapters exist as separate classes in the enclosing\r\n * package.\r\n */\r\npublic final class TypeAdapters {\r\n\r\n    private TypeAdapters() {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n    @SuppressWarnings(\"rawtypes\")\r\n    public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Class value) throws IOException {\r\n            throw new UnsupportedOperationException(\"Attempted to serialize java.lang.Class: \" + value.getName() + \". Forgot to register a type adapter?\" + \"\\nSee \" + TroubleshootingGuide.createUrl(\"java-lang-class-unsupported\"));\r\n        }\r\n\r\n        @Override\r\n        public Class read(JsonReader in) throws IOException {\r\n            throw new UnsupportedOperationException(\"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\" + \"\\nSee \" + TroubleshootingGuide.createUrl(\"java-lang-class-unsupported\"));\r\n        }\r\n    }.nullSafe();\r\n\r\n    public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS);\r\n\r\n    public static final TypeAdapter<BitSet> BIT_SET = new TypeAdapter<BitSet>() {\r\n\r\n        @Override\r\n        public BitSet read(JsonReader in) throws IOException {\r\n            BitSet bitset = new BitSet();\r\n            in.beginArray();\r\n            int i = 0;\r\n            JsonToken tokenType = in.peek();\r\n            while (tokenType != JsonToken.END_ARRAY) {\r\n                boolean set;\r\n                switch(tokenType) {\r\n                    case NUMBER:\r\n                    case STRING:\r\n                        int intValue = in.nextInt();\r\n                        if (intValue == 0) {\r\n                            set = false;\r\n                        } else if (intValue == 1) {\r\n                            set = true;\r\n                        } else {\r\n                            throw new JsonSyntaxException(\"Invalid bitset value \" + intValue + \", expected 0 or 1; at path \" + in.getPreviousPath());\r\n                        }\r\n                        break;\r\n                    case BOOLEAN:\r\n                        set = in.nextBoolean();\r\n                        break;\r\n                    default:\r\n                        throw new JsonSyntaxException(\"Invalid bitset value type: \" + tokenType + \"; at path \" + in.getPath());\r\n                }\r\n                if (set) {\r\n                    bitset.set(i);\r\n                }\r\n                ++i;\r\n                tokenType = in.peek();\r\n            }\r\n            in.endArray();\r\n            return bitset;\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, BitSet src) throws IOException {\r\n            out.beginArray();\r\n            for (int i = 0, length = src.length(); i < length; i++) {\r\n                int value = src.get(i) ? 1 : 0;\r\n                out.value(value);\r\n            }\r\n            out.endArray();\r\n        }\r\n    }.nullSafe();\r\n\r\n    public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET);\r\n\r\n    public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() {\r\n\r\n        @Override\r\n        public Boolean read(JsonReader in) throws IOException {\r\n            JsonToken peek = in.peek();\r\n            if (peek == JsonToken.NULL) {\r\n                in.nextNull();\r\n                return null;\r\n            } else if (peek == JsonToken.STRING) {\r\n                // support strings for compatibility with GSON 1.7\r\n                return Boolean.parseBoolean(in.nextString());\r\n            }\r\n            return in.nextBoolean();\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Boolean value) throws IOException {\r\n            out.value(value);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Writes a boolean as a string. Useful for map keys, where booleans aren't otherwise permitted.\r\n     */\r\n    public static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<Boolean>() {\r\n\r\n        @Override\r\n        public Boolean read(JsonReader in) throws IOException {\r\n            if (in.peek() == JsonToken.NULL) {\r\n                in.nextNull();\r\n                return null;\r\n            }\r\n            return Boolean.valueOf(in.nextString());\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Boolean value) throws IOException {\r\n            out.value(value == null ? \"null\" : value.toString());\r\n        }\r\n    };\r\n\r\n    public static final TypeAdapterFactory BOOLEAN_FACTORY = newFactory(boolean.class, Boolean.class, BOOLEAN);\r\n\r\n    public static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() {\r\n\r\n        @Override\r\n        public Number read(JsonReader in) throws IOException {\r\n            if (in.peek() == JsonToken.NULL) {\r\n                in.nextNull();\r\n                return null;\r\n            }\r\n            int intValue;\r\n            try {\r\n                intValue = in.nextInt();\r\n            } catch (NumberFormatException e) {\r\n                throw new JsonSyntaxException(e);\r\n            }\r\n            // Allow up to 255 to support unsigned values\r\n            if (intValue > 255 || intValue < Byte.MIN_VALUE) {\r\n                throw new JsonSyntaxException(\"Lossy conversion from \" + intValue + \" to byte; at path \" + in.getPreviousPath());\r\n            }\r\n            return (byte) intValue;\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Number value) throws IOException {\r\n            if (value == null) {\r\n                out.nullValue();\r\n            } else {\r\n                out.value(value.byteValue());\r\n            }\r\n        }\r\n    };\r\n\r\n    public static final TypeAdapterFactory BYTE_FACTORY = newFactory(byte.class, Byte.class, BYTE);\r\n\r\n    public static final TypeAdapter<Number> SHORT = new TypeAdapter<Number>() {\r\n\r\n        @Override\r\n        public Number read(JsonReader in) throws IOException {\r\n            if (in.peek() == JsonToken.NULL) {\r\n                in.nextNull();\r\n                return null;\r\n            }\r\n            int intValue;\r\n            try {\r\n                intValue = in.nextInt();\r\n            } catch (NumberFormatException e) {\r\n                throw new JsonSyntaxException(e);\r\n            }\r\n            // Allow up to 65535 to support unsigned values\r\n            if (intValue > 65535 || intValue < Short.MIN_VALUE) {\r\n                throw new JsonSyntaxException(\"Lossy conversion from \" + intValue + \" to short; at path \" + in.getPreviousPath());\r\n            }\r\n            return (short) intValue;\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Number value) throws IOException {\r\n            if (value == null) {\r\n                out.nullValue();\r\n            } else {\r\n                out.value(value.shortValue());\r\n            }\r\n        }\r\n    };\r\n\r\n    public static final TypeAdapterFactory SHORT_FACTORY = newFactory(short.class, Short.class, SHORT);\r\n\r\n    public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() {\r\n\r\n        @Override\r\n        public Number read(JsonReader in) throws IOException {\r\n            if (in.peek() == JsonToken.NULL) {\r\n                in.nextNull();\r\n                return null;\r\n            }\r\n            try {\r\n                return in.nextInt();\r\n            } catch (NumberFormatException e) {\r\n                throw new JsonSyntaxException(e);\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Number value) throws IOException {\r\n            if (value == null) {\r\n                out.nullValue();\r\n            } else {\r\n                out.value(value.intValue());\r\n            }\r\n        }\r\n    };\r\n\r\n    public static final TypeAdapterFactory INTEGER_FACTORY = newFactory(int.class, Integer.class, INTEGER);\r\n\r\n    public static final TypeAdapter<AtomicInteger> ATOMIC_INTEGER = new TypeAdapter<AtomicInteger>() {\r\n\r\n        @Override\r\n        public AtomicInteger read(JsonReader in) throws IOException {\r\n            try {\r\n                return new AtomicInteger(in.nextInt());\r\n            } catch (NumberFormatException e) {\r\n                throw new JsonSyntaxException(e);\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, AtomicInteger value) throws IOException {\r\n            out.value(value.get());\r\n        }\r\n    }.nullSafe();\r\n\r\n    public static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY = newFactory(AtomicInteger.class, TypeAdapters.ATOMIC_INTEGER);\r\n\r\n    public static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN = new TypeAdapter<AtomicBoolean>() {\r\n\r\n        @Override\r\n        public AtomicBoolean read(JsonReader in) throws IOException {\r\n            return new AtomicBoolean(in.nextBoolean());\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, AtomicBoolean value) throws IOException {\r\n            out.value(value.get());\r\n        }\r\n    }.nullSafe();\r\n\r\n    public static final TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY = newFactory(AtomicBoolean.class, TypeAdapters.ATOMIC_BOOLEAN);\r\n\r\n    public static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY = new TypeAdapter<AtomicIntegerArray>() {\r\n\r\n        @Override\r\n        public AtomicIntegerArray read(JsonReader in) throws IOException {\r\n            List<Integer> list = new ArrayList<>();\r\n            in.beginArray();\r\n            while (in.hasNext()) {\r\n                try {\r\n                    int integer = in.nextInt();\r\n                    list.add(integer);\r\n                } catch (NumberFormatException e) {\r\n                    throw new JsonSyntaxException(e);\r\n                }\r\n            }\r\n            in.endArray();\r\n            int length = list.size();\r\n            AtomicIntegerArray array = new AtomicIntegerArray(length);\r\n            for (int i = 0; i < length; ++i) {\r\n                array.set(i, list.get(i));\r\n            }\r\n            return array;\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, AtomicIntegerArray value) throws IOException {\r\n            out.beginArray();\r\n            for (int i = 0, length = value.length(); i < length; i++) {\r\n                out.value(value.get(i));\r\n            }\r\n            out.endArray();\r\n        }\r\n    }.nullSafe();\r\n\r\n    public static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY = newFactory(AtomicIntegerArray.class, TypeAdapters.ATOMIC_INTEGER_ARRAY);\r\n\r\n    public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() {\r\n\r\n        @Override\r\n        public Number read(JsonReader in) throws IOException {\r\n            if (in.peek() == JsonToken.NULL) {\r\n                in.nextNull();\r\n                return null;\r\n            }\r\n            try {\r\n                return in.nextLong();\r\n            } catch (NumberFormatException e) {\r\n                throw new JsonSyntaxException(e);\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Number value) throws IOException {\r\n            if (value == null) {\r\n                out.nullValue();\r\n            } else {\r\n                out.value(value.longValue());\r\n            }\r\n        }\r\n    };\r\n\r\n    public static final TypeAdapter<Number> FLOAT = new TypeAdapter<Number>() {\r\n\r\n        @Override\r\n        public Number read(JsonReader in) throws IOException {\r\n            if (in.peek() == JsonToken.NULL) {\r\n                in.nextNull();\r\n                return null;\r\n            }\r\n            return (float) in.nextDouble();\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Number value) throws IOException {\r\n            if (value == null) {\r\n                out.nullValue();\r\n            } else {\r\n                // For backward compatibility don't call `JsonWriter.value(float)` because that method\r\n                // has been newly added and not all custom JsonWriter implementations might override\r\n                // it yet\r\n                Number floatNumber = value instanceof Float ? value : value.floatValue();\r\n                out.value(floatNumber);\r\n            }\r\n        }\r\n    };\r\n\r\n    public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() {\r\n\r\n        @Override\r\n        public Number read(JsonReader in) throws IOException {\r\n            if (in.peek() == JsonToken.NULL) {\r\n                in.nextNull();\r\n                return null;\r\n            }\r\n            return in.nextDouble();\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Number value) throws IOException {\r\n            if (value == null) {\r\n                out.nullValue();\r\n            } else {\r\n                out.value(value.doubleValue());\r\n            }\r\n        }\r\n    };\r\n\r\n    public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() {\r\n\r\n        @Override\r\n        public Character read(JsonReader in) throws IOException {\r\n            if (in.peek() == JsonToken.NULL) {\r\n                in.nextNull();\r\n                return null;\r\n            }\r\n            String str = in.nextString();\r\n            if (str.length() != 1) {\r\n                throw new JsonSyntaxException(\"Expecting character, got: \" + str + \"; at \" + in.getPreviousPath());\r\n            }\r\n            return str.charAt(0);\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Character value) throws IOException {\r\n            out.value(value == null ? null : String.valueOf(value));\r\n        }\r\n    };\r\n\r\n    public static final TypeAdapterFactory CHARACTER_FACTORY = newFactory(char.class, Character.class, CHARACTER);\r\n\r\n    public static final TypeAdapter<String> STRING = new TypeAdapter<String>() {\r\n\r\n        @Override\r\n        public String read(JsonReader in) throws IOException {\r\n            JsonToken peek = in.peek();\r\n            if (peek == JsonToken.NULL) {\r\n                in.nextNull();\r\n                return null;\r\n            }\r\n            /* coerce booleans to strings for backwards compatibility */\r\n            if (peek == JsonToken.BOOLEAN) {\r\n                return Boolean.toString(in.nextBoolean());\r\n            }\r\n            return in.nextString();\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, String value) throws IOException {\r\n            out.value(value);\r\n        }\r\n    };\r\n\r\n    public static final TypeAdapter<BigDecimal> BIG_DECIMAL = new TypeAdapter<BigDecimal>() {\r\n\r\n        @Override\r\n        public BigDecimal read(JsonReader in) throws IOException {\r\n            if (in.peek() == JsonToken.NULL) {\r\n                in.nextNull();\r\n                return null;\r\n            }\r\n            String s = in.nextString();\r\n            try {\r\n                return NumberLimits.parseBigDecimal(s);\r\n            } catch (NumberFormatException e) {\r\n                throw new JsonSyntaxException(\"Failed parsing '\" + s + \"' as BigDecimal; at path \" + in.getPreviousPath(), e);\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, BigDecimal value) throws IOException {\r\n            out.value(value);\r\n        }\r\n    };\r\n\r\n    public static final TypeAdapter<BigInteger> BIG_INTEGER = new TypeAdapter<BigInteger>() {\r\n\r\n        @Override\r\n        public BigInteger read(JsonReader in) throws IOException {\r\n            if (in.peek() == JsonToken.NULL) {\r\n                in.nextNull();\r\n                return null;\r\n            }\r\n            String s = in.nextString();\r\n            try {\r\n                return NumberLimits.parseBigInteger(s);\r\n            } catch (NumberFormatException e) {\r\n                throw new JsonSyntaxException(\"Failed parsing '\" + s + \"' as BigInteger; at path \" + in.getPreviousPath(), e);\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, BigInteger value) throws IOException {\r\n            out.value(value);\r\n        }\r\n    };\r\n\r\n    public static final TypeAdapter<LazilyParsedNumber> LAZILY_PARSED_NUMBER = new TypeAdapter<LazilyParsedNumber>() {\r\n\r\n        // Normally users should not be able to access and deserialize LazilyParsedNumber because\r\n        // it is an internal type, but implement this nonetheless in case there are legit corner\r\n        // cases where this is possible\r\n        @Override\r\n        public LazilyParsedNumber read(JsonReader in) throws IOException {\r\n            if (in.peek() == JsonToken.NULL) {\r\n                in.nextNull();\r\n                return null;\r\n            }\r\n            return new LazilyParsedNumber(in.nextString());\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, LazilyParsedNumber value) throws IOException {\r\n            out.value(value);\r\n        }\r\n    };\r\n\r\n    public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING);\r\n\r\n    public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<StringBuilder>() {\r\n\r\n        @Override\r\n        public StringBuilder read(JsonReader in) throws IOException {\r\n            if (in.peek() == JsonToken.NULL) {\r\n                in.nextNull();\r\n                return null;\r\n            }\r\n            return new StringBuilder(in.nextString());\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, StringBuilder value) throws IOException {\r\n            out.value(value == null ? null : value.toString());\r\n        }\r\n    };\r\n\r\n    public static final TypeAdapterFactory STRING_BUILDER_FACTORY = newFactory(StringBuilder.class, STRING_BUILDER);\r\n\r\n    public static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() {\r\n\r\n        @Override\r\n        public StringBuffer read(JsonReader in) throws IOException {\r\n            if (in.peek() == JsonToken.NULL) {\r\n                in.nextNull();\r\n                return null;\r\n            }\r\n            return new StringBuffer(in.nextString());\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, StringBuffer value) throws IOException {\r\n            out.value(value == null ? null : value.toString());\r\n        }\r\n    };\r\n\r\n    public static final TypeAdapterFactory STRING_BUFFER_FACTORY = newFactory(StringBuffer.class, STRING_BUFFER);\r\n\r\n    public static final TypeAdapter<URL> URL = new TypeAdapter<URL>() {\r\n\r\n        @Override\r\n        public URL read(JsonReader in) throws IOException {\r\n            if (in.peek() == JsonToken.NULL) {\r\n                in.nextNull();\r\n                return null;\r\n            }\r\n            String nextString = in.nextString();\r\n            return nextString.equals(\"null\") ? null : new URL(nextString);\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, URL value) throws IOException {\r\n            out.value(value == null ? null : value.toExternalForm());\r\n        }\r\n    };\r\n\r\n    public static final TypeAdapterFactory URL_FACTORY = newFactory(URL.class, URL);\r\n\r\n    public static final TypeAdapter<URI> URI = new TypeAdapter<URI>() {\r\n\r\n        @Override\r\n        public URI read(JsonReader in) throws IOException {\r\n            if (in.peek() == JsonToken.NULL) {\r\n                in.nextNull();\r\n                return null;\r\n            }\r\n            try {\r\n                String nextString = in.nextString();\r\n                return nextString.equals(\"null\") ? null : new URI(nextString);\r\n            } catch (URISyntaxException e) {\r\n                throw new JsonIOException(e);\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, URI value) throws IOException {\r\n            out.value(value == null ? null : value.toASCIIString());\r\n        }\r\n    };\r\n\r\n    public static final TypeAdapterFactory URI_FACTORY = newFactory(URI.class, URI);\r\n\r\n    public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<InetAddress>() {\r\n\r\n        @Override\r\n        public InetAddress read(JsonReader in) throws IOException {\r\n            if (in.peek() == JsonToken.NULL) {\r\n                in.nextNull();\r\n                return null;\r\n            }\r\n            // regrettably, this should have included both the host name and the host address\r\n            // For compatibility, we use InetAddress.getByName rather than the possibly-better\r\n            // .getAllByName\r\n            @SuppressWarnings(\"AddressSelection\")\r\n            InetAddress addr = InetAddress.getByName(in.nextString());\r\n            return addr;\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, InetAddress value) throws IOException {\r\n            out.value(value == null ? null : value.getHostAddress());\r\n        }\r\n    };\r\n\r\n    public static final TypeAdapterFactory INET_ADDRESS_FACTORY = newTypeHierarchyFactory(InetAddress.class, INET_ADDRESS);\r\n\r\n    public static final TypeAdapter<UUID> UUID = new TypeAdapter<UUID>() {\r\n\r\n        @Override\r\n        public UUID read(JsonReader in) throws IOException {\r\n            if (in.peek() == JsonToken.NULL) {\r\n                in.nextNull();\r\n                return null;\r\n            }\r\n            String s = in.nextString();\r\n            try {\r\n                return java.util.UUID.fromString(s);\r\n            } catch (IllegalArgumentException e) {\r\n                throw new JsonSyntaxException(\"Failed parsing '\" + s + \"' as UUID; at path \" + in.getPreviousPath(), e);\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, UUID value) throws IOException {\r\n            out.value(value == null ? null : value.toString());\r\n        }\r\n    };\r\n\r\n    public static final TypeAdapterFactory UUID_FACTORY = newFactory(UUID.class, UUID);\r\n\r\n    public static final TypeAdapter<Currency> CURRENCY = new TypeAdapter<Currency>() {\r\n\r\n        @Override\r\n        public Currency read(JsonReader in) throws IOException {\r\n            String s = in.nextString();\r\n            try {\r\n                return Currency.getInstance(s);\r\n            } catch (IllegalArgumentException e) {\r\n                throw new JsonSyntaxException(\"Failed parsing '\" + s + \"' as Currency; at path \" + in.getPreviousPath(), e);\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Currency value) throws IOException {\r\n            out.value(value.getCurrencyCode());\r\n        }\r\n    }.nullSafe();\r\n\r\n    public static final TypeAdapterFactory CURRENCY_FACTORY = newFactory(Currency.class, CURRENCY);\r\n\r\n    public static final TypeAdapter<Calendar> CALENDAR = new TypeAdapter<Calendar>() {\r\n\r\n        private static final String YEAR = \"year\";\r\n\r\n        private static final String MONTH = \"month\";\r\n\r\n        private static final String DAY_OF_MONTH = \"dayOfMonth\";\r\n\r\n        private static final String HOUR_OF_DAY = \"hourOfDay\";\r\n\r\n        private static final String MINUTE = \"minute\";\r\n\r\n        private static final String SECOND = \"second\";\r\n\r\n        @Override\r\n        public Calendar read(JsonReader in) throws IOException {\r\n            if (in.peek() == JsonToken.NULL) {\r\n                in.nextNull();\r\n                return null;\r\n            }\r\n            in.beginObject();\r\n            int year = 0;\r\n            int month = 0;\r\n            int dayOfMonth = 0;\r\n            int hourOfDay = 0;\r\n            int minute = 0;\r\n            int second = 0;\r\n            while (in.peek() != JsonToken.END_OBJECT) {\r\n                String name = in.nextName();\r\n                int value = in.nextInt();\r\n                switch(name) {\r\n                    case YEAR:\r\n                        year = value;\r\n                        break;\r\n                    case MONTH:\r\n                        month = value;\r\n                        break;\r\n                    case DAY_OF_MONTH:\r\n                        dayOfMonth = value;\r\n                        break;\r\n                    case HOUR_OF_DAY:\r\n                        hourOfDay = value;\r\n                        break;\r\n                    case MINUTE:\r\n                        minute = value;\r\n                        break;\r\n                    case SECOND:\r\n                        second = value;\r\n                        break;\r\n                    default:\r\n                }\r\n            }\r\n            in.endObject();\r\n            return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second);\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Calendar value) throws IOException {\r\n            if (value == null) {\r\n                out.nullValue();\r\n                return;\r\n            }\r\n            out.beginObject();\r\n            out.name(YEAR);\r\n            out.value(value.get(Calendar.YEAR));\r\n            out.name(MONTH);\r\n            out.value(value.get(Calendar.MONTH));\r\n            out.name(DAY_OF_MONTH);\r\n            out.value(value.get(Calendar.DAY_OF_MONTH));\r\n            out.name(HOUR_OF_DAY);\r\n            out.value(value.get(Calendar.HOUR_OF_DAY));\r\n            out.name(MINUTE);\r\n            out.value(value.get(Calendar.MINUTE));\r\n            out.name(SECOND);\r\n            out.value(value.get(Calendar.SECOND));\r\n            out.endObject();\r\n        }\r\n    };\r\n\r\n    public static final TypeAdapterFactory CALENDAR_FACTORY = newFactoryForMultipleTypes(Calendar.class, GregorianCalendar.class, CALENDAR);\r\n\r\n    public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() {\r\n\r\n        @Override\r\n        public Locale read(JsonReader in) throws IOException {\r\n            if (in.peek() == JsonToken.NULL) {\r\n                in.nextNull();\r\n                return null;\r\n            }\r\n            String locale = in.nextString();\r\n            StringTokenizer tokenizer = new StringTokenizer(locale, \"_\");\r\n            String language = null;\r\n            String country = null;\r\n            String variant = null;\r\n            if (tokenizer.hasMoreElements()) {\r\n                language = tokenizer.nextToken();\r\n            }\r\n            if (tokenizer.hasMoreElements()) {\r\n                country = tokenizer.nextToken();\r\n            }\r\n            if (tokenizer.hasMoreElements()) {\r\n                variant = tokenizer.nextToken();\r\n            }\r\n            if (country == null && variant == null) {\r\n                return new Locale(language);\r\n            } else if (variant == null) {\r\n                return new Locale(language, country);\r\n            } else {\r\n                return new Locale(language, country, variant);\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, Locale value) throws IOException {\r\n            out.value(value == null ? null : value.toString());\r\n        }\r\n    };\r\n\r\n    public static final TypeAdapterFactory LOCALE_FACTORY = newFactory(Locale.class, LOCALE);\r\n\r\n    public static final TypeAdapter<JsonElement> JSON_ELEMENT = JsonElementTypeAdapter.ADAPTER;\r\n\r\n    public static final TypeAdapterFactory JSON_ELEMENT_FACTORY = newTypeHierarchyFactory(JsonElement.class, JSON_ELEMENT);\r\n\r\n    public static final TypeAdapterFactory ENUM_FACTORY = EnumTypeAdapter.FACTORY;\r\n\r\n    @SuppressWarnings(\"TypeParameterNaming\")\r\n    public static <TT> TypeAdapterFactory newFactory(TypeToken<TT> type, TypeAdapter<TT> typeAdapter) {\r\n        return new TypeAdapterFactory() {\r\n\r\n            // we use a runtime check to make sure the 'T's equal\r\n            @SuppressWarnings(\"unchecked\")\r\n            @Override\r\n            public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\r\n                return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null;\r\n            }\r\n        };\r\n    }\r\n\r\n    @SuppressWarnings(\"TypeParameterNaming\")\r\n    public static <TT> TypeAdapterFactory newFactory(Class<TT> type, TypeAdapter<TT> typeAdapter) {\r\n        return new TypeAdapterFactory() {\r\n\r\n            // we use a runtime check to make sure the 'T's equal\r\n            @SuppressWarnings(\"unchecked\")\r\n            @Override\r\n            public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\r\n                return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\r\n            }\r\n\r\n            @Override\r\n            public String toString() {\r\n                return \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\r\n            }\r\n        };\r\n    }\r\n\r\n    @SuppressWarnings(\"TypeParameterNaming\")\r\n    public static <TT> TypeAdapterFactory newFactory(Class<TT> unboxed, Class<TT> boxed, TypeAdapter<? super TT> typeAdapter) {\r\n        return new TypeAdapterFactory() {\r\n\r\n            // we use a runtime check to make sure the 'T's equal\r\n            @SuppressWarnings(\"unchecked\")\r\n            @Override\r\n            public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\r\n                Class<? super T> rawType = typeToken.getRawType();\r\n                return (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\r\n            }\r\n\r\n            @Override\r\n            public String toString() {\r\n                return \"Factory[type=\" + boxed.getName() + \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\r\n            }\r\n        };\r\n    }\r\n\r\n    @SuppressWarnings(\"TypeParameterNaming\")\r\n    public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(Class<TT> base, Class<? extends TT> sub, TypeAdapter<? super TT> typeAdapter) {\r\n        return new TypeAdapterFactory() {\r\n\r\n            // we use a runtime check to make sure the 'T's equal\r\n            @SuppressWarnings(\"unchecked\")\r\n            @Override\r\n            public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\r\n                Class<? super T> rawType = typeToken.getRawType();\r\n                return (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\r\n            }\r\n\r\n            @Override\r\n            public String toString() {\r\n                return \"Factory[type=\" + base.getName() + \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Returns a factory for all subtypes of {@code typeAdapter}. We do a runtime check to confirm\r\n     * that the deserialized type matches the type requested.\r\n     */\r\n    public static <T1> TypeAdapterFactory newTypeHierarchyFactory(Class<T1> clazz, TypeAdapter<T1> typeAdapter) {\r\n        return new TypeAdapterFactory() {\r\n\r\n            @SuppressWarnings(\"unchecked\")\r\n            @Override\r\n            public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\r\n                Class<? super T2> requestedType = typeToken.getRawType();\r\n                if (!clazz.isAssignableFrom(requestedType)) {\r\n                    return null;\r\n                }\r\n                return (TypeAdapter<T2>) new TypeAdapter<T1>() {\r\n\r\n                    @Override\r\n                    public void write(JsonWriter out, T1 value) throws IOException {\r\n                        typeAdapter.write(out, value);\r\n                    }\r\n\r\n                    @Override\r\n                    public T1 read(JsonReader in) throws IOException {\r\n                        T1 result = typeAdapter.read(in);\r\n                        if (result != null && !requestedType.isInstance(result)) {\r\n                            throw new JsonSyntaxException(\"Expected a \" + requestedType.getName() + \" but was \" + result.getClass().getName() + \"; at path \" + in.getPreviousPath());\r\n                        }\r\n                        return result;\r\n                    }\r\n                };\r\n            }\r\n\r\n            @Override\r\n            public String toString() {\r\n                return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\r\n            }\r\n        };\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "CLASS",
    "start_line": 61,
    "end_line": 81,
    "code": "@SuppressWarnings(\"rawtypes\")\r\npublic static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {\r\n\r\n    @Override\r\n    public void write(JsonWriter out, Class value) throws IOException {\r\n        throw new UnsupportedOperationException(\"Attempted to serialize java.lang.Class: \" + value.getName() + \". Forgot to register a type adapter?\" + \"\\nSee \" + TroubleshootingGuide.createUrl(\"java-lang-class-unsupported\"));\r\n    }\r\n\r\n    @Override\r\n    public Class read(JsonReader in) throws IOException {\r\n        throw new UnsupportedOperationException(\"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\" + \"\\nSee \" + TroubleshootingGuide.createUrl(\"java-lang-class-unsupported\"));\r\n    }\r\n}.nullSafe();",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "CLASS_FACTORY",
    "start_line": 83,
    "end_line": 83,
    "code": "public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS);",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "BIT_SET",
    "start_line": 85,
    "end_line": 137,
    "code": "public static final TypeAdapter<BitSet> BIT_SET = new TypeAdapter<BitSet>() {\r\n\r\n    @Override\r\n    public BitSet read(JsonReader in) throws IOException {\r\n        BitSet bitset = new BitSet();\r\n        in.beginArray();\r\n        int i = 0;\r\n        JsonToken tokenType = in.peek();\r\n        while (tokenType != JsonToken.END_ARRAY) {\r\n            boolean set;\r\n            switch(tokenType) {\r\n                case NUMBER:\r\n                case STRING:\r\n                    int intValue = in.nextInt();\r\n                    if (intValue == 0) {\r\n                        set = false;\r\n                    } else if (intValue == 1) {\r\n                        set = true;\r\n                    } else {\r\n                        throw new JsonSyntaxException(\"Invalid bitset value \" + intValue + \", expected 0 or 1; at path \" + in.getPreviousPath());\r\n                    }\r\n                    break;\r\n                case BOOLEAN:\r\n                    set = in.nextBoolean();\r\n                    break;\r\n                default:\r\n                    throw new JsonSyntaxException(\"Invalid bitset value type: \" + tokenType + \"; at path \" + in.getPath());\r\n            }\r\n            if (set) {\r\n                bitset.set(i);\r\n            }\r\n            ++i;\r\n            tokenType = in.peek();\r\n        }\r\n        in.endArray();\r\n        return bitset;\r\n    }\r\n\r\n    @Override\r\n    public void write(JsonWriter out, BitSet src) throws IOException {\r\n        out.beginArray();\r\n        for (int i = 0, length = src.length(); i < length; i++) {\r\n            int value = src.get(i) ? 1 : 0;\r\n            out.value(value);\r\n        }\r\n        out.endArray();\r\n    }\r\n}.nullSafe();",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "BIT_SET_FACTORY",
    "start_line": 139,
    "end_line": 139,
    "code": "public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET);",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "BOOLEAN",
    "start_line": 141,
    "end_line": 160,
    "code": "public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() {\r\n\r\n    @Override\r\n    public Boolean read(JsonReader in) throws IOException {\r\n        JsonToken peek = in.peek();\r\n        if (peek == JsonToken.NULL) {\r\n            in.nextNull();\r\n            return null;\r\n        } else if (peek == JsonToken.STRING) {\r\n            // support strings for compatibility with GSON 1.7\r\n            return Boolean.parseBoolean(in.nextString());\r\n        }\r\n        return in.nextBoolean();\r\n    }\r\n\r\n    @Override\r\n    public void write(JsonWriter out, Boolean value) throws IOException {\r\n        out.value(value);\r\n    }\r\n};",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "BOOLEAN_AS_STRING",
    "start_line": 165,
    "end_line": 180,
    "code": "/**\r\n * Writes a boolean as a string. Useful for map keys, where booleans aren't otherwise permitted.\r\n */\r\npublic static final TypeAdapter<Boolean> BOOLEAN_AS_STRING = new TypeAdapter<Boolean>() {\r\n\r\n    @Override\r\n    public Boolean read(JsonReader in) throws IOException {\r\n        if (in.peek() == JsonToken.NULL) {\r\n            in.nextNull();\r\n            return null;\r\n        }\r\n        return Boolean.valueOf(in.nextString());\r\n    }\r\n\r\n    @Override\r\n    public void write(JsonWriter out, Boolean value) throws IOException {\r\n        out.value(value == null ? \"null\" : value.toString());\r\n    }\r\n};",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "BOOLEAN_FACTORY",
    "start_line": 182,
    "end_line": 183,
    "code": "public static final TypeAdapterFactory BOOLEAN_FACTORY = newFactory(boolean.class, Boolean.class, BOOLEAN);",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "BYTE",
    "start_line": 185,
    "end_line": 216,
    "code": "public static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() {\r\n\r\n    @Override\r\n    public Number read(JsonReader in) throws IOException {\r\n        if (in.peek() == JsonToken.NULL) {\r\n            in.nextNull();\r\n            return null;\r\n        }\r\n        int intValue;\r\n        try {\r\n            intValue = in.nextInt();\r\n        } catch (NumberFormatException e) {\r\n            throw new JsonSyntaxException(e);\r\n        }\r\n        // Allow up to 255 to support unsigned values\r\n        if (intValue > 255 || intValue < Byte.MIN_VALUE) {\r\n            throw new JsonSyntaxException(\"Lossy conversion from \" + intValue + \" to byte; at path \" + in.getPreviousPath());\r\n        }\r\n        return (byte) intValue;\r\n    }\r\n\r\n    @Override\r\n    public void write(JsonWriter out, Number value) throws IOException {\r\n        if (value == null) {\r\n            out.nullValue();\r\n        } else {\r\n            out.value(value.byteValue());\r\n        }\r\n    }\r\n};",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "BYTE_FACTORY",
    "start_line": 218,
    "end_line": 218,
    "code": "public static final TypeAdapterFactory BYTE_FACTORY = newFactory(byte.class, Byte.class, BYTE);",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "SHORT",
    "start_line": 220,
    "end_line": 251,
    "code": "public static final TypeAdapter<Number> SHORT = new TypeAdapter<Number>() {\r\n\r\n    @Override\r\n    public Number read(JsonReader in) throws IOException {\r\n        if (in.peek() == JsonToken.NULL) {\r\n            in.nextNull();\r\n            return null;\r\n        }\r\n        int intValue;\r\n        try {\r\n            intValue = in.nextInt();\r\n        } catch (NumberFormatException e) {\r\n            throw new JsonSyntaxException(e);\r\n        }\r\n        // Allow up to 65535 to support unsigned values\r\n        if (intValue > 65535 || intValue < Short.MIN_VALUE) {\r\n            throw new JsonSyntaxException(\"Lossy conversion from \" + intValue + \" to short; at path \" + in.getPreviousPath());\r\n        }\r\n        return (short) intValue;\r\n    }\r\n\r\n    @Override\r\n    public void write(JsonWriter out, Number value) throws IOException {\r\n        if (value == null) {\r\n            out.nullValue();\r\n        } else {\r\n            out.value(value.shortValue());\r\n        }\r\n    }\r\n};",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "SHORT_FACTORY",
    "start_line": 253,
    "end_line": 254,
    "code": "public static final TypeAdapterFactory SHORT_FACTORY = newFactory(short.class, Short.class, SHORT);",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "INTEGER",
    "start_line": 256,
    "end_line": 279,
    "code": "public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() {\r\n\r\n    @Override\r\n    public Number read(JsonReader in) throws IOException {\r\n        if (in.peek() == JsonToken.NULL) {\r\n            in.nextNull();\r\n            return null;\r\n        }\r\n        try {\r\n            return in.nextInt();\r\n        } catch (NumberFormatException e) {\r\n            throw new JsonSyntaxException(e);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void write(JsonWriter out, Number value) throws IOException {\r\n        if (value == null) {\r\n            out.nullValue();\r\n        } else {\r\n            out.value(value.intValue());\r\n        }\r\n    }\r\n};",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "INTEGER_FACTORY",
    "start_line": 280,
    "end_line": 281,
    "code": "public static final TypeAdapterFactory INTEGER_FACTORY = newFactory(int.class, Integer.class, INTEGER);",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "ATOMIC_INTEGER",
    "start_line": 283,
    "end_line": 298,
    "code": "public static final TypeAdapter<AtomicInteger> ATOMIC_INTEGER = new TypeAdapter<AtomicInteger>() {\r\n\r\n    @Override\r\n    public AtomicInteger read(JsonReader in) throws IOException {\r\n        try {\r\n            return new AtomicInteger(in.nextInt());\r\n        } catch (NumberFormatException e) {\r\n            throw new JsonSyntaxException(e);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void write(JsonWriter out, AtomicInteger value) throws IOException {\r\n        out.value(value.get());\r\n    }\r\n}.nullSafe();",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "ATOMIC_INTEGER_FACTORY",
    "start_line": 299,
    "end_line": 300,
    "code": "public static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY = newFactory(AtomicInteger.class, TypeAdapters.ATOMIC_INTEGER);",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "ATOMIC_BOOLEAN",
    "start_line": 302,
    "end_line": 313,
    "code": "public static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN = new TypeAdapter<AtomicBoolean>() {\r\n\r\n    @Override\r\n    public AtomicBoolean read(JsonReader in) throws IOException {\r\n        return new AtomicBoolean(in.nextBoolean());\r\n    }\r\n\r\n    @Override\r\n    public void write(JsonWriter out, AtomicBoolean value) throws IOException {\r\n        out.value(value.get());\r\n    }\r\n}.nullSafe();",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "ATOMIC_BOOLEAN_FACTORY",
    "start_line": 314,
    "end_line": 315,
    "code": "public static final TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY = newFactory(AtomicBoolean.class, TypeAdapters.ATOMIC_BOOLEAN);",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "ATOMIC_INTEGER_ARRAY",
    "start_line": 317,
    "end_line": 348,
    "code": "public static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY = new TypeAdapter<AtomicIntegerArray>() {\r\n\r\n    @Override\r\n    public AtomicIntegerArray read(JsonReader in) throws IOException {\r\n        List<Integer> list = new ArrayList<>();\r\n        in.beginArray();\r\n        while (in.hasNext()) {\r\n            try {\r\n                int integer = in.nextInt();\r\n                list.add(integer);\r\n            } catch (NumberFormatException e) {\r\n                throw new JsonSyntaxException(e);\r\n            }\r\n        }\r\n        in.endArray();\r\n        int length = list.size();\r\n        AtomicIntegerArray array = new AtomicIntegerArray(length);\r\n        for (int i = 0; i < length; ++i) {\r\n            array.set(i, list.get(i));\r\n        }\r\n        return array;\r\n    }\r\n\r\n    @Override\r\n    public void write(JsonWriter out, AtomicIntegerArray value) throws IOException {\r\n        out.beginArray();\r\n        for (int i = 0, length = value.length(); i < length; i++) {\r\n            out.value(value.get(i));\r\n        }\r\n        out.endArray();\r\n    }\r\n}.nullSafe();",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "ATOMIC_INTEGER_ARRAY_FACTORY",
    "start_line": 349,
    "end_line": 350,
    "code": "public static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY = newFactory(AtomicIntegerArray.class, TypeAdapters.ATOMIC_INTEGER_ARRAY);",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "LONG",
    "start_line": 352,
    "end_line": 375,
    "code": "public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() {\r\n\r\n    @Override\r\n    public Number read(JsonReader in) throws IOException {\r\n        if (in.peek() == JsonToken.NULL) {\r\n            in.nextNull();\r\n            return null;\r\n        }\r\n        try {\r\n            return in.nextLong();\r\n        } catch (NumberFormatException e) {\r\n            throw new JsonSyntaxException(e);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void write(JsonWriter out, Number value) throws IOException {\r\n        if (value == null) {\r\n            out.nullValue();\r\n        } else {\r\n            out.value(value.longValue());\r\n        }\r\n    }\r\n};",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "FLOAT",
    "start_line": 377,
    "end_line": 400,
    "code": "public static final TypeAdapter<Number> FLOAT = new TypeAdapter<Number>() {\r\n\r\n    @Override\r\n    public Number read(JsonReader in) throws IOException {\r\n        if (in.peek() == JsonToken.NULL) {\r\n            in.nextNull();\r\n            return null;\r\n        }\r\n        return (float) in.nextDouble();\r\n    }\r\n\r\n    @Override\r\n    public void write(JsonWriter out, Number value) throws IOException {\r\n        if (value == null) {\r\n            out.nullValue();\r\n        } else {\r\n            // For backward compatibility don't call `JsonWriter.value(float)` because that method\r\n            // has been newly added and not all custom JsonWriter implementations might override\r\n            // it yet\r\n            Number floatNumber = value instanceof Float ? value : value.floatValue();\r\n            out.value(floatNumber);\r\n        }\r\n    }\r\n};",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "DOUBLE",
    "start_line": 402,
    "end_line": 421,
    "code": "public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() {\r\n\r\n    @Override\r\n    public Number read(JsonReader in) throws IOException {\r\n        if (in.peek() == JsonToken.NULL) {\r\n            in.nextNull();\r\n            return null;\r\n        }\r\n        return in.nextDouble();\r\n    }\r\n\r\n    @Override\r\n    public void write(JsonWriter out, Number value) throws IOException {\r\n        if (value == null) {\r\n            out.nullValue();\r\n        } else {\r\n            out.value(value.doubleValue());\r\n        }\r\n    }\r\n};",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "CHARACTER",
    "start_line": 423,
    "end_line": 443,
    "code": "public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() {\r\n\r\n    @Override\r\n    public Character read(JsonReader in) throws IOException {\r\n        if (in.peek() == JsonToken.NULL) {\r\n            in.nextNull();\r\n            return null;\r\n        }\r\n        String str = in.nextString();\r\n        if (str.length() != 1) {\r\n            throw new JsonSyntaxException(\"Expecting character, got: \" + str + \"; at \" + in.getPreviousPath());\r\n        }\r\n        return str.charAt(0);\r\n    }\r\n\r\n    @Override\r\n    public void write(JsonWriter out, Character value) throws IOException {\r\n        out.value(value == null ? null : String.valueOf(value));\r\n    }\r\n};",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "CHARACTER_FACTORY",
    "start_line": 445,
    "end_line": 446,
    "code": "public static final TypeAdapterFactory CHARACTER_FACTORY = newFactory(char.class, Character.class, CHARACTER);",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "STRING",
    "start_line": 448,
    "end_line": 468,
    "code": "public static final TypeAdapter<String> STRING = new TypeAdapter<String>() {\r\n\r\n    @Override\r\n    public String read(JsonReader in) throws IOException {\r\n        JsonToken peek = in.peek();\r\n        if (peek == JsonToken.NULL) {\r\n            in.nextNull();\r\n            return null;\r\n        }\r\n        /* coerce booleans to strings for backwards compatibility */\r\n        if (peek == JsonToken.BOOLEAN) {\r\n            return Boolean.toString(in.nextBoolean());\r\n        }\r\n        return in.nextString();\r\n    }\r\n\r\n    @Override\r\n    public void write(JsonWriter out, String value) throws IOException {\r\n        out.value(value);\r\n    }\r\n};",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "BIG_DECIMAL",
    "start_line": 470,
    "end_line": 491,
    "code": "public static final TypeAdapter<BigDecimal> BIG_DECIMAL = new TypeAdapter<BigDecimal>() {\r\n\r\n    @Override\r\n    public BigDecimal read(JsonReader in) throws IOException {\r\n        if (in.peek() == JsonToken.NULL) {\r\n            in.nextNull();\r\n            return null;\r\n        }\r\n        String s = in.nextString();\r\n        try {\r\n            return NumberLimits.parseBigDecimal(s);\r\n        } catch (NumberFormatException e) {\r\n            throw new JsonSyntaxException(\"Failed parsing '\" + s + \"' as BigDecimal; at path \" + in.getPreviousPath(), e);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void write(JsonWriter out, BigDecimal value) throws IOException {\r\n        out.value(value);\r\n    }\r\n};",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "BIG_INTEGER",
    "start_line": 493,
    "end_line": 514,
    "code": "public static final TypeAdapter<BigInteger> BIG_INTEGER = new TypeAdapter<BigInteger>() {\r\n\r\n    @Override\r\n    public BigInteger read(JsonReader in) throws IOException {\r\n        if (in.peek() == JsonToken.NULL) {\r\n            in.nextNull();\r\n            return null;\r\n        }\r\n        String s = in.nextString();\r\n        try {\r\n            return NumberLimits.parseBigInteger(s);\r\n        } catch (NumberFormatException e) {\r\n            throw new JsonSyntaxException(\"Failed parsing '\" + s + \"' as BigInteger; at path \" + in.getPreviousPath(), e);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void write(JsonWriter out, BigInteger value) throws IOException {\r\n        out.value(value);\r\n    }\r\n};",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "LAZILY_PARSED_NUMBER",
    "start_line": 516,
    "end_line": 534,
    "code": "public static final TypeAdapter<LazilyParsedNumber> LAZILY_PARSED_NUMBER = new TypeAdapter<LazilyParsedNumber>() {\r\n\r\n    // Normally users should not be able to access and deserialize LazilyParsedNumber because\r\n    // it is an internal type, but implement this nonetheless in case there are legit corner\r\n    // cases where this is possible\r\n    @Override\r\n    public LazilyParsedNumber read(JsonReader in) throws IOException {\r\n        if (in.peek() == JsonToken.NULL) {\r\n            in.nextNull();\r\n            return null;\r\n        }\r\n        return new LazilyParsedNumber(in.nextString());\r\n    }\r\n\r\n    @Override\r\n    public void write(JsonWriter out, LazilyParsedNumber value) throws IOException {\r\n        out.value(value);\r\n    }\r\n};",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "STRING_FACTORY",
    "start_line": 536,
    "end_line": 536,
    "code": "public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING);",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "STRING_BUILDER",
    "start_line": 538,
    "end_line": 553,
    "code": "public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<StringBuilder>() {\r\n\r\n    @Override\r\n    public StringBuilder read(JsonReader in) throws IOException {\r\n        if (in.peek() == JsonToken.NULL) {\r\n            in.nextNull();\r\n            return null;\r\n        }\r\n        return new StringBuilder(in.nextString());\r\n    }\r\n\r\n    @Override\r\n    public void write(JsonWriter out, StringBuilder value) throws IOException {\r\n        out.value(value == null ? null : value.toString());\r\n    }\r\n};",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "STRING_BUILDER_FACTORY",
    "start_line": 555,
    "end_line": 556,
    "code": "public static final TypeAdapterFactory STRING_BUILDER_FACTORY = newFactory(StringBuilder.class, STRING_BUILDER);",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "STRING_BUFFER",
    "start_line": 558,
    "end_line": 573,
    "code": "public static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() {\r\n\r\n    @Override\r\n    public StringBuffer read(JsonReader in) throws IOException {\r\n        if (in.peek() == JsonToken.NULL) {\r\n            in.nextNull();\r\n            return null;\r\n        }\r\n        return new StringBuffer(in.nextString());\r\n    }\r\n\r\n    @Override\r\n    public void write(JsonWriter out, StringBuffer value) throws IOException {\r\n        out.value(value == null ? null : value.toString());\r\n    }\r\n};",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "STRING_BUFFER_FACTORY",
    "start_line": 575,
    "end_line": 576,
    "code": "public static final TypeAdapterFactory STRING_BUFFER_FACTORY = newFactory(StringBuffer.class, STRING_BUFFER);",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "URL",
    "start_line": 578,
    "end_line": 594,
    "code": "public static final TypeAdapter<URL> URL = new TypeAdapter<URL>() {\r\n\r\n    @Override\r\n    public URL read(JsonReader in) throws IOException {\r\n        if (in.peek() == JsonToken.NULL) {\r\n            in.nextNull();\r\n            return null;\r\n        }\r\n        String nextString = in.nextString();\r\n        return nextString.equals(\"null\") ? null : new URL(nextString);\r\n    }\r\n\r\n    @Override\r\n    public void write(JsonWriter out, URL value) throws IOException {\r\n        out.value(value == null ? null : value.toExternalForm());\r\n    }\r\n};",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "URL_FACTORY",
    "start_line": 596,
    "end_line": 596,
    "code": "public static final TypeAdapterFactory URL_FACTORY = newFactory(URL.class, URL);",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "URI",
    "start_line": 598,
    "end_line": 618,
    "code": "public static final TypeAdapter<URI> URI = new TypeAdapter<URI>() {\r\n\r\n    @Override\r\n    public URI read(JsonReader in) throws IOException {\r\n        if (in.peek() == JsonToken.NULL) {\r\n            in.nextNull();\r\n            return null;\r\n        }\r\n        try {\r\n            String nextString = in.nextString();\r\n            return nextString.equals(\"null\") ? null : new URI(nextString);\r\n        } catch (URISyntaxException e) {\r\n            throw new JsonIOException(e);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void write(JsonWriter out, URI value) throws IOException {\r\n        out.value(value == null ? null : value.toASCIIString());\r\n    }\r\n};",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "URI_FACTORY",
    "start_line": 620,
    "end_line": 620,
    "code": "public static final TypeAdapterFactory URI_FACTORY = newFactory(URI.class, URI);",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "INET_ADDRESS",
    "start_line": 622,
    "end_line": 642,
    "code": "public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<InetAddress>() {\r\n\r\n    @Override\r\n    public InetAddress read(JsonReader in) throws IOException {\r\n        if (in.peek() == JsonToken.NULL) {\r\n            in.nextNull();\r\n            return null;\r\n        }\r\n        // regrettably, this should have included both the host name and the host address\r\n        // For compatibility, we use InetAddress.getByName rather than the possibly-better\r\n        // .getAllByName\r\n        @SuppressWarnings(\"AddressSelection\")\r\n        InetAddress addr = InetAddress.getByName(in.nextString());\r\n        return addr;\r\n    }\r\n\r\n    @Override\r\n    public void write(JsonWriter out, InetAddress value) throws IOException {\r\n        out.value(value == null ? null : value.getHostAddress());\r\n    }\r\n};",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "INET_ADDRESS_FACTORY",
    "start_line": 644,
    "end_line": 645,
    "code": "public static final TypeAdapterFactory INET_ADDRESS_FACTORY = newTypeHierarchyFactory(InetAddress.class, INET_ADDRESS);",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "UUID",
    "start_line": 647,
    "end_line": 668,
    "code": "public static final TypeAdapter<UUID> UUID = new TypeAdapter<UUID>() {\r\n\r\n    @Override\r\n    public UUID read(JsonReader in) throws IOException {\r\n        if (in.peek() == JsonToken.NULL) {\r\n            in.nextNull();\r\n            return null;\r\n        }\r\n        String s = in.nextString();\r\n        try {\r\n            return java.util.UUID.fromString(s);\r\n        } catch (IllegalArgumentException e) {\r\n            throw new JsonSyntaxException(\"Failed parsing '\" + s + \"' as UUID; at path \" + in.getPreviousPath(), e);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void write(JsonWriter out, UUID value) throws IOException {\r\n        out.value(value == null ? null : value.toString());\r\n    }\r\n};",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "UUID_FACTORY",
    "start_line": 670,
    "end_line": 670,
    "code": "public static final TypeAdapterFactory UUID_FACTORY = newFactory(UUID.class, UUID);",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "CURRENCY",
    "start_line": 672,
    "end_line": 689,
    "code": "public static final TypeAdapter<Currency> CURRENCY = new TypeAdapter<Currency>() {\r\n\r\n    @Override\r\n    public Currency read(JsonReader in) throws IOException {\r\n        String s = in.nextString();\r\n        try {\r\n            return Currency.getInstance(s);\r\n        } catch (IllegalArgumentException e) {\r\n            throw new JsonSyntaxException(\"Failed parsing '\" + s + \"' as Currency; at path \" + in.getPreviousPath(), e);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void write(JsonWriter out, Currency value) throws IOException {\r\n        out.value(value.getCurrencyCode());\r\n    }\r\n}.nullSafe();",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "CURRENCY_FACTORY",
    "start_line": 690,
    "end_line": 690,
    "code": "public static final TypeAdapterFactory CURRENCY_FACTORY = newFactory(Currency.class, CURRENCY);",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "CALENDAR",
    "start_line": 692,
    "end_line": 765,
    "code": "public static final TypeAdapter<Calendar> CALENDAR = new TypeAdapter<Calendar>() {\r\n\r\n    private static final String YEAR = \"year\";\r\n\r\n    private static final String MONTH = \"month\";\r\n\r\n    private static final String DAY_OF_MONTH = \"dayOfMonth\";\r\n\r\n    private static final String HOUR_OF_DAY = \"hourOfDay\";\r\n\r\n    private static final String MINUTE = \"minute\";\r\n\r\n    private static final String SECOND = \"second\";\r\n\r\n    @Override\r\n    public Calendar read(JsonReader in) throws IOException {\r\n        if (in.peek() == JsonToken.NULL) {\r\n            in.nextNull();\r\n            return null;\r\n        }\r\n        in.beginObject();\r\n        int year = 0;\r\n        int month = 0;\r\n        int dayOfMonth = 0;\r\n        int hourOfDay = 0;\r\n        int minute = 0;\r\n        int second = 0;\r\n        while (in.peek() != JsonToken.END_OBJECT) {\r\n            String name = in.nextName();\r\n            int value = in.nextInt();\r\n            switch(name) {\r\n                case YEAR:\r\n                    year = value;\r\n                    break;\r\n                case MONTH:\r\n                    month = value;\r\n                    break;\r\n                case DAY_OF_MONTH:\r\n                    dayOfMonth = value;\r\n                    break;\r\n                case HOUR_OF_DAY:\r\n                    hourOfDay = value;\r\n                    break;\r\n                case MINUTE:\r\n                    minute = value;\r\n                    break;\r\n                case SECOND:\r\n                    second = value;\r\n                    break;\r\n                default:\r\n            }\r\n        }\r\n        in.endObject();\r\n        return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second);\r\n    }\r\n\r\n    @Override\r\n    public void write(JsonWriter out, Calendar value) throws IOException {\r\n        if (value == null) {\r\n            out.nullValue();\r\n            return;\r\n        }\r\n        out.beginObject();\r\n        out.name(YEAR);\r\n        out.value(value.get(Calendar.YEAR));\r\n        out.name(MONTH);\r\n        out.value(value.get(Calendar.MONTH));\r\n        out.name(DAY_OF_MONTH);\r\n        out.value(value.get(Calendar.DAY_OF_MONTH));\r\n        out.name(HOUR_OF_DAY);\r\n        out.value(value.get(Calendar.HOUR_OF_DAY));\r\n        out.name(MINUTE);\r\n        out.value(value.get(Calendar.MINUTE));\r\n        out.name(SECOND);\r\n        out.value(value.get(Calendar.SECOND));\r\n        out.endObject();\r\n    }\r\n};",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "CALENDAR_FACTORY",
    "start_line": 767,
    "end_line": 768,
    "code": "public static final TypeAdapterFactory CALENDAR_FACTORY = newFactoryForMultipleTypes(Calendar.class, GregorianCalendar.class, CALENDAR);",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "LOCALE",
    "start_line": 770,
    "end_line": 805,
    "code": "public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() {\r\n\r\n    @Override\r\n    public Locale read(JsonReader in) throws IOException {\r\n        if (in.peek() == JsonToken.NULL) {\r\n            in.nextNull();\r\n            return null;\r\n        }\r\n        String locale = in.nextString();\r\n        StringTokenizer tokenizer = new StringTokenizer(locale, \"_\");\r\n        String language = null;\r\n        String country = null;\r\n        String variant = null;\r\n        if (tokenizer.hasMoreElements()) {\r\n            language = tokenizer.nextToken();\r\n        }\r\n        if (tokenizer.hasMoreElements()) {\r\n            country = tokenizer.nextToken();\r\n        }\r\n        if (tokenizer.hasMoreElements()) {\r\n            variant = tokenizer.nextToken();\r\n        }\r\n        if (country == null && variant == null) {\r\n            return new Locale(language);\r\n        } else if (variant == null) {\r\n            return new Locale(language, country);\r\n        } else {\r\n            return new Locale(language, country, variant);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void write(JsonWriter out, Locale value) throws IOException {\r\n        out.value(value == null ? null : value.toString());\r\n    }\r\n};",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "LOCALE_FACTORY",
    "start_line": 807,
    "end_line": 807,
    "code": "public static final TypeAdapterFactory LOCALE_FACTORY = newFactory(Locale.class, LOCALE);",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "JSON_ELEMENT",
    "start_line": 809,
    "end_line": 809,
    "code": "public static final TypeAdapter<JsonElement> JSON_ELEMENT = JsonElementTypeAdapter.ADAPTER;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "JSON_ELEMENT_FACTORY",
    "start_line": 811,
    "end_line": 812,
    "code": "public static final TypeAdapterFactory JSON_ELEMENT_FACTORY = newTypeHierarchyFactory(JsonElement.class, JSON_ELEMENT);",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "field",
    "name": "ENUM_FACTORY",
    "start_line": 814,
    "end_line": 814,
    "code": "public static final TypeAdapterFactory ENUM_FACTORY = EnumTypeAdapter.FACTORY;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "constructor",
    "name": "TypeAdapters",
    "start_line": 57,
    "end_line": 59,
    "code": "private TypeAdapters() {\r\n    throw new UnsupportedOperationException();\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "method",
    "name": "newFactory",
    "start_line": 816,
    "end_line": 826,
    "code": "@SuppressWarnings(\"TypeParameterNaming\")\r\npublic static <TT> TypeAdapterFactory newFactory(TypeToken<TT> type, TypeAdapter<TT> typeAdapter) {\r\n    return new TypeAdapterFactory() {\r\n\r\n        // we use a runtime check to make sure the 'T's equal\r\n        @SuppressWarnings(\"unchecked\")\r\n        @Override\r\n        public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\r\n            return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null;\r\n        }\r\n    };\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "method",
    "name": "newFactory",
    "start_line": 828,
    "end_line": 842,
    "code": "@SuppressWarnings(\"TypeParameterNaming\")\r\npublic static <TT> TypeAdapterFactory newFactory(Class<TT> type, TypeAdapter<TT> typeAdapter) {\r\n    return new TypeAdapterFactory() {\r\n\r\n        // we use a runtime check to make sure the 'T's equal\r\n        @SuppressWarnings(\"unchecked\")\r\n        @Override\r\n        public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\r\n            return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\r\n        }\r\n    };\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "method",
    "name": "newFactory",
    "start_line": 844,
    "end_line": 866,
    "code": "@SuppressWarnings(\"TypeParameterNaming\")\r\npublic static <TT> TypeAdapterFactory newFactory(Class<TT> unboxed, Class<TT> boxed, TypeAdapter<? super TT> typeAdapter) {\r\n    return new TypeAdapterFactory() {\r\n\r\n        // we use a runtime check to make sure the 'T's equal\r\n        @SuppressWarnings(\"unchecked\")\r\n        @Override\r\n        public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\r\n            Class<? super T> rawType = typeToken.getRawType();\r\n            return (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"Factory[type=\" + boxed.getName() + \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\r\n        }\r\n    };\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "method",
    "name": "newFactoryForMultipleTypes",
    "start_line": 868,
    "end_line": 890,
    "code": "@SuppressWarnings(\"TypeParameterNaming\")\r\npublic static <TT> TypeAdapterFactory newFactoryForMultipleTypes(Class<TT> base, Class<? extends TT> sub, TypeAdapter<? super TT> typeAdapter) {\r\n    return new TypeAdapterFactory() {\r\n\r\n        // we use a runtime check to make sure the 'T's equal\r\n        @SuppressWarnings(\"unchecked\")\r\n        @Override\r\n        public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\r\n            Class<? super T> rawType = typeToken.getRawType();\r\n            return (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"Factory[type=\" + base.getName() + \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\r\n        }\r\n    };\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  },
  {
    "type": "method",
    "name": "newTypeHierarchyFactory",
    "start_line": 896,
    "end_line": 935,
    "code": "/**\r\n * Returns a factory for all subtypes of {@code typeAdapter}. We do a runtime check to confirm\r\n * that the deserialized type matches the type requested.\r\n */\r\npublic static <T1> TypeAdapterFactory newTypeHierarchyFactory(Class<T1> clazz, TypeAdapter<T1> typeAdapter) {\r\n    return new TypeAdapterFactory() {\r\n\r\n        @SuppressWarnings(\"unchecked\")\r\n        @Override\r\n        public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\r\n            Class<? super T2> requestedType = typeToken.getRawType();\r\n            if (!clazz.isAssignableFrom(requestedType)) {\r\n                return null;\r\n            }\r\n            return (TypeAdapter<T2>) new TypeAdapter<T1>() {\r\n\r\n                @Override\r\n                public void write(JsonWriter out, T1 value) throws IOException {\r\n                    typeAdapter.write(out, value);\r\n                }\r\n\r\n                @Override\r\n                public T1 read(JsonReader in) throws IOException {\r\n                    T1 result = typeAdapter.read(in);\r\n                    if (result != null && !requestedType.isInstance(result)) {\r\n                        throw new JsonSyntaxException(\"Expected a \" + requestedType.getName() + \" but was \" + result.getClass().getName() + \"; at path \" + in.getPreviousPath());\r\n                    }\r\n                    return result;\r\n                }\r\n            };\r\n        }\r\n\r\n        @Override\r\n        public String toString() {\r\n            return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\r\n        }\r\n    };\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\TypeAdapters.java"
  }
]