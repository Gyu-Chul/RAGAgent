[
  {
    "type": "package",
    "name": "com.google.gson.internal.bind",
    "start_line": 17,
    "end_line": 17,
    "code": "package com.google.gson.internal.bind;\r\n\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\JsonAdapterAnnotationTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.Gson",
    "start_line": 19,
    "end_line": 19,
    "code": "import com.google.gson.Gson;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\JsonAdapterAnnotationTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.JsonDeserializer",
    "start_line": 20,
    "end_line": 20,
    "code": "import com.google.gson.JsonDeserializer;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\JsonAdapterAnnotationTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.JsonSerializer",
    "start_line": 21,
    "end_line": 21,
    "code": "import com.google.gson.JsonSerializer;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\JsonAdapterAnnotationTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.TypeAdapter",
    "start_line": 22,
    "end_line": 22,
    "code": "import com.google.gson.TypeAdapter;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\JsonAdapterAnnotationTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.TypeAdapterFactory",
    "start_line": 23,
    "end_line": 23,
    "code": "import com.google.gson.TypeAdapterFactory;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\JsonAdapterAnnotationTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.annotations.JsonAdapter",
    "start_line": 24,
    "end_line": 24,
    "code": "import com.google.gson.annotations.JsonAdapter;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\JsonAdapterAnnotationTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.internal.ConstructorConstructor",
    "start_line": 25,
    "end_line": 25,
    "code": "import com.google.gson.internal.ConstructorConstructor;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\JsonAdapterAnnotationTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.reflect.TypeToken",
    "start_line": 26,
    "end_line": 26,
    "code": "import com.google.gson.reflect.TypeToken;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\JsonAdapterAnnotationTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "java.util.Objects",
    "start_line": 27,
    "end_line": 27,
    "code": "import java.util.Objects;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\JsonAdapterAnnotationTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "java.util.concurrent.ConcurrentHashMap",
    "start_line": 28,
    "end_line": 28,
    "code": "import java.util.concurrent.ConcurrentHashMap;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\JsonAdapterAnnotationTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "java.util.concurrent.ConcurrentMap",
    "start_line": 29,
    "end_line": 29,
    "code": "import java.util.concurrent.ConcurrentMap;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\JsonAdapterAnnotationTypeAdapterFactory.java"
  },
  {
    "type": "class",
    "name": "JsonAdapterAnnotationTypeAdapterFactory",
    "start_line": 37,
    "end_line": 204,
    "code": "/**\r\n * Given a type T, looks for the annotation {@link JsonAdapter} and uses an instance of the\r\n * specified class as the default type adapter.\r\n *\r\n * @since 2.3\r\n */\r\npublic final class JsonAdapterAnnotationTypeAdapterFactory implements TypeAdapterFactory {\r\n\r\n    private static class DummyTypeAdapterFactory implements TypeAdapterFactory {\r\n\r\n        @Override\r\n        public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\r\n            throw new AssertionError(\"Factory should not be used\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Factory used for {@link TreeTypeAdapter}s created for {@code @JsonAdapter} on a class.\r\n     */\r\n    private static final TypeAdapterFactory TREE_TYPE_CLASS_DUMMY_FACTORY = new DummyTypeAdapterFactory();\r\n\r\n    /**\r\n     * Factory used for {@link TreeTypeAdapter}s created for {@code @JsonAdapter} on a field.\r\n     */\r\n    private static final TypeAdapterFactory TREE_TYPE_FIELD_DUMMY_FACTORY = new DummyTypeAdapterFactory();\r\n\r\n    private final ConstructorConstructor constructorConstructor;\r\n\r\n    /**\r\n     * For a class, if it is annotated with {@code @JsonAdapter} and refers to a {@link\r\n     * TypeAdapterFactory}, stores the factory instance in case it has been requested already. Has to\r\n     * be a {@link ConcurrentMap} because {@link Gson} guarantees to be thread-safe.\r\n     */\r\n    // Note: In case these strong reference to TypeAdapterFactory instances are considered\r\n    // a memory leak in the future, could consider switching to WeakReference<TypeAdapterFactory>\r\n    private final ConcurrentMap<Class<?>, TypeAdapterFactory> adapterFactoryMap;\r\n\r\n    public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\r\n        this.constructorConstructor = constructorConstructor;\r\n        this.adapterFactoryMap = new ConcurrentHashMap<>();\r\n    }\r\n\r\n    // Separate helper method to make sure callers retrieve annotation in a consistent way\r\n    private static JsonAdapter getAnnotation(Class<?> rawType) {\r\n        return rawType.getAnnotation(JsonAdapter.class);\r\n    }\r\n\r\n    // this is not safe; requires that user has specified correct adapter class for @JsonAdapter\r\n    @SuppressWarnings(\"unchecked\")\r\n    @Override\r\n    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\r\n        Class<? super T> rawType = targetType.getRawType();\r\n        JsonAdapter annotation = getAnnotation(rawType);\r\n        if (annotation == null) {\r\n            return null;\r\n        }\r\n        return (TypeAdapter<T>) getTypeAdapter(constructorConstructor, gson, targetType, annotation, true);\r\n    }\r\n\r\n    // Separate helper method to make sure callers create adapter in a consistent way\r\n    private static Object createAdapter(ConstructorConstructor constructorConstructor, Class<?> adapterClass) {\r\n        // TODO: The exception messages created by ConstructorConstructor are currently written in the\r\n        // context of deserialization and for example suggest usage of TypeAdapter, which would not work\r\n        // for @JsonAdapter usage\r\n        // TODO: Should probably not allow usage of Unsafe; instances might be in broken state and\r\n        // calling adapter methods on them might lead to confusing exceptions\r\n        boolean allowUnsafe = true;\r\n        return constructorConstructor.get(TypeToken.get(adapterClass), allowUnsafe).construct();\r\n    }\r\n\r\n    private TypeAdapterFactory putFactoryAndGetCurrent(Class<?> rawType, TypeAdapterFactory factory) {\r\n        // Uses putIfAbsent in case multiple threads concurrently create factory\r\n        TypeAdapterFactory existingFactory = adapterFactoryMap.putIfAbsent(rawType, factory);\r\n        return existingFactory != null ? existingFactory : factory;\r\n    }\r\n\r\n    TypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson, TypeToken<?> type, JsonAdapter annotation, boolean isClassAnnotation) {\r\n        Object instance = createAdapter(constructorConstructor, annotation.value());\r\n        TypeAdapter<?> typeAdapter;\r\n        boolean nullSafe = annotation.nullSafe();\r\n        if (instance instanceof TypeAdapter) {\r\n            typeAdapter = (TypeAdapter<?>) instance;\r\n        } else if (instance instanceof TypeAdapterFactory) {\r\n            TypeAdapterFactory factory = (TypeAdapterFactory) instance;\r\n            if (isClassAnnotation) {\r\n                factory = putFactoryAndGetCurrent(type.getRawType(), factory);\r\n            }\r\n            typeAdapter = factory.create(gson, type);\r\n        } else if (instance instanceof JsonSerializer || instance instanceof JsonDeserializer) {\r\n            JsonSerializer<?> serializer = instance instanceof JsonSerializer ? (JsonSerializer<?>) instance : null;\r\n            JsonDeserializer<?> deserializer = instance instanceof JsonDeserializer ? (JsonDeserializer<?>) instance : null;\r\n            // Uses dummy factory instances because TreeTypeAdapter needs a 'skipPast' factory for\r\n            // `Gson.getDelegateAdapter` call and has to differentiate there whether TreeTypeAdapter was\r\n            // created for @JsonAdapter on class or field\r\n            TypeAdapterFactory skipPast;\r\n            if (isClassAnnotation) {\r\n                skipPast = TREE_TYPE_CLASS_DUMMY_FACTORY;\r\n            } else {\r\n                skipPast = TREE_TYPE_FIELD_DUMMY_FACTORY;\r\n            }\r\n            @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n            TypeAdapter<?> tempAdapter = new TreeTypeAdapter(serializer, deserializer, gson, type, skipPast, nullSafe);\r\n            typeAdapter = tempAdapter;\r\n            // TreeTypeAdapter handles nullSafe; don't additionally call `nullSafe()`\r\n            nullSafe = false;\r\n        } else {\r\n            throw new IllegalArgumentException(\"Invalid attempt to bind an instance of \" + instance.getClass().getName() + \" as a @JsonAdapter for \" + type.toString() + \". @JsonAdapter value must be a TypeAdapter, TypeAdapterFactory,\" + \" JsonSerializer or JsonDeserializer.\");\r\n        }\r\n        if (typeAdapter != null && nullSafe) {\r\n            typeAdapter = typeAdapter.nullSafe();\r\n        }\r\n        return typeAdapter;\r\n    }\r\n\r\n    /**\r\n     * Returns whether {@code factory} is a type adapter factory created for {@code @JsonAdapter}\r\n     * placed on {@code type}.\r\n     */\r\n    public boolean isClassJsonAdapterFactory(TypeToken<?> type, TypeAdapterFactory factory) {\r\n        Objects.requireNonNull(type);\r\n        Objects.requireNonNull(factory);\r\n        if (factory == TREE_TYPE_CLASS_DUMMY_FACTORY) {\r\n            return true;\r\n        }\r\n        // Using raw type to match behavior of `create(Gson, TypeToken<T>)` above\r\n        Class<?> rawType = type.getRawType();\r\n        TypeAdapterFactory existingFactory = adapterFactoryMap.get(rawType);\r\n        if (existingFactory != null) {\r\n            // Checks for reference equality, like it is done by `Gson.getDelegateAdapter`\r\n            return existingFactory == factory;\r\n        }\r\n        // If no factory has been created for the type yet check manually for a @JsonAdapter annotation\r\n        // which specifies a TypeAdapterFactory\r\n        // Otherwise behavior would not be consistent, depending on whether or not adapter had been\r\n        // requested before call to `isClassJsonAdapterFactory` was made\r\n        JsonAdapter annotation = getAnnotation(rawType);\r\n        if (annotation == null) {\r\n            return false;\r\n        }\r\n        Class<?> adapterClass = annotation.value();\r\n        if (!TypeAdapterFactory.class.isAssignableFrom(adapterClass)) {\r\n            return false;\r\n        }\r\n        Object adapter = createAdapter(constructorConstructor, adapterClass);\r\n        TypeAdapterFactory newFactory = (TypeAdapterFactory) adapter;\r\n        return putFactoryAndGetCurrent(rawType, newFactory) == factory;\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\JsonAdapterAnnotationTypeAdapterFactory.java"
  },
  {
    "type": "field",
    "name": "TREE_TYPE_CLASS_DUMMY_FACTORY",
    "start_line": 46,
    "end_line": 47,
    "code": "/**\r\n * Factory used for {@link TreeTypeAdapter}s created for {@code @JsonAdapter} on a class.\r\n */\r\nprivate static final TypeAdapterFactory TREE_TYPE_CLASS_DUMMY_FACTORY = new DummyTypeAdapterFactory();",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\JsonAdapterAnnotationTypeAdapterFactory.java"
  },
  {
    "type": "field",
    "name": "TREE_TYPE_FIELD_DUMMY_FACTORY",
    "start_line": 50,
    "end_line": 51,
    "code": "/**\r\n * Factory used for {@link TreeTypeAdapter}s created for {@code @JsonAdapter} on a field.\r\n */\r\nprivate static final TypeAdapterFactory TREE_TYPE_FIELD_DUMMY_FACTORY = new DummyTypeAdapterFactory();",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\JsonAdapterAnnotationTypeAdapterFactory.java"
  },
  {
    "type": "field",
    "name": "constructorConstructor",
    "start_line": 53,
    "end_line": 53,
    "code": "private final ConstructorConstructor constructorConstructor;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\JsonAdapterAnnotationTypeAdapterFactory.java"
  },
  {
    "type": "field",
    "name": "adapterFactoryMap",
    "start_line": 62,
    "end_line": 62,
    "code": "/**\r\n * For a class, if it is annotated with {@code @JsonAdapter} and refers to a {@link\r\n * TypeAdapterFactory}, stores the factory instance in case it has been requested already. Has to\r\n * be a {@link ConcurrentMap} because {@link Gson} guarantees to be thread-safe.\r\n */\r\n// Note: In case these strong reference to TypeAdapterFactory instances are considered\r\n// a memory leak in the future, could consider switching to WeakReference<TypeAdapterFactory>\r\nprivate final ConcurrentMap<Class<?>, TypeAdapterFactory> adapterFactoryMap;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\JsonAdapterAnnotationTypeAdapterFactory.java"
  },
  {
    "type": "constructor",
    "name": "JsonAdapterAnnotationTypeAdapterFactory",
    "start_line": 64,
    "end_line": 67,
    "code": "public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\r\n    this.constructorConstructor = constructorConstructor;\r\n    this.adapterFactoryMap = new ConcurrentHashMap<>();\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\JsonAdapterAnnotationTypeAdapterFactory.java"
  },
  {
    "type": "method",
    "name": "getAnnotation",
    "start_line": 70,
    "end_line": 72,
    "code": "// Separate helper method to make sure callers retrieve annotation in a consistent way\r\nprivate static JsonAdapter getAnnotation(Class<?> rawType) {\r\n    return rawType.getAnnotation(JsonAdapter.class);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\JsonAdapterAnnotationTypeAdapterFactory.java"
  },
  {
    "type": "method",
    "name": "create",
    "start_line": 75,
    "end_line": 85,
    "code": "// this is not safe; requires that user has specified correct adapter class for @JsonAdapter\r\n@SuppressWarnings(\"unchecked\")\r\n@Override\r\npublic <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\r\n    Class<? super T> rawType = targetType.getRawType();\r\n    JsonAdapter annotation = getAnnotation(rawType);\r\n    if (annotation == null) {\r\n        return null;\r\n    }\r\n    return (TypeAdapter<T>) getTypeAdapter(constructorConstructor, gson, targetType, annotation, true);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\JsonAdapterAnnotationTypeAdapterFactory.java"
  },
  {
    "type": "method",
    "name": "createAdapter",
    "start_line": 88,
    "end_line": 97,
    "code": "// Separate helper method to make sure callers create adapter in a consistent way\r\nprivate static Object createAdapter(ConstructorConstructor constructorConstructor, Class<?> adapterClass) {\r\n    // TODO: The exception messages created by ConstructorConstructor are currently written in the\r\n    // context of deserialization and for example suggest usage of TypeAdapter, which would not work\r\n    // for @JsonAdapter usage\r\n    // TODO: Should probably not allow usage of Unsafe; instances might be in broken state and\r\n    // calling adapter methods on them might lead to confusing exceptions\r\n    boolean allowUnsafe = true;\r\n    return constructorConstructor.get(TypeToken.get(adapterClass), allowUnsafe).construct();\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\JsonAdapterAnnotationTypeAdapterFactory.java"
  },
  {
    "type": "method",
    "name": "putFactoryAndGetCurrent",
    "start_line": 99,
    "end_line": 103,
    "code": "private TypeAdapterFactory putFactoryAndGetCurrent(Class<?> rawType, TypeAdapterFactory factory) {\r\n    // Uses putIfAbsent in case multiple threads concurrently create factory\r\n    TypeAdapterFactory existingFactory = adapterFactoryMap.putIfAbsent(rawType, factory);\r\n    return existingFactory != null ? existingFactory : factory;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\JsonAdapterAnnotationTypeAdapterFactory.java"
  },
  {
    "type": "method",
    "name": "getTypeAdapter",
    "start_line": 105,
    "end_line": 162,
    "code": "TypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson, TypeToken<?> type, JsonAdapter annotation, boolean isClassAnnotation) {\r\n    Object instance = createAdapter(constructorConstructor, annotation.value());\r\n    TypeAdapter<?> typeAdapter;\r\n    boolean nullSafe = annotation.nullSafe();\r\n    if (instance instanceof TypeAdapter) {\r\n        typeAdapter = (TypeAdapter<?>) instance;\r\n    } else if (instance instanceof TypeAdapterFactory) {\r\n        TypeAdapterFactory factory = (TypeAdapterFactory) instance;\r\n        if (isClassAnnotation) {\r\n            factory = putFactoryAndGetCurrent(type.getRawType(), factory);\r\n        }\r\n        typeAdapter = factory.create(gson, type);\r\n    } else if (instance instanceof JsonSerializer || instance instanceof JsonDeserializer) {\r\n        JsonSerializer<?> serializer = instance instanceof JsonSerializer ? (JsonSerializer<?>) instance : null;\r\n        JsonDeserializer<?> deserializer = instance instanceof JsonDeserializer ? (JsonDeserializer<?>) instance : null;\r\n        // Uses dummy factory instances because TreeTypeAdapter needs a 'skipPast' factory for\r\n        // `Gson.getDelegateAdapter` call and has to differentiate there whether TreeTypeAdapter was\r\n        // created for @JsonAdapter on class or field\r\n        TypeAdapterFactory skipPast;\r\n        if (isClassAnnotation) {\r\n            skipPast = TREE_TYPE_CLASS_DUMMY_FACTORY;\r\n        } else {\r\n            skipPast = TREE_TYPE_FIELD_DUMMY_FACTORY;\r\n        }\r\n        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n        TypeAdapter<?> tempAdapter = new TreeTypeAdapter(serializer, deserializer, gson, type, skipPast, nullSafe);\r\n        typeAdapter = tempAdapter;\r\n        // TreeTypeAdapter handles nullSafe; don't additionally call `nullSafe()`\r\n        nullSafe = false;\r\n    } else {\r\n        throw new IllegalArgumentException(\"Invalid attempt to bind an instance of \" + instance.getClass().getName() + \" as a @JsonAdapter for \" + type.toString() + \". @JsonAdapter value must be a TypeAdapter, TypeAdapterFactory,\" + \" JsonSerializer or JsonDeserializer.\");\r\n    }\r\n    if (typeAdapter != null && nullSafe) {\r\n        typeAdapter = typeAdapter.nullSafe();\r\n    }\r\n    return typeAdapter;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\JsonAdapterAnnotationTypeAdapterFactory.java"
  },
  {
    "type": "method",
    "name": "isClassJsonAdapterFactory",
    "start_line": 168,
    "end_line": 203,
    "code": "/**\r\n * Returns whether {@code factory} is a type adapter factory created for {@code @JsonAdapter}\r\n * placed on {@code type}.\r\n */\r\npublic boolean isClassJsonAdapterFactory(TypeToken<?> type, TypeAdapterFactory factory) {\r\n    Objects.requireNonNull(type);\r\n    Objects.requireNonNull(factory);\r\n    if (factory == TREE_TYPE_CLASS_DUMMY_FACTORY) {\r\n        return true;\r\n    }\r\n    // Using raw type to match behavior of `create(Gson, TypeToken<T>)` above\r\n    Class<?> rawType = type.getRawType();\r\n    TypeAdapterFactory existingFactory = adapterFactoryMap.get(rawType);\r\n    if (existingFactory != null) {\r\n        // Checks for reference equality, like it is done by `Gson.getDelegateAdapter`\r\n        return existingFactory == factory;\r\n    }\r\n    // If no factory has been created for the type yet check manually for a @JsonAdapter annotation\r\n    // which specifies a TypeAdapterFactory\r\n    // Otherwise behavior would not be consistent, depending on whether or not adapter had been\r\n    // requested before call to `isClassJsonAdapterFactory` was made\r\n    JsonAdapter annotation = getAnnotation(rawType);\r\n    if (annotation == null) {\r\n        return false;\r\n    }\r\n    Class<?> adapterClass = annotation.value();\r\n    if (!TypeAdapterFactory.class.isAssignableFrom(adapterClass)) {\r\n        return false;\r\n    }\r\n    Object adapter = createAdapter(constructorConstructor, adapterClass);\r\n    TypeAdapterFactory newFactory = (TypeAdapterFactory) adapter;\r\n    return putFactoryAndGetCurrent(rawType, newFactory) == factory;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\gson\\src\\main\\java\\com\\google\\gson\\internal\\bind\\JsonAdapterAnnotationTypeAdapterFactory.java"
  }
]