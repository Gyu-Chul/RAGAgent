[
  {
    "type": "package",
    "name": "com.google.gson.typeadapters",
    "start_line": 17,
    "end_line": 17,
    "code": "package com.google.gson.typeadapters;\r\n\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\typeadapters\\RuntimeTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.errorprone.annotations.CanIgnoreReturnValue",
    "start_line": 19,
    "end_line": 19,
    "code": "import com.google.errorprone.annotations.CanIgnoreReturnValue;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\typeadapters\\RuntimeTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.Gson",
    "start_line": 20,
    "end_line": 20,
    "code": "import com.google.gson.Gson;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\typeadapters\\RuntimeTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.JsonElement",
    "start_line": 21,
    "end_line": 21,
    "code": "import com.google.gson.JsonElement;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\typeadapters\\RuntimeTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.JsonObject",
    "start_line": 22,
    "end_line": 22,
    "code": "import com.google.gson.JsonObject;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\typeadapters\\RuntimeTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.JsonParseException",
    "start_line": 23,
    "end_line": 23,
    "code": "import com.google.gson.JsonParseException;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\typeadapters\\RuntimeTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.JsonPrimitive",
    "start_line": 24,
    "end_line": 24,
    "code": "import com.google.gson.JsonPrimitive;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\typeadapters\\RuntimeTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.TypeAdapter",
    "start_line": 25,
    "end_line": 25,
    "code": "import com.google.gson.TypeAdapter;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\typeadapters\\RuntimeTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.TypeAdapterFactory",
    "start_line": 26,
    "end_line": 26,
    "code": "import com.google.gson.TypeAdapterFactory;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\typeadapters\\RuntimeTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.reflect.TypeToken",
    "start_line": 27,
    "end_line": 27,
    "code": "import com.google.gson.reflect.TypeToken;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\typeadapters\\RuntimeTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.stream.JsonReader",
    "start_line": 28,
    "end_line": 28,
    "code": "import com.google.gson.stream.JsonReader;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\typeadapters\\RuntimeTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.stream.JsonWriter",
    "start_line": 29,
    "end_line": 29,
    "code": "import com.google.gson.stream.JsonWriter;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\typeadapters\\RuntimeTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "java.io.IOException",
    "start_line": 30,
    "end_line": 30,
    "code": "import java.io.IOException;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\typeadapters\\RuntimeTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "java.util.LinkedHashMap",
    "start_line": 31,
    "end_line": 31,
    "code": "import java.util.LinkedHashMap;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\typeadapters\\RuntimeTypeAdapterFactory.java"
  },
  {
    "type": "import",
    "name": "java.util.Map",
    "start_line": 32,
    "end_line": 32,
    "code": "import java.util.Map;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\typeadapters\\RuntimeTypeAdapterFactory.java"
  },
  {
    "type": "class",
    "name": "RuntimeTypeAdapterFactory",
    "start_line": 158,
    "end_line": 331,
    "code": "/**\r\n * Adapts values whose runtime type may differ from their declaration type. This is necessary when a\r\n * field's type is not the same type that GSON should create when deserializing that field. For\r\n * example, consider these types:\r\n *\r\n * <pre>{@code\r\n * abstract class Shape {\r\n *   int x;\r\n *   int y;\r\n * }\r\n * class Circle extends Shape {\r\n *   int radius;\r\n * }\r\n * class Rectangle extends Shape {\r\n *   int width;\r\n *   int height;\r\n * }\r\n * class Diamond extends Shape {\r\n *   int width;\r\n *   int height;\r\n * }\r\n * class Drawing {\r\n *   Shape bottomShape;\r\n *   Shape topShape;\r\n * }\r\n * }</pre>\r\n *\r\n * <p>Without additional type information, the serialized JSON is ambiguous. Is the bottom shape in\r\n * this drawing a rectangle or a diamond?\r\n *\r\n * <pre>{@code\r\n * {\r\n *   \"bottomShape\": {\r\n *     \"width\": 10,\r\n *     \"height\": 5,\r\n *     \"x\": 0,\r\n *     \"y\": 0\r\n *   },\r\n *   \"topShape\": {\r\n *     \"radius\": 2,\r\n *     \"x\": 4,\r\n *     \"y\": 1\r\n *   }\r\n * }\r\n * }</pre>\r\n *\r\n * This class addresses this problem by adding type information to the serialized JSON and honoring\r\n * that type information when the JSON is deserialized:\r\n *\r\n * <pre>{@code\r\n * {\r\n *   \"bottomShape\": {\r\n *     \"type\": \"Diamond\",\r\n *     \"width\": 10,\r\n *     \"height\": 5,\r\n *     \"x\": 0,\r\n *     \"y\": 0\r\n *   },\r\n *   \"topShape\": {\r\n *     \"type\": \"Circle\",\r\n *     \"radius\": 2,\r\n *     \"x\": 4,\r\n *     \"y\": 1\r\n *   }\r\n * }\r\n * }</pre>\r\n *\r\n * Both the type field name ({@code \"type\"}) and the type labels ({@code \"Rectangle\"}) are\r\n * configurable.\r\n *\r\n * <h2>Registering Types</h2>\r\n *\r\n * Create a {@code RuntimeTypeAdapterFactory} by passing the base type and type field name to the\r\n * {@link #of} factory method. If you don't supply an explicit type field name, {@code \"type\"} will\r\n * be used.\r\n *\r\n * <pre>{@code\r\n * RuntimeTypeAdapterFactory<Shape> shapeAdapterFactory\r\n *     = RuntimeTypeAdapterFactory.of(Shape.class, \"type\");\r\n * }</pre>\r\n *\r\n * Next register all of your subtypes. Every subtype must be explicitly registered. This protects\r\n * your application from injection attacks. If you don't supply an explicit type label, the type's\r\n * simple name will be used.\r\n *\r\n * <pre>{@code\r\n * shapeAdapterFactory.registerSubtype(Rectangle.class, \"Rectangle\");\r\n * shapeAdapterFactory.registerSubtype(Circle.class, \"Circle\");\r\n * shapeAdapterFactory.registerSubtype(Diamond.class, \"Diamond\");\r\n * }</pre>\r\n *\r\n * Finally, register the type adapter factory in your application's GSON builder:\r\n *\r\n * <pre>{@code\r\n * Gson gson = new GsonBuilder()\r\n *     .registerTypeAdapterFactory(shapeAdapterFactory)\r\n *     .create();\r\n * }</pre>\r\n *\r\n * Like {@code GsonBuilder}, this API supports chaining:\r\n *\r\n * <pre>{@code\r\n * RuntimeTypeAdapterFactory<Shape> shapeAdapterFactory = RuntimeTypeAdapterFactory.of(Shape.class)\r\n *     .registerSubtype(Rectangle.class)\r\n *     .registerSubtype(Circle.class)\r\n *     .registerSubtype(Diamond.class);\r\n * }</pre>\r\n *\r\n * <h2>Serialization and deserialization</h2>\r\n *\r\n * In order to serialize and deserialize a polymorphic object, you must specify the base type\r\n * explicitly.\r\n *\r\n * <pre>{@code\r\n * Diamond diamond = new Diamond();\r\n * String json = gson.toJson(diamond, Shape.class);\r\n * }</pre>\r\n *\r\n * And then:\r\n *\r\n * <pre>{@code\r\n * Shape shape = gson.fromJson(json, Shape.class);\r\n * }</pre>\r\n */\r\npublic final class RuntimeTypeAdapterFactory<T> implements TypeAdapterFactory {\r\n\r\n    private final Class<?> baseType;\r\n\r\n    private final String typeFieldName;\r\n\r\n    private final Map<String, Class<?>> labelToSubtype = new LinkedHashMap<>();\r\n\r\n    private final Map<Class<?>, String> subtypeToLabel = new LinkedHashMap<>();\r\n\r\n    private final boolean maintainType;\r\n\r\n    private boolean recognizeSubtypes;\r\n\r\n    private RuntimeTypeAdapterFactory(Class<?> baseType, String typeFieldName, boolean maintainType) {\r\n        if (typeFieldName == null || baseType == null) {\r\n            throw new NullPointerException();\r\n        }\r\n        this.baseType = baseType;\r\n        this.typeFieldName = typeFieldName;\r\n        this.maintainType = maintainType;\r\n    }\r\n\r\n    /**\r\n     * Creates a new runtime type adapter for {@code baseType} using {@code typeFieldName} as the type\r\n     * field name. Type field names are case sensitive.\r\n     *\r\n     * @param maintainType true if the type field should be included in deserialized objects\r\n     */\r\n    public static <T> RuntimeTypeAdapterFactory<T> of(Class<T> baseType, String typeFieldName, boolean maintainType) {\r\n        return new RuntimeTypeAdapterFactory<>(baseType, typeFieldName, maintainType);\r\n    }\r\n\r\n    /**\r\n     * Creates a new runtime type adapter for {@code baseType} using {@code typeFieldName} as the type\r\n     * field name. Type field names are case sensitive.\r\n     */\r\n    public static <T> RuntimeTypeAdapterFactory<T> of(Class<T> baseType, String typeFieldName) {\r\n        return new RuntimeTypeAdapterFactory<>(baseType, typeFieldName, false);\r\n    }\r\n\r\n    /**\r\n     * Creates a new runtime type adapter for {@code baseType} using {@code \"type\"} as the type field\r\n     * name.\r\n     */\r\n    public static <T> RuntimeTypeAdapterFactory<T> of(Class<T> baseType) {\r\n        return new RuntimeTypeAdapterFactory<>(baseType, \"type\", false);\r\n    }\r\n\r\n    /**\r\n     * Ensures that this factory will handle not just the given {@code baseType}, but any subtype of\r\n     * that type.\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public RuntimeTypeAdapterFactory<T> recognizeSubtypes() {\r\n        this.recognizeSubtypes = true;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Registers {@code type} identified by {@code label}. Labels are case sensitive.\r\n     *\r\n     * @throws IllegalArgumentException if either {@code type} or {@code label} have already been\r\n     *     registered on this type adapter.\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public RuntimeTypeAdapterFactory<T> registerSubtype(Class<? extends T> type, String label) {\r\n        if (type == null || label == null) {\r\n            throw new NullPointerException();\r\n        }\r\n        if (subtypeToLabel.containsKey(type) || labelToSubtype.containsKey(label)) {\r\n            throw new IllegalArgumentException(\"types and labels must be unique\");\r\n        }\r\n        labelToSubtype.put(label, type);\r\n        subtypeToLabel.put(type, label);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Registers {@code type} identified by its {@link Class#getSimpleName simple name}. Labels are\r\n     * case sensitive.\r\n     *\r\n     * @throws IllegalArgumentException if either {@code type} or its simple name have already been\r\n     *     registered on this type adapter.\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public RuntimeTypeAdapterFactory<T> registerSubtype(Class<? extends T> type) {\r\n        return registerSubtype(type, type.getSimpleName());\r\n    }\r\n\r\n    @Override\r\n    public <R> TypeAdapter<R> create(Gson gson, TypeToken<R> type) {\r\n        if (type == null) {\r\n            return null;\r\n        }\r\n        Class<?> rawType = type.getRawType();\r\n        boolean handle = recognizeSubtypes ? baseType.isAssignableFrom(rawType) : baseType.equals(rawType);\r\n        if (!handle) {\r\n            return null;\r\n        }\r\n        TypeAdapter<JsonElement> jsonElementAdapter = gson.getAdapter(JsonElement.class);\r\n        Map<String, TypeAdapter<?>> labelToDelegate = new LinkedHashMap<>();\r\n        Map<Class<?>, TypeAdapter<?>> subtypeToDelegate = new LinkedHashMap<>();\r\n        for (Map.Entry<String, Class<?>> entry : labelToSubtype.entrySet()) {\r\n            TypeAdapter<?> delegate = gson.getDelegateAdapter(this, TypeToken.get(entry.getValue()));\r\n            labelToDelegate.put(entry.getKey(), delegate);\r\n            subtypeToDelegate.put(entry.getValue(), delegate);\r\n        }\r\n        return new TypeAdapter<R>() {\r\n\r\n            @Override\r\n            public R read(JsonReader in) throws IOException {\r\n                JsonElement jsonElement = jsonElementAdapter.read(in);\r\n                JsonElement labelJsonElement;\r\n                if (maintainType) {\r\n                    labelJsonElement = jsonElement.getAsJsonObject().get(typeFieldName);\r\n                } else {\r\n                    labelJsonElement = jsonElement.getAsJsonObject().remove(typeFieldName);\r\n                }\r\n                if (labelJsonElement == null) {\r\n                    throw new JsonParseException(\"cannot deserialize \" + baseType + \" because it does not define a field named \" + typeFieldName);\r\n                }\r\n                String label = labelJsonElement.getAsString();\r\n                // registration requires that subtype extends T\r\n                @SuppressWarnings(\"unchecked\")\r\n                TypeAdapter<R> delegate = (TypeAdapter<R>) labelToDelegate.get(label);\r\n                if (delegate == null) {\r\n                    throw new JsonParseException(\"cannot deserialize \" + baseType + \" subtype named \" + label + \"; did you forget to register a subtype?\");\r\n                }\r\n                return delegate.fromJsonTree(jsonElement);\r\n            }\r\n\r\n            @Override\r\n            public void write(JsonWriter out, R value) throws IOException {\r\n                Class<?> srcType = value.getClass();\r\n                String label = subtypeToLabel.get(srcType);\r\n                // registration requires that subtype extends T\r\n                @SuppressWarnings(\"unchecked\")\r\n                TypeAdapter<R> delegate = (TypeAdapter<R>) subtypeToDelegate.get(srcType);\r\n                if (delegate == null) {\r\n                    throw new JsonParseException(\"cannot serialize \" + srcType.getName() + \"; did you forget to register a subtype?\");\r\n                }\r\n                JsonObject jsonObject = delegate.toJsonTree(value).getAsJsonObject();\r\n                if (maintainType) {\r\n                    jsonElementAdapter.write(out, jsonObject);\r\n                    return;\r\n                }\r\n                JsonObject clone = new JsonObject();\r\n                if (jsonObject.has(typeFieldName)) {\r\n                    throw new JsonParseException(\"cannot serialize \" + srcType.getName() + \" because it already defines a field named \" + typeFieldName);\r\n                }\r\n                clone.add(typeFieldName, new JsonPrimitive(label));\r\n                for (Map.Entry<String, JsonElement> e : jsonObject.entrySet()) {\r\n                    clone.add(e.getKey(), e.getValue());\r\n                }\r\n                jsonElementAdapter.write(out, clone);\r\n            }\r\n        }.nullSafe();\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\typeadapters\\RuntimeTypeAdapterFactory.java"
  },
  {
    "type": "field",
    "name": "baseType",
    "start_line": 159,
    "end_line": 159,
    "code": "private final Class<?> baseType;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\typeadapters\\RuntimeTypeAdapterFactory.java"
  },
  {
    "type": "field",
    "name": "typeFieldName",
    "start_line": 160,
    "end_line": 160,
    "code": "private final String typeFieldName;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\typeadapters\\RuntimeTypeAdapterFactory.java"
  },
  {
    "type": "field",
    "name": "labelToSubtype",
    "start_line": 161,
    "end_line": 161,
    "code": "private final Map<String, Class<?>> labelToSubtype = new LinkedHashMap<>();",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\typeadapters\\RuntimeTypeAdapterFactory.java"
  },
  {
    "type": "field",
    "name": "subtypeToLabel",
    "start_line": 162,
    "end_line": 162,
    "code": "private final Map<Class<?>, String> subtypeToLabel = new LinkedHashMap<>();",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\typeadapters\\RuntimeTypeAdapterFactory.java"
  },
  {
    "type": "field",
    "name": "maintainType",
    "start_line": 163,
    "end_line": 163,
    "code": "private final boolean maintainType;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\typeadapters\\RuntimeTypeAdapterFactory.java"
  },
  {
    "type": "field",
    "name": "recognizeSubtypes",
    "start_line": 164,
    "end_line": 164,
    "code": "private boolean recognizeSubtypes;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\typeadapters\\RuntimeTypeAdapterFactory.java"
  },
  {
    "type": "constructor",
    "name": "RuntimeTypeAdapterFactory",
    "start_line": 166,
    "end_line": 173,
    "code": "private RuntimeTypeAdapterFactory(Class<?> baseType, String typeFieldName, boolean maintainType) {\r\n    if (typeFieldName == null || baseType == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    this.baseType = baseType;\r\n    this.typeFieldName = typeFieldName;\r\n    this.maintainType = maintainType;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\typeadapters\\RuntimeTypeAdapterFactory.java"
  },
  {
    "type": "method",
    "name": "of",
    "start_line": 181,
    "end_line": 184,
    "code": "/**\r\n * Creates a new runtime type adapter for {@code baseType} using {@code typeFieldName} as the type\r\n * field name. Type field names are case sensitive.\r\n *\r\n * @param maintainType true if the type field should be included in deserialized objects\r\n */\r\npublic static <T> RuntimeTypeAdapterFactory<T> of(Class<T> baseType, String typeFieldName, boolean maintainType) {\r\n    return new RuntimeTypeAdapterFactory<>(baseType, typeFieldName, maintainType);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\typeadapters\\RuntimeTypeAdapterFactory.java"
  },
  {
    "type": "method",
    "name": "of",
    "start_line": 190,
    "end_line": 192,
    "code": "/**\r\n * Creates a new runtime type adapter for {@code baseType} using {@code typeFieldName} as the type\r\n * field name. Type field names are case sensitive.\r\n */\r\npublic static <T> RuntimeTypeAdapterFactory<T> of(Class<T> baseType, String typeFieldName) {\r\n    return new RuntimeTypeAdapterFactory<>(baseType, typeFieldName, false);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\typeadapters\\RuntimeTypeAdapterFactory.java"
  },
  {
    "type": "method",
    "name": "of",
    "start_line": 198,
    "end_line": 200,
    "code": "/**\r\n * Creates a new runtime type adapter for {@code baseType} using {@code \"type\"} as the type field\r\n * name.\r\n */\r\npublic static <T> RuntimeTypeAdapterFactory<T> of(Class<T> baseType) {\r\n    return new RuntimeTypeAdapterFactory<>(baseType, \"type\", false);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\typeadapters\\RuntimeTypeAdapterFactory.java"
  },
  {
    "type": "method",
    "name": "recognizeSubtypes",
    "start_line": 206,
    "end_line": 210,
    "code": "/**\r\n * Ensures that this factory will handle not just the given {@code baseType}, but any subtype of\r\n * that type.\r\n */\r\n@CanIgnoreReturnValue\r\npublic RuntimeTypeAdapterFactory<T> recognizeSubtypes() {\r\n    this.recognizeSubtypes = true;\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\typeadapters\\RuntimeTypeAdapterFactory.java"
  },
  {
    "type": "method",
    "name": "registerSubtype",
    "start_line": 218,
    "end_line": 229,
    "code": "/**\r\n * Registers {@code type} identified by {@code label}. Labels are case sensitive.\r\n *\r\n * @throws IllegalArgumentException if either {@code type} or {@code label} have already been\r\n *     registered on this type adapter.\r\n */\r\n@CanIgnoreReturnValue\r\npublic RuntimeTypeAdapterFactory<T> registerSubtype(Class<? extends T> type, String label) {\r\n    if (type == null || label == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    if (subtypeToLabel.containsKey(type) || labelToSubtype.containsKey(label)) {\r\n        throw new IllegalArgumentException(\"types and labels must be unique\");\r\n    }\r\n    labelToSubtype.put(label, type);\r\n    subtypeToLabel.put(type, label);\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\typeadapters\\RuntimeTypeAdapterFactory.java"
  },
  {
    "type": "method",
    "name": "registerSubtype",
    "start_line": 238,
    "end_line": 241,
    "code": "/**\r\n * Registers {@code type} identified by its {@link Class#getSimpleName simple name}. Labels are\r\n * case sensitive.\r\n *\r\n * @throws IllegalArgumentException if either {@code type} or its simple name have already been\r\n *     registered on this type adapter.\r\n */\r\n@CanIgnoreReturnValue\r\npublic RuntimeTypeAdapterFactory<T> registerSubtype(Class<? extends T> type) {\r\n    return registerSubtype(type, type.getSimpleName());\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\typeadapters\\RuntimeTypeAdapterFactory.java"
  },
  {
    "type": "method",
    "name": "create",
    "start_line": 243,
    "end_line": 330,
    "code": "@Override\r\npublic <R> TypeAdapter<R> create(Gson gson, TypeToken<R> type) {\r\n    if (type == null) {\r\n        return null;\r\n    }\r\n    Class<?> rawType = type.getRawType();\r\n    boolean handle = recognizeSubtypes ? baseType.isAssignableFrom(rawType) : baseType.equals(rawType);\r\n    if (!handle) {\r\n        return null;\r\n    }\r\n    TypeAdapter<JsonElement> jsonElementAdapter = gson.getAdapter(JsonElement.class);\r\n    Map<String, TypeAdapter<?>> labelToDelegate = new LinkedHashMap<>();\r\n    Map<Class<?>, TypeAdapter<?>> subtypeToDelegate = new LinkedHashMap<>();\r\n    for (Map.Entry<String, Class<?>> entry : labelToSubtype.entrySet()) {\r\n        TypeAdapter<?> delegate = gson.getDelegateAdapter(this, TypeToken.get(entry.getValue()));\r\n        labelToDelegate.put(entry.getKey(), delegate);\r\n        subtypeToDelegate.put(entry.getValue(), delegate);\r\n    }\r\n    return new TypeAdapter<R>() {\r\n\r\n        @Override\r\n        public R read(JsonReader in) throws IOException {\r\n            JsonElement jsonElement = jsonElementAdapter.read(in);\r\n            JsonElement labelJsonElement;\r\n            if (maintainType) {\r\n                labelJsonElement = jsonElement.getAsJsonObject().get(typeFieldName);\r\n            } else {\r\n                labelJsonElement = jsonElement.getAsJsonObject().remove(typeFieldName);\r\n            }\r\n            if (labelJsonElement == null) {\r\n                throw new JsonParseException(\"cannot deserialize \" + baseType + \" because it does not define a field named \" + typeFieldName);\r\n            }\r\n            String label = labelJsonElement.getAsString();\r\n            // registration requires that subtype extends T\r\n            @SuppressWarnings(\"unchecked\")\r\n            TypeAdapter<R> delegate = (TypeAdapter<R>) labelToDelegate.get(label);\r\n            if (delegate == null) {\r\n                throw new JsonParseException(\"cannot deserialize \" + baseType + \" subtype named \" + label + \"; did you forget to register a subtype?\");\r\n            }\r\n            return delegate.fromJsonTree(jsonElement);\r\n        }\r\n\r\n        @Override\r\n        public void write(JsonWriter out, R value) throws IOException {\r\n            Class<?> srcType = value.getClass();\r\n            String label = subtypeToLabel.get(srcType);\r\n            // registration requires that subtype extends T\r\n            @SuppressWarnings(\"unchecked\")\r\n            TypeAdapter<R> delegate = (TypeAdapter<R>) subtypeToDelegate.get(srcType);\r\n            if (delegate == null) {\r\n                throw new JsonParseException(\"cannot serialize \" + srcType.getName() + \"; did you forget to register a subtype?\");\r\n            }\r\n            JsonObject jsonObject = delegate.toJsonTree(value).getAsJsonObject();\r\n            if (maintainType) {\r\n                jsonElementAdapter.write(out, jsonObject);\r\n                return;\r\n            }\r\n            JsonObject clone = new JsonObject();\r\n            if (jsonObject.has(typeFieldName)) {\r\n                throw new JsonParseException(\"cannot serialize \" + srcType.getName() + \" because it already defines a field named \" + typeFieldName);\r\n            }\r\n            clone.add(typeFieldName, new JsonPrimitive(label));\r\n            for (Map.Entry<String, JsonElement> e : jsonObject.entrySet()) {\r\n                clone.add(e.getKey(), e.getValue());\r\n            }\r\n            jsonElementAdapter.write(out, clone);\r\n        }\r\n    }.nullSafe();\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\typeadapters\\RuntimeTypeAdapterFactory.java"
  }
]