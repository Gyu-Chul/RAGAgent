[
  {
    "type": "package",
    "name": "com.google.gson.graph",
    "start_line": 17,
    "end_line": 17,
    "code": "package com.google.gson.graph;\r\n\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\graph\\GraphAdapterBuilder.java"
  },
  {
    "type": "import",
    "name": "com.google.errorprone.annotations.CanIgnoreReturnValue",
    "start_line": 19,
    "end_line": 19,
    "code": "import com.google.errorprone.annotations.CanIgnoreReturnValue;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\graph\\GraphAdapterBuilder.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.Gson",
    "start_line": 20,
    "end_line": 20,
    "code": "import com.google.gson.Gson;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\graph\\GraphAdapterBuilder.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.GsonBuilder",
    "start_line": 21,
    "end_line": 21,
    "code": "import com.google.gson.GsonBuilder;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\graph\\GraphAdapterBuilder.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.InstanceCreator",
    "start_line": 22,
    "end_line": 22,
    "code": "import com.google.gson.InstanceCreator;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\graph\\GraphAdapterBuilder.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.JsonElement",
    "start_line": 23,
    "end_line": 23,
    "code": "import com.google.gson.JsonElement;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\graph\\GraphAdapterBuilder.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.TypeAdapter",
    "start_line": 24,
    "end_line": 24,
    "code": "import com.google.gson.TypeAdapter;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\graph\\GraphAdapterBuilder.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.TypeAdapterFactory",
    "start_line": 25,
    "end_line": 25,
    "code": "import com.google.gson.TypeAdapterFactory;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\graph\\GraphAdapterBuilder.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.internal.ConstructorConstructor",
    "start_line": 26,
    "end_line": 26,
    "code": "import com.google.gson.internal.ConstructorConstructor;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\graph\\GraphAdapterBuilder.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.internal.ObjectConstructor",
    "start_line": 27,
    "end_line": 27,
    "code": "import com.google.gson.internal.ObjectConstructor;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\graph\\GraphAdapterBuilder.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.reflect.TypeToken",
    "start_line": 28,
    "end_line": 28,
    "code": "import com.google.gson.reflect.TypeToken;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\graph\\GraphAdapterBuilder.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.stream.JsonReader",
    "start_line": 29,
    "end_line": 29,
    "code": "import com.google.gson.stream.JsonReader;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\graph\\GraphAdapterBuilder.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.stream.JsonToken",
    "start_line": 30,
    "end_line": 30,
    "code": "import com.google.gson.stream.JsonToken;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\graph\\GraphAdapterBuilder.java"
  },
  {
    "type": "import",
    "name": "com.google.gson.stream.JsonWriter",
    "start_line": 31,
    "end_line": 31,
    "code": "import com.google.gson.stream.JsonWriter;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\graph\\GraphAdapterBuilder.java"
  },
  {
    "type": "import",
    "name": "java.io.IOException",
    "start_line": 32,
    "end_line": 32,
    "code": "import java.io.IOException;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\graph\\GraphAdapterBuilder.java"
  },
  {
    "type": "import",
    "name": "java.lang.reflect.Type",
    "start_line": 33,
    "end_line": 33,
    "code": "import java.lang.reflect.Type;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\graph\\GraphAdapterBuilder.java"
  },
  {
    "type": "import",
    "name": "java.util.ArrayDeque",
    "start_line": 34,
    "end_line": 34,
    "code": "import java.util.ArrayDeque;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\graph\\GraphAdapterBuilder.java"
  },
  {
    "type": "import",
    "name": "java.util.Collections",
    "start_line": 35,
    "end_line": 35,
    "code": "import java.util.Collections;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\graph\\GraphAdapterBuilder.java"
  },
  {
    "type": "import",
    "name": "java.util.HashMap",
    "start_line": 36,
    "end_line": 36,
    "code": "import java.util.HashMap;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\graph\\GraphAdapterBuilder.java"
  },
  {
    "type": "import",
    "name": "java.util.IdentityHashMap",
    "start_line": 37,
    "end_line": 37,
    "code": "import java.util.IdentityHashMap;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\graph\\GraphAdapterBuilder.java"
  },
  {
    "type": "import",
    "name": "java.util.Map",
    "start_line": 38,
    "end_line": 38,
    "code": "import java.util.Map;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\graph\\GraphAdapterBuilder.java"
  },
  {
    "type": "import",
    "name": "java.util.Queue",
    "start_line": 39,
    "end_line": 39,
    "code": "import java.util.Queue;\r\n",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\graph\\GraphAdapterBuilder.java"
  },
  {
    "type": "class",
    "name": "GraphAdapterBuilder",
    "start_line": 73,
    "end_line": 360,
    "code": "/**\r\n * A builder for constructing a graph-aware type adapter. This class allows you to register types\r\n * for which cyclic references are allowed by serializing the graph of objects as a list of named\r\n * nodes. This approach ensures that objects referencing each other (or themselves) are properly\r\n * serialized and deserialized.\r\n *\r\n * <p>The builder maintains a mapping between types and their corresponding {@link InstanceCreator}\r\n * instances. When a type is registered, it will be serialized using a graph adapter that assigns a\r\n * unique identifier to each object instance. During deserialization, the graph adapter first builds\r\n * a mapping from these identifiers to their JSON representations and then reconstructs the object\r\n * graph.\r\n *\r\n * <p>Example usage:\r\n *\r\n * <pre>\r\n *   GraphAdapterBuilder graphBuilder = new GraphAdapterBuilder();\r\n *   graphBuilder.addType(MyClass.class);\r\n *\r\n *   GsonBuilder gsonBuilder = new GsonBuilder();\r\n *   graphBuilder.registerOn(gsonBuilder);\r\n *   Gson gson = gsonBuilder.create();\r\n *\r\n *   // Serialization\r\n *   String json = gson.toJson(myObject);\r\n *\r\n *   // Deserialization\r\n *   MyClass deserialized = gson.fromJson(json, MyClass.class);\r\n * </pre>\r\n *\r\n * @see Gson\r\n * @see GsonBuilder\r\n */\r\npublic final class GraphAdapterBuilder {\r\n\r\n    private final Map<Type, InstanceCreator<?>> instanceCreators;\r\n\r\n    private final ConstructorConstructor constructorConstructor;\r\n\r\n    public GraphAdapterBuilder() {\r\n        this.instanceCreators = new HashMap<>();\r\n        this.constructorConstructor = new ConstructorConstructor(Collections.emptyMap(), true, Collections.emptyList());\r\n    }\r\n\r\n    /**\r\n     * Registers the specified type with a default instance creator.\r\n     *\r\n     * @param type the type to register\r\n     * @return this builder instance for chaining\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public GraphAdapterBuilder addType(Type type) {\r\n        ObjectConstructor<?> objectConstructor = constructorConstructor.get(TypeToken.get(type));\r\n        InstanceCreator<Object> instanceCreator = new InstanceCreator<Object>() {\r\n\r\n            @Override\r\n            public Object createInstance(Type type) {\r\n                return objectConstructor.construct();\r\n            }\r\n        };\r\n        return addType(type, instanceCreator);\r\n    }\r\n\r\n    /**\r\n     * Registers the specified type with the provided instance creator.\r\n     *\r\n     * @param type the type to register\r\n     * @param instanceCreator the instance creator used to create instances of the type during\r\n     *     deserialization\r\n     * @return this builder instance for chaining\r\n     */\r\n    @CanIgnoreReturnValue\r\n    public GraphAdapterBuilder addType(Type type, InstanceCreator<?> instanceCreator) {\r\n        if (type == null || instanceCreator == null) {\r\n            throw new NullPointerException();\r\n        }\r\n        instanceCreators.put(type, instanceCreator);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Registers the graph adapter on the provided {@link GsonBuilder}. This method adds a {@link\r\n     * TypeAdapterFactory} and registers the necessary type adapters for all types previously\r\n     * registered via {@link #addType(Type)}.\r\n     *\r\n     * @param gsonBuilder the {@code GsonBuilder} on which to register the graph adapter\r\n     */\r\n    public void registerOn(GsonBuilder gsonBuilder) {\r\n        // Create copy to allow reusing GraphAdapterBuilder without affecting adapter factory\r\n        Map<Type, InstanceCreator<?>> instanceCreators = new HashMap<>(this.instanceCreators);\r\n        Factory factory = new Factory(instanceCreators);\r\n        gsonBuilder.registerTypeAdapterFactory(factory);\r\n        for (Map.Entry<Type, InstanceCreator<?>> entry : instanceCreators.entrySet()) {\r\n            gsonBuilder.registerTypeAdapter(entry.getKey(), factory);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * A factory that creates type adapters capable of serializing and deserializing object graphs.\r\n     *\r\n     * <p>This factory implements both {@link TypeAdapterFactory} and {@link InstanceCreator}\r\n     * interfaces. It is responsible for handling cyclic references by assigning unique names to\r\n     * objects and managing a graph during both serialization and deserialization.\r\n     */\r\n    static class Factory implements TypeAdapterFactory, InstanceCreator<Object> {\r\n\r\n        private final Map<Type, InstanceCreator<?>> instanceCreators;\r\n\r\n        @SuppressWarnings(\"ThreadLocalUsage\")\r\n        private final ThreadLocal<Graph> graphThreadLocal = new ThreadLocal<>();\r\n\r\n        Factory(Map<Type, InstanceCreator<?>> instanceCreators) {\r\n            this.instanceCreators = instanceCreators;\r\n        }\r\n\r\n        @Override\r\n        public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\r\n            if (!instanceCreators.containsKey(type.getType())) {\r\n                return null;\r\n            }\r\n            TypeAdapter<T> typeAdapter = gson.getDelegateAdapter(this, type);\r\n            TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);\r\n            return new TypeAdapter<T>() {\r\n\r\n                @Override\r\n                public void write(JsonWriter out, T value) throws IOException {\r\n                    if (value == null) {\r\n                        out.nullValue();\r\n                        return;\r\n                    }\r\n                    Graph graph = graphThreadLocal.get();\r\n                    boolean writeEntireGraph = false;\r\n                    /*\r\n           * We have one of two cases:\r\n           *  1. We've encountered the first known object in this graph. Write\r\n           *     out the graph, starting with that object.\r\n           *  2. We've encountered another graph object in the course of #1.\r\n           *     Just write out this object's name. We'll circle back to writing\r\n           *     out the object's value as a part of #1.\r\n           */\r\n                    if (graph == null) {\r\n                        writeEntireGraph = true;\r\n                        graph = new Graph(new IdentityHashMap<Object, Element<?>>());\r\n                    }\r\n                    // graph.map guarantees consistency between value and T\r\n                    @SuppressWarnings(\"unchecked\")\r\n                    Element<T> element = (Element<T>) graph.map.get(value);\r\n                    if (element == null) {\r\n                        element = new Element<>(value, graph.nextName(), typeAdapter, null);\r\n                        graph.map.put(value, element);\r\n                        graph.queue.add(element);\r\n                    }\r\n                    if (writeEntireGraph) {\r\n                        graphThreadLocal.set(graph);\r\n                        try {\r\n                            out.beginObject();\r\n                            Element<?> current;\r\n                            while ((current = graph.queue.poll()) != null) {\r\n                                out.name(current.id);\r\n                                current.write(out);\r\n                            }\r\n                            out.endObject();\r\n                        } finally {\r\n                            graphThreadLocal.remove();\r\n                        }\r\n                    } else {\r\n                        out.value(element.id);\r\n                    }\r\n                }\r\n\r\n                @Override\r\n                public T read(JsonReader in) throws IOException {\r\n                    if (in.peek() == JsonToken.NULL) {\r\n                        in.nextNull();\r\n                        return null;\r\n                    }\r\n                    /*\r\n           * Again we have one of two cases:\r\n           *  1. We've encountered the first known object in this graph. Read\r\n           *     the entire graph in as a map from names to their JsonElements.\r\n           *     Then convert the first JsonElement to its Java object.\r\n           *  2. We've encountered another graph object in the course of #1.\r\n           *     Read in its name, then deserialize its value from the\r\n           *     JsonElement in our map. We need to do this lazily because we\r\n           *     don't know which TypeAdapter to use until a value is\r\n           *     encountered in the wild.\r\n           */\r\n                    String currentName = null;\r\n                    Graph graph = graphThreadLocal.get();\r\n                    boolean readEntireGraph = false;\r\n                    if (graph == null) {\r\n                        graph = new Graph(new HashMap<Object, Element<?>>());\r\n                        readEntireGraph = true;\r\n                        // read the entire tree into memory\r\n                        in.beginObject();\r\n                        while (in.hasNext()) {\r\n                            String name = in.nextName();\r\n                            if (currentName == null) {\r\n                                currentName = name;\r\n                            }\r\n                            JsonElement element = elementAdapter.read(in);\r\n                            graph.map.put(name, new Element<>(null, name, typeAdapter, element));\r\n                        }\r\n                        in.endObject();\r\n                    } else {\r\n                        currentName = in.nextString();\r\n                    }\r\n                    if (readEntireGraph) {\r\n                        graphThreadLocal.set(graph);\r\n                    }\r\n                    try {\r\n                        // graph.map guarantees consistency between value and T\r\n                        @SuppressWarnings(\"unchecked\")\r\n                        Element<T> element = (Element<T>) graph.map.get(currentName);\r\n                        // now that we know the typeAdapter for this name, go from JsonElement to 'T'\r\n                        if (element.value == null) {\r\n                            element.typeAdapter = typeAdapter;\r\n                            element.read(graph);\r\n                        }\r\n                        return element.value;\r\n                    } finally {\r\n                        if (readEntireGraph) {\r\n                            graphThreadLocal.remove();\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n        }\r\n\r\n        /**\r\n         * Hook for the graph adapter to get a reference to a deserialized value before that value is\r\n         * fully populated. This is useful to deserialize values that directly or indirectly reference\r\n         * themselves: we can hand out an instance before read() returns.\r\n         *\r\n         * <p>Gson should only ever call this method when we're expecting it to; that is only when we've\r\n         * called back into Gson to deserialize a tree.\r\n         */\r\n        @Override\r\n        public Object createInstance(Type type) {\r\n            Graph graph = graphThreadLocal.get();\r\n            if (graph == null || graph.nextCreate == null) {\r\n                throw new IllegalStateException(\"Unexpected call to createInstance() for \" + type);\r\n            }\r\n            InstanceCreator<?> creator = instanceCreators.get(type);\r\n            Object result = creator.createInstance(type);\r\n            graph.nextCreate.value = result;\r\n            graph.nextCreate = null;\r\n            return result;\r\n        }\r\n    }\r\n\r\n    static class Graph {\r\n\r\n        /**\r\n         * The graph elements. On serialization keys are objects (using an identity hash map) and on\r\n         * deserialization keys are the string names (using a standard hash map).\r\n         */\r\n        private final Map<Object, Element<?>> map;\r\n\r\n        /**\r\n         * The queue of elements to write during serialization. Unused during deserialization.\r\n         */\r\n        private final Queue<Element<?>> queue = new ArrayDeque<>();\r\n\r\n        /**\r\n         * The instance currently being deserialized. Used as a backdoor between the graph traversal\r\n         * (which needs to know instances) and instance creators which create them.\r\n         */\r\n        private Element<Object> nextCreate;\r\n\r\n        private Graph(Map<Object, Element<?>> map) {\r\n            this.map = map;\r\n        }\r\n\r\n        /**\r\n         * Returns a unique name for an element to be inserted into the graph.\r\n         */\r\n        public String nextName() {\r\n            return \"0x\" + Integer.toHexString(map.size() + 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * An element of the graph during serialization or deserialization.\r\n     */\r\n    static class Element<T> {\r\n\r\n        /**\r\n         * This element's name in the top level graph object.\r\n         */\r\n        private final String id;\r\n\r\n        /**\r\n         * The value if known. During deserialization this is lazily populated.\r\n         */\r\n        private T value;\r\n\r\n        /**\r\n         * This element's type adapter if known. During deserialization this is lazily populated.\r\n         */\r\n        private TypeAdapter<T> typeAdapter;\r\n\r\n        /**\r\n         * The element to deserialize. Unused in serialization.\r\n         */\r\n        private final JsonElement element;\r\n\r\n        Element(T value, String id, TypeAdapter<T> typeAdapter, JsonElement element) {\r\n            this.value = value;\r\n            this.id = id;\r\n            this.typeAdapter = typeAdapter;\r\n            this.element = element;\r\n        }\r\n\r\n        void write(JsonWriter out) throws IOException {\r\n            typeAdapter.write(out, value);\r\n        }\r\n\r\n        @SuppressWarnings(\"unchecked\")\r\n        void read(Graph graph) {\r\n            if (graph.nextCreate != null) {\r\n                throw new IllegalStateException(\"Unexpected recursive call to read() for \" + id);\r\n            }\r\n            graph.nextCreate = (Element<Object>) this;\r\n            value = typeAdapter.fromJsonTree(element);\r\n            if (value == null) {\r\n                throw new IllegalStateException(\"non-null value deserialized to null: \" + element);\r\n            }\r\n        }\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\graph\\GraphAdapterBuilder.java"
  },
  {
    "type": "field",
    "name": "instanceCreators",
    "start_line": 74,
    "end_line": 74,
    "code": "private final Map<Type, InstanceCreator<?>> instanceCreators;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\graph\\GraphAdapterBuilder.java"
  },
  {
    "type": "field",
    "name": "constructorConstructor",
    "start_line": 75,
    "end_line": 75,
    "code": "private final ConstructorConstructor constructorConstructor;",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\graph\\GraphAdapterBuilder.java"
  },
  {
    "type": "constructor",
    "name": "GraphAdapterBuilder",
    "start_line": 77,
    "end_line": 81,
    "code": "public GraphAdapterBuilder() {\r\n    this.instanceCreators = new HashMap<>();\r\n    this.constructorConstructor = new ConstructorConstructor(Collections.emptyMap(), true, Collections.emptyList());\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\graph\\GraphAdapterBuilder.java"
  },
  {
    "type": "method",
    "name": "addType",
    "start_line": 89,
    "end_line": 100,
    "code": "/**\r\n * Registers the specified type with a default instance creator.\r\n *\r\n * @param type the type to register\r\n * @return this builder instance for chaining\r\n */\r\n@CanIgnoreReturnValue\r\npublic GraphAdapterBuilder addType(Type type) {\r\n    ObjectConstructor<?> objectConstructor = constructorConstructor.get(TypeToken.get(type));\r\n    InstanceCreator<Object> instanceCreator = new InstanceCreator<Object>() {\r\n\r\n        @Override\r\n        public Object createInstance(Type type) {\r\n            return objectConstructor.construct();\r\n        }\r\n    };\r\n    return addType(type, instanceCreator);\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\graph\\GraphAdapterBuilder.java"
  },
  {
    "type": "method",
    "name": "addType",
    "start_line": 110,
    "end_line": 117,
    "code": "/**\r\n * Registers the specified type with the provided instance creator.\r\n *\r\n * @param type the type to register\r\n * @param instanceCreator the instance creator used to create instances of the type during\r\n *     deserialization\r\n * @return this builder instance for chaining\r\n */\r\n@CanIgnoreReturnValue\r\npublic GraphAdapterBuilder addType(Type type, InstanceCreator<?> instanceCreator) {\r\n    if (type == null || instanceCreator == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    instanceCreators.put(type, instanceCreator);\r\n    return this;\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\graph\\GraphAdapterBuilder.java"
  },
  {
    "type": "method",
    "name": "registerOn",
    "start_line": 126,
    "end_line": 134,
    "code": "/**\r\n * Registers the graph adapter on the provided {@link GsonBuilder}. This method adds a {@link\r\n * TypeAdapterFactory} and registers the necessary type adapters for all types previously\r\n * registered via {@link #addType(Type)}.\r\n *\r\n * @param gsonBuilder the {@code GsonBuilder} on which to register the graph adapter\r\n */\r\npublic void registerOn(GsonBuilder gsonBuilder) {\r\n    // Create copy to allow reusing GraphAdapterBuilder without affecting adapter factory\r\n    Map<Type, InstanceCreator<?>> instanceCreators = new HashMap<>(this.instanceCreators);\r\n    Factory factory = new Factory(instanceCreators);\r\n    gsonBuilder.registerTypeAdapterFactory(factory);\r\n    for (Map.Entry<Type, InstanceCreator<?>> entry : instanceCreators.entrySet()) {\r\n        gsonBuilder.registerTypeAdapter(entry.getKey(), factory);\r\n    }\r\n}",
    "file_path": "C:\\Users\\su9ki\\Desktop\\git-ai\\git-agent\\repository\\gson\\extras\\src\\main\\java\\com\\google\\gson\\graph\\GraphAdapterBuilder.java"
  }
]